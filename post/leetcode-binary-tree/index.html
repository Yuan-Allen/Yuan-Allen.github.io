<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäºŒå‰æ ‘ç¯‡ï¼‰ | AllenY&#39;s blog</title>
<link rel="shortcut icon" href="https://alleny.xyz/favicon.ico?v=1747120786321">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://alleny.xyz/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäºŒå‰æ ‘ç¯‡ï¼‰ | AllenY&#39;s blog - Atom Feed" href="https://alleny.xyz/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-HPLP8D1S43"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HPLP8D1S43');
</script>


    <meta name="description" content="LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäºŒå‰æ ‘ç¯‡ï¼‰ï¼Œä¸ªäººå‘ã€‚
è¿™éƒ¨åˆ†æ¶‰åŠé¢‘ç¹çš„æŒ‡é’ˆæ“ä½œï¼Œå› æ­¤ä¸“ç²¾C++æ¥åšé¢˜ã€‚

[144]ã€[145]ã€[94]

éš¾åº¦ï¼šEasy
è¯­è¨€ï¼šC++

é¢˜ç›®æè¿°å°±ä¸æ”¾äº†ï¼Œå°±æ˜¯äºŒå‰æ ‘çš„å‰ä¸­ååºéå†ã€‚è€ƒå¯Ÿæœ€åŸºæœ¬çš„æ•°æ®ç»“æ„äº†è§£ç¨‹åº¦..." />
    <meta name="keywords" content="LeetCode" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://alleny.xyz">
  <img class="avatar" src="https://alleny.xyz/images/avatar.png?v=1747120786321" alt="">
  </a>
  <h1 class="site-title">
    AllenY&#39;s blog
  </h1>
  <p class="site-description">
    ğŸ§‘ğŸ»â€ğŸ’»ğŸ®ğŸ¿ğŸ¹ğŸ—»
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu">
          Archive
        </a>
      
    
      
        <a href="/tags" class="menu">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu">
          About
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Yuan-Allen" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
        <a href="https://weibo.com/u/6478080851" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäºŒå‰æ ‘ç¯‡ï¼‰
            </h2>
            <div class="post-info">
              <span>
                2024-09-25
              </span>
              <span>
                36 min read
              </span>
              
                <a href="https://alleny.xyz/tag/leetcode/" class="post-tag">
                  # LeetCode
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>LeetCodeåˆ·é¢˜è®°å½•ï¼ˆäºŒå‰æ ‘ç¯‡ï¼‰ï¼Œä¸ªäººå‘ã€‚<br>
è¿™éƒ¨åˆ†æ¶‰åŠé¢‘ç¹çš„æŒ‡é’ˆæ“ä½œï¼Œå› æ­¤ä¸“ç²¾C++æ¥åšé¢˜ã€‚</p>
<!-- more -->
<h2 id="144-145-94">[144]ã€[145]ã€[94]</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p>é¢˜ç›®æè¿°å°±ä¸æ”¾äº†ï¼Œå°±æ˜¯äºŒå‰æ ‘çš„å‰ä¸­ååºéå†ã€‚è€ƒå¯Ÿæœ€åŸºæœ¬çš„æ•°æ®ç»“æ„äº†è§£ç¨‹åº¦ï¼Œæ— éš¾åº¦ã€‚è¿™é‡Œæ”¾å‡ ç§ä¸åŒçš„å®ç°æ–¹å¼ã€‚</p>
<h3 id="é€’å½’éå†">é€’å½’éå†</h3>
<p>å‰åºéå†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  void traverse(TreeNode* cur, vector&lt;int&gt;&amp; res) {
    if (!cur) {
      return;
    }
    res.push_back(cur-&gt;val);
    traverse(cur-&gt;left, res);
    traverse(cur-&gt;right, res);
  }

  vector&lt;int&gt; preorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    traverse(root, res);
    return res;
  }
};
</code></pre>
<p>ååºéå†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  void traverse(TreeNode* cur, vector&lt;int&gt;&amp; res) {
    if (!cur) {
      return;
    }
    traverse(cur-&gt;left, res);
    traverse(cur-&gt;right, res);
    res.push_back(cur-&gt;val);
  }

  vector&lt;int&gt; postorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    traverse(root, res);
    return res;
  }
};
</code></pre>
<p>ä¸­åºéå†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  void traverse(TreeNode* cur, vector&lt;int&gt;&amp; res) {
    if (!cur) {
      return;
    }
    traverse(cur-&gt;left, res);
    res.push_back(cur-&gt;val);
    traverse(cur-&gt;right, res);
  }

  vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    traverse(root, res);
    return res;
  }
};
</code></pre>
<p>ä¸‰ç§éå†çš„é€’å½’å†™æ³•ä»£ç åŸºæœ¬ä¸€æ ·ï¼Œæ”¹ä¸‹<code>traverse</code>é‡Œé¢é¡ºåºå³å¯ã€‚</p>
<h3 id="è¿­ä»£éå†">è¿­ä»£éå†</h3>
<p>å‰åºéå†ã€‚ä½¿ç”¨æ ˆæ¥å­˜æ”¾èŠ‚ç‚¹ã€‚<br>
æ³¨æ„è¦å…ˆå…¥å³èŠ‚ç‚¹å†å…¥å·¦èŠ‚ç‚¹ï¼Œè¿™æ ·å·¦èŠ‚ç‚¹ä¼šå…ˆå‡ºæ ˆï¼Œæ‰ç¬¦åˆå‰åºéå†é¡ºåºã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; preorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (!root) return result;
    st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      result.push_back(cur-&gt;val);
      if (cur-&gt;right) st.push(cur-&gt;right);
      if (cur-&gt;left) st.push(cur-&gt;left);
    }
    return result;
  }
};
</code></pre>
<p>ååºéå†ã€‚å’Œå‰åºéå†ç±»ä¼¼ã€‚<br>
ä¸ºäº†æ»¡è¶³åç»­éå†çš„é¡ºåºï¼Œæˆ‘ä»¬å¯ä»¥äº¤æ¢å·¦å³èŠ‚ç‚¹å…¥æ ˆçš„é¡ºåºï¼ˆå³å…ˆå…¥å·¦èŠ‚ç‚¹å†å…¥å³èŠ‚ç‚¹ï¼‰ï¼Œæœ€åå†æŠŠç»“æœåè½¬ä¸€ä¸‹é¡ºåºã€‚<br>
è¿™æ ·ä¸€æ¥ï¼ŒåŸæœ¬å‰åºéå†ä¸º<strong>ä¸­å·¦å³</strong>ï¼Œäº¤æ¢å…¥æ ˆé¡ºåºå˜æˆ<strong>ä¸­å³å·¦</strong>ï¼Œç»“æœåè½¬åå˜æˆ<strong>å·¦å³ä¸­</strong>ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; postorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (!root) return result;
    st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      result.push_back(cur-&gt;val);
      if (cur-&gt;left) st.push(cur-&gt;left);
      if (cur-&gt;right) st.push(cur-&gt;right);
    }
    reverse(result.begin(), result.end());
    return result;
  }
};
</code></pre>
<p>ä¸­åºéå†ä¼šæ›´éº»çƒ¦äº›ã€‚åœ¨å‰åºéå†ä¸­ï¼Œå½“å‰èŠ‚ç‚¹è®¿é—®è¿‡å°±å¯ä»¥ä¸¢æ‰äº†ï¼Œä½†æ˜¯åœ¨ä¸­åºéå†ä¸­æˆ‘ä»¬éœ€è¦æŠŠå½“å‰èŠ‚ç‚¹å…ˆå…¥æ ˆå­˜èµ·æ¥ï¼Œå¹¶å°½é‡çš„å…ˆå¾€å·¦éå†ï¼Œç›´åˆ°éå†åˆ°å¤´å†å°è¯•å¼¹æ ˆå¹¶å¾€å³ç§»åŠ¨ã€‚<br>
æ³¨æ„åœ¨ååºéå†ä¸­ï¼Œæˆ‘ä»¬é€šè¿‡ç»“æœåè½¬çš„æ–¹å¼å·§å¦™è§„é¿äº†è¿™äº›é—®é¢˜ï¼Œä½†ä¸­åºéå†å°±ä¸è¡Œäº†ã€‚<br>
åœ¨å†™ä»£ç æ—¶è¯·æ³¨æ„åœ¨ç©ºèŠ‚ç‚¹æ˜¯å¦å…¥æ ˆä¸Šè¾¾æˆç»Ÿä¸€æ„è§ï¼ˆä»¥é˜²æ­¢å†™å‡ºbugï¼‰ï¼Œæœ¬äººç»™å‡ºçš„æ˜¯ç©ºèŠ‚ç‚¹ä¸å…¥æ ˆçš„å†™æ³•ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    TreeNode* cur = root;
    while (cur || !st.empty()) {
      if (cur) {
        st.push(cur);
        cur = cur-&gt;left;
      } else {
        cur = st.top();
        st.pop();
        result.push_back(cur-&gt;val);
        cur = cur-&gt;right;
      }
    }
    return result;
  }
};
</code></pre>
<h3 id="ç»Ÿä¸€è¿­ä»£æ³•">ç»Ÿä¸€è¿­ä»£æ³•</h3>
<p>åœ¨å‰é¢çš„è¿­ä»£æ–¹æ³•ä¸­ï¼Œå‰ä¸­ååºçš„å†™æ³•éƒ½ä¸ä¸€æ ·ï¼Œæ²¡æœ‰åšåˆ°åƒé€’å½’éå†ä¸€æ ·çš„ç¨å¾®æ”¹ä¸‹ä»£ç é¡ºåºå³å¯ã€‚å› æ­¤ï¼Œå¯¹äºéé€’å½’çš„æ–¹æ³•ï¼Œä¹Ÿæœ‰ç»Ÿä¸€çš„å†™æ³•ï¼Œå¯åšåˆ°ç¨å¾®æ”¹ä¸‹ä»£ç é¡ºåºå³å¯æ›´æ”¹éå†é¡ºåºã€‚<br>
ç»Ÿä¸€è¿­ä»£æ³•çš„å…³é”®æ˜¯ï¼Œåˆ©ç”¨äº†ç©ºæŒ‡é’ˆæ¥åšæ ‡è®°ï¼Œå³è®¿é—®åˆ°çš„èŠ‚ç‚¹åä¼šå†è·Ÿä¸€ä¸ªç©ºæŒ‡é’ˆå…¥æ ˆï¼Œå¼¹æ ˆæ—¶é‡åˆ°ç©ºæŒ‡é’ˆæ‰æŠŠåé¢çš„èŠ‚ç‚¹è¿›è¡Œå¤„ç†ï¼ˆåŠ å…¥ç»“æœé›†ï¼‰ã€‚<strong>å³ä¸€ä¸ªèŠ‚ç‚¹å®é™…ä¸Šä¼šå…¥æ ˆå‡ºæ ˆä¸¤æ¬¡ï¼Œç¬¬ä¸€æ¬¡ï¼ˆå…¥æ ˆä¸å¸¦ç©ºæŒ‡é’ˆï¼‰ä»£è¡¨è®¿é—®åˆ°ï¼ˆä»…ä»…æ˜¯è·¯è¿‡ï¼‰ï¼Œç¬¬äºŒæ¬¡ï¼ˆå…¥æ ˆåå¸¦ç©ºæŒ‡é’ˆï¼‰æ‰ä»£è¡¨è¦å¤„ç†è¯¥èŠ‚ç‚¹ã€‚</strong><br>
äºæ˜¯ï¼Œæˆ‘ä»¬å¯ä»¥å¾ˆå®¹æ˜“å¾—åˆ°ä¸‰ç§éå†çš„å†™æ³•ã€‚<br>
å‰åºéå†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; preorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (root) st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      if (cur) {
        if (cur-&gt;right) st.push(cur-&gt;right);
        if (cur-&gt;left) st.push(cur-&gt;left);
        st.push(cur);
        st.push(nullptr);
      } else {
        result.push_back(st.top()-&gt;val);
        st.pop();
      }
    }
    return result;
  }
};
</code></pre>
<p>ååºéå†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; postorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (root) st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      if (cur) {
        st.push(cur);
        st.push(nullptr);
        if (cur-&gt;right) st.push(cur-&gt;right);
        if (cur-&gt;left) st.push(cur-&gt;left);
      } else {
        result.push_back(st.top()-&gt;val);
        st.pop();
      }
    }
    return result;
  }
};
</code></pre>
<p>ä¸­åºéå†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (root) st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      if (cur) {
        if (cur-&gt;right) st.push(cur-&gt;right);
        st.push(cur);
        st.push(nullptr);
        if (cur-&gt;left) st.push(cur-&gt;left);
      } else {
        result.push_back(st.top()-&gt;val);
        st.pop();
      }
    }
    return result;
  }
};
</code></pre>
<h2 id="102-binary-tree-level-order-traversal">[102] Binary Tree Level Order Traversal</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
äºŒå‰æ ‘çš„å±‚åºéå†ï¼Œä¹Ÿå±äºæ•°æ®ç»“æ„çš„åŸºæœ¬æ“ä½œã€‚<br>
å±‚åºéå†å…¶å®å°±ç›¸å½“äºå›¾è®ºçš„å¹¿åº¦ä¼˜å…ˆæœç´¢ã€‚åªä¸è¿‡ï¼Œè¿™é“é¢˜çš„è¿”å›ç±»å‹æ˜¯äºŒç»´<code>vector</code>ï¼Œå³è¦æ±‚æŠŠæ¯ä¸€å±‚çš„èŠ‚ç‚¹å•ç‹¬ä½œä¸ºä¸€ä¸ª<code>vector&lt;int&gt;</code>åˆ†å‡ºæ¥ï¼Œå› æ­¤æˆ‘ä»¬åœ¨å†…éƒ¨åµŒå¥—ä¸€ä¸ªå¾ªç¯æ¥ä¸“é—¨å¤„ç†æŸä¸€å±‚çš„èŠ‚ç‚¹ã€‚å¦åˆ™ï¼Œæˆ‘ä»¬åªä¿ç•™æœ€å¤–å±‚çš„<code>while</code>å¾ªç¯å³å¯ï¼ˆä¸å…³å¿ƒæ¯å±‚çš„èŠ‚ç‚¹ä»ä»€ä¹ˆåœ°æ–¹å¼€å§‹å’Œç»“æŸï¼Œå³é€€åŒ–åˆ°å¹¿åº¦ä¼˜å…ˆæœç´¢ï¼‰ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
    vector&lt;vector&lt;int&gt;&gt; result;
    if (!root) {
      return result;
    }

    queue&lt;TreeNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
      int level_width = q.size();
      vector&lt;int&gt; cur_level;
      while (level_width-- &gt; 0) {
        TreeNode* cur = q.front();
        q.pop();
        cur_level.push_back(cur-&gt;val);
        if (cur-&gt;left) {
          q.push(cur-&gt;left);
        }
        if (cur-&gt;right) {
          q.push(cur-&gt;right);
        }
      }
      result.push_back(cur_level);
    }

    return result;
  }
};
</code></pre>
<h2 id="226-invert-binary-tree">[226] Invert Binary Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ä¹‹å‰è®²äº†å¾ˆå¤šç§éå†æ–¹æ³•ï¼Œéšä¾¿é€‰ä¸€ç§ç”¨ï¼Œéå†çš„åŒæ—¶äº¤æ¢å½“å‰èŠ‚ç‚¹çš„å·¦å³å„¿å­å³å¯ã€‚è¿™é‡Œæˆ‘é€‰ç”¨çš„æ˜¯é€’å½’å‰åºéå†ã€‚<br>
éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œå¦‚æœé€‰ç”¨çš„æ˜¯é€’å½’ä¸­åºéå†ï¼Œä¸¤æ¬¡<code>traversal</code>éƒ½è¦å¯¹<code>cur-&gt;left</code>è¿›è¡Œï¼Œå› ä¸ºå·¦å³å„¿å­åœ¨ä¸­é—´è¢«äº¤æ¢äº†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  void traversal(TreeNode* cur) {
    if (!cur) {
      return;
    }
    TreeNode* tmp = cur-&gt;left;
    cur-&gt;left = cur-&gt;right;
    cur-&gt;right = tmp;
    traversal(cur-&gt;left);
    traversal(cur-&gt;right);
  }
  TreeNode* invertTree(TreeNode* root) {
    traversal(root);
    return root;
  }
};
</code></pre>
<h2 id="101-symmetric-tree">[101] Symmetric Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/symmetric-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åŒæ—¶éå†æ ¹èŠ‚ç‚¹çš„å·¦å³å­æ ‘ï¼Œéå†çš„åŒæ—¶è¿›è¡Œæ¯”è¾ƒå³å¯ã€‚æ³¨æ„å·¦å­æ ‘çš„<code>left</code>å’Œå³å­æ ‘çš„<code>right</code>æ¯”è¾ƒï¼Œå·¦å­æ ‘çš„<code>right</code>å’Œå³å­æ ‘çš„<code>left</code>æ¯”è¾ƒã€‚<br>
è¿™é‡Œä½¿ç”¨çš„æ˜¯é€’å½’çš„å†™æ³•ã€‚å®é™…ä¸Šï¼Œç”¨é˜Ÿåˆ—æˆ–è€…æ ˆç­‰ç­‰ä¹Ÿå¯ä»¥æœ‰ä¸é€’å½’çš„å†™æ³•ï¼ˆè¿­ä»£æ³•ï¼‰ã€‚å…·ä½“æ¥è¯´ï¼Œå°±æ˜¯æŠŠ<code>left_cur-&gt;left, right_cur-&gt;right</code>æ”¾è¿›å®¹å™¨ä¸­ï¼Œ<code>left_cur-&gt;right, right_cur-&gt;left</code>æ”¾è¿›å®¹å™¨ä¸­ï¼Œç„¶åæˆå¯¹ä»å®¹å™¨ä¸­å–å…ƒç´ ï¼Œè¿›è¡Œåˆ¤æ–­å³å¯ã€‚å…·ä½“å¯è§è¿™ç¯‡<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md">solution</a>ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  bool traversal(TreeNode* left_cur, TreeNode* right_cur) {
    if (!left_cur || !right_cur) {
      if (left_cur == right_cur) {
        return true;
      } else {
        return false;
      }
    }

    if (left_cur-&gt;val != right_cur-&gt;val) {
      return false;
    }

    return traversal(left_cur-&gt;left, right_cur-&gt;right) &amp;&amp;
           traversal(left_cur-&gt;right, right_cur-&gt;left);
  }

  bool isSymmetric(TreeNode* root) {
    if (!root) {
      return true;
    }

    return traversal(root-&gt;left, root-&gt;right);
  }
};
</code></pre>
<h2 id="104-maximum-depth-of-binary-tree">[104] Maximum Depth of Binary Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
æ¯”è¾ƒé—²å°±é¡ºæ‰‹å†™äº†éé€’å½’å±‚åºå’Œé€’å½’å‰åºçš„ä¸¤ç§å†™æ³•ã€‚äº‹å®ä¸Šè¿™é“é¢˜å†™æ³•åº”è¯¥å¾ˆå¤šï¼Œè¦åšçš„å°±åªæ˜¯åœ¨éå†çš„åŒæ—¶è®°å½•ä¸€ä¸‹æ·±åº¦å³å¯ã€‚åœ¨è¿™é‡Œçš„è¯ï¼Œæˆ‘é€‰æ‹©åœ¨éé€’å½’å±‚åºéå†æ—¶ç”¨ç©ºæŒ‡é’ˆè®°å½•ä¸€å±‚çš„ç»“æŸï¼Œç„¶åç›´æ¥<code>++max_depth</code>ï¼›åœ¨é€’å½’å‰åºéå†ä¸­æˆ‘é€‰æ‹©è®°å½•<code>cur_level</code>å¹¶çœ‹æ¡ä»¶æ›´æ–°<code>max_level</code>ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  int maxDepthLevel(TreeNode* root) {
    if (!root) {
      return 0;
    }

    int max_depth = 0;
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    q.push(nullptr);
    while (!q.empty()) {
      TreeNode* cur = q.front();
      q.pop();
      if (!cur) {
        ++max_depth;
        if (!q.empty()) {
          // Not the last level
          q.push(nullptr);
        }
      } else {
        if (cur-&gt;left) {
          q.push(cur-&gt;left);
        }
        if (cur-&gt;right) {
          q.push(cur-&gt;right);
        }
      }
    }
    return max_depth;
  }

  void traversal(TreeNode* cur, int cur_level, int&amp; max_level) {
    if (!cur) {
      return;
    }
    cur_level += 1;
    max_level = cur_level &gt; max_level ? cur_level : max_level;
    traversal(cur-&gt;left, cur_level, max_level);
    traversal(cur-&gt;right, cur_level, max_level);
  }

  int maxDepth(TreeNode* root) {
    int max_level = 0;
    traversal(root, 0, max_level);
    return max_level;
  }
};
</code></pre>
<h2 id="111-minimum-depth-of-binary-tree">[111] Minimum Depth of Binary Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åœ¨<a href="#104-maximum-depth-of-binary-tree">104</a>çš„åŸºç¡€ä¸Šç¨åŠ æ”¹åŠ¨å³å¯ã€‚åœ¨éå†çš„æ—¶å€™ï¼Œé‡åˆ°å½“å‰èŠ‚ç‚¹çš„å·¦å³å„¿å­éƒ½æ˜¯ç©ºæŒ‡é’ˆï¼Œè¯´æ˜é‡åˆ°å¶å­èŠ‚ç‚¹ï¼Œå°±å¯ä»¥å°è¯•æ›´æ–°<code>min_level</code>äº†ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  void traversal(TreeNode* cur, int cur_level, int&amp; min_level) {
    if (!cur) {
      return;
    }
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right) {
      min_level = cur_level &lt; min_level ? cur_level : min_level;
    }
    traversal(cur-&gt;left, cur_level + 1, min_level);
    traversal(cur-&gt;right, cur_level + 1, min_level);
  }

  int minDepth(TreeNode* root) {
    if (!root) {
      return 0;
    }

    int min_level = __INT_MAX__;
    traversal(root, 1, min_level);
    return min_level;
  }
};
</code></pre>
<h2 id="222-count-complete-tree-nodes">[222] Count Complete Tree Nodes</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å¾€ä¸‹éå†çš„è¿‡ç¨‹ä¸­ä¸€å®šä¼šé‡åˆ°æ»¡äºŒå‰æ ‘ï¼Œå¯¹äºæ»¡äºŒå‰æ ‘å¯ä»¥ç”¨<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>âˆ’</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">âˆ’</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>çš„å…¬å¼å¿«é€Ÿè®¡ç®—æ•°é‡ã€‚å¯ä»¥ç”¨å‘å·¦éå†å’Œå‘å³éå†çš„æ·±åº¦æ˜¯å¦ä¸€è‡´æ¥åˆ¤æ–­å½“å‰å­æ ‘æ˜¯å¦ä¸ºæ»¡äºŒå‰æ ‘ï¼Œå¦‚ä¸æ˜¯ï¼Œåˆ™å¾€å·¦å³å­æ ‘ç»§ç»­é€’å½’ï¼ˆååºéå†ï¼‰å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  int countNodes(TreeNode* root) {
    if (!root) {
      return 0;
    }

    TreeNode* left = root-&gt;left;
    TreeNode* right = root-&gt;right;
    int left_depth = 0;
    int right_depth = 0;
    while (left) {
      left = left-&gt;left;
      left_depth += 1;
    }
    while (right) {
      right = right-&gt;right;
      right_depth += 1;
    }
    if (left_depth == right_depth) {
      return (2 &lt;&lt; left_depth) - 1;
    }

    return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
  }
};
</code></pre>
<h2 id="110-balanced-binary-tree">[110] Balanced Binary Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ä½¿ç”¨ååºéå†è·å–èŠ‚ç‚¹é«˜åº¦ï¼ŒåŒæ—¶ä½¿ç”¨-1æ¥è¡¨ç¤ºå­æ ‘ä¸å¹³è¡¡ã€‚åœ¨éå†çš„åŒæ—¶æ¯”è¾ƒå·¦å³å­æ ‘çš„é«˜åº¦ï¼Œå¦‚æœé«˜åº¦å·®å€¼ç»å¯¹å€¼å¤§äº1åˆ™è¿”å›-1å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  int getHeight(TreeNode* cur) {
    if (!cur) {
      return 0;
    }

    int left_height = getHeight(cur-&gt;left);
    if (left_height &lt; 0) {
      return -1;
    }
    int right_height = getHeight(cur-&gt;right);
    if (right_height &lt; 0) {
      return -1;
    }

    if (abs(left_height - right_height) &gt; 1) {
      return -1;
    }

    return max(left_height, right_height) + 1;
  }

  bool isBalanced(TreeNode* root) { return getHeight(root) &gt;= 0; }
};
</code></pre>
<h2 id="257-binary-tree-paths">[257] Binary Tree Paths</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p>å‰åºéå†çš„åŒæ—¶ï¼Œè®°å½•å½“å‰èµ°è¿‡çš„è·¯å¾„ï¼ˆ<code>cur_path</code>ï¼‰ï¼Œåœ¨é‡åˆ°å¶å­èŠ‚ç‚¹æ—¶å†å­˜å…¥<code>all_path</code>å³å¯ã€‚ç”±äºé¢˜ç›®è¦æ±‚å­—ç¬¦ä¸²æ ¼å¼çš„è·¯å¾„ï¼Œæ‰€ä»¥å¢åŠ äº†<code>pathToString</code>ç”¨æ¥æŠŠ<code>vector&lt;TreeNode*&gt;</code>è½¬ä¸º<code>string</code>ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  string pathToString(vector&lt;TreeNode*&gt; path) {
    string s;
    for (TreeNode* node : path) {
      s.append(to_string(node-&gt;val));
      s.append(&quot;-&gt;&quot;);
    }
    s.erase(s.end() - 2, s.end());
    return s;
  }

  void traverse(TreeNode* cur, vector&lt;string&gt;&amp; all_paths,
                vector&lt;TreeNode*&gt; cur_path) {
    cur_path.push_back(cur);
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right) {
      all_paths.push_back(pathToString(cur_path));
      return;
    }
    if (cur-&gt;left) {
      traverse(cur-&gt;left, all_paths, cur_path);
    }
    if (cur-&gt;right) {
      traverse(cur-&gt;right, all_paths, cur_path);
    }
  }

  vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
    vector&lt;string&gt; result;
    if (!root) {
      return result;
    }
    vector&lt;TreeNode*&gt; cur_path;
    traverse(root, result, cur_path);
    return result;
  }
};
</code></pre>
<h2 id="404-sum-of-left-leaves">[404] Sum of Left Leaves</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
æ— ä»€ä¹ˆéš¾åº¦çš„é¢˜ç›®ã€‚éå†çš„åŒæ—¶ä½¿ç”¨ä¸€ä¸ªå‚æ•°<code>left_falg</code>æ¥è®°å½•å½“å‰èŠ‚ç‚¹æ˜¯å¦æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å„¿å­å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  int traverse(TreeNode* cur, bool left_flag) {
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right) {
      return left_flag ? cur-&gt;val : 0;
    }

    int sum = 0;
    if (cur-&gt;left) {
      sum += traverse(cur-&gt;left, true);
    }
    if (cur-&gt;right) {
      sum += traverse(cur-&gt;right, false);
    }
    return sum;
  }

  int sumOfLeftLeaves(TreeNode* root) {
    if (!root) {
      return 0;
    }
    return traverse(root, false);
  }
};
</code></pre>
<h2 id="513-find-bottom-left-tree-value">[513] Find Bottom Left Tree Value</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å¾ˆå®¹æ˜“æƒ³åˆ°ä½¿ç”¨å±‚åºéå†ï¼Œè®°å½•æœ€åä¸€å±‚æœ€å·¦è¾¹çš„èŠ‚ç‚¹å³å¯ã€‚è¿™é‡Œä¹Ÿå†™äº†ä¸€ä¸ªé€’å½’çš„å†™æ³•ï¼Œåœ¨éå†çš„åŒæ—¶è®°å½•å½“å‰æ·±åº¦ï¼Œç”±äºæ˜¯å‰åºéå†ï¼ˆå…ˆå·¦åå³ï¼‰ï¼Œæ‰€ä»¥åœ¨ç¬¬ä¸€æ¬¡åˆ°è¾¾æ–°çš„æ·±åº¦æ—¶è®°å½•èŠ‚ç‚¹å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  void traversal(TreeNode* cur, int cur_level, int&amp; left_most_val,
                 int&amp; most_level) {
    if (cur_level &gt; most_level) {
      left_most_val = cur-&gt;val;
      most_level = cur_level;
    }
    if (cur-&gt;left) {
      traversal(cur-&gt;left, cur_level + 1, left_most_val, most_level);
    }
    if (cur-&gt;right) {
      traversal(cur-&gt;right, cur_level + 1, left_most_val, most_level);
    }
  }

  int findBottomLeftValueRecursive(TreeNode* root) {
    int left_most_val = 0;
    int most_level = 0;
    if (!root) {
      return left_most_val;
    }

    traversal(root, 1, left_most_val, most_level);

    return left_most_val;
  }

  int findBottomLeftValue(TreeNode* root) {
    int left_most_val = 0;
    if (!root) {
      return left_most_val;
    }
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
      int width = q.size();
      for (int i = 0; i &lt; width; ++i) {
        TreeNode* cur = q.front();
        q.pop();
        if (i == 0) {
          left_most_val = cur-&gt;val;
        }
        if (cur-&gt;left) {
          q.push(cur-&gt;left);
        }
        if (cur-&gt;right) {
          q.push(cur-&gt;right);
        }
      }
    }
    return left_most_val;
  }
};
</code></pre>
<h2 id="112-path-sum">[112] Path Sum</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/path-sum/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åœ¨éå†çš„åŒæ—¶è®°å½•ä¸€ä¸‹å½“å‰<code>cur_sum</code>ï¼Œåœ¨é‡åˆ°å¶å­èŠ‚ç‚¹æ—¶å†åˆ¤æ–­ä¸€ä¸‹æ˜¯å¦ç­‰äº<code>target</code>å³å¯ã€‚<br>
ä¹Ÿå¯ä»¥æ¢æˆæŠŠä¸€ä¸ªå‚æ•°é€’å‡ä¸€ç›´å‡åˆ°0è€Œä¸æ˜¯æ±‚å’Œç„¶ååˆ¤æ–­æ˜¯å¦ç›¸ç­‰ï¼Œè¿™æ ·ä»£ç å¯ä»¥æ›´ç®€æ´ï¼Œå¯å‚è€ƒ<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.md">è¿™ç¯‡</a>ã€‚<br>
ä¹Ÿå¯ä»¥ç”¨è¿­ä»£çš„æ–¹å¼ï¼Œä½¿ç”¨<code>pair&lt;TreeNode*, int&gt;</code>æ¥å­˜å‚¨èŠ‚ç‚¹æŒ‡é’ˆå’Œå¯¹åº”çš„è·¯å¾„æ•°å€¼å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  bool traversal(TreeNode* cur, int cur_sum, int target) {
    cur_sum += cur-&gt;val;
    bool result = false;
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; cur_sum == target) {
      return true;
    }
    if (cur-&gt;left) {
      result |= traversal(cur-&gt;left, cur_sum, target);
    }
    if (!result &amp;&amp; cur-&gt;right) {
      result |= traversal(cur-&gt;right, cur_sum, target);
    }
    return result;
  }
  bool hasPathSum(TreeNode* root, int targetSum) {
    if (!root) {
      return false;
    }
    return traversal(root, 0, targetSum);
  }
};
</code></pre>
<h2 id="106-construct-binary-tree-from-inorder-and-postorder-traversal">[106] Construct Binary Tree from Inorder and Postorder Traversal</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ååºéå†çš„æœ€åä¸€ä¸ªä¸€å®šæ˜¯æ ¹èŠ‚ç‚¹ã€‚åˆ©ç”¨è¿™ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬ä½¿ç”¨è¯¥èŠ‚ç‚¹åœ¨ä¸­åºéå†ä¸­åˆ’åˆ†å·¦å³å­æ ‘ï¼Œç„¶åå†ä¾æ¬¡åœ¨å·¦å³å­æ ‘ä¸­é€’å½’å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* traversal(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder,
                      int inorder_begin, int inorder_end, int postorder_begin,
                      int postorder_end) {
    if (postorder_begin == postorder_end) {
      return nullptr;
    }
    int cur_val = postorder[postorder_end - 1];
    TreeNode* cur = new TreeNode(cur_val);
    if (postorder_begin + 1 &lt; postorder_end) {  // early stop
      for (int i = inorder_begin; i &lt; inorder_end; ++i) {
        if (inorder[i] == cur_val) {
          cur-&gt;left =
              traversal(inorder, postorder, inorder_begin, i, postorder_begin,
                        postorder_begin + i - inorder_begin);
          cur-&gt;right =
              traversal(inorder, postorder, i + 1, inorder_end,
                        postorder_begin + i - inorder_begin, postorder_end - 1);

          break;
        }
      }
    }

    return cur;
  }

  TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
    int size = inorder.size();
    TreeNode* root = traversal(inorder, postorder, 0, size, 0, size);
    return root;
  }
};
</code></pre>
<h2 id="654-maximum-binary-tree">[654] Maximum Binary Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
é€’å½’çš„åŒæ—¶æ‰¾ä¸€ä¸‹å½“å‰<code>index</code>èŒƒå›´å†…çš„æœ€å¤§å€¼ä½œä¸ºå½“å‰<code>TreeNode</code>ï¼Œç„¶åé€’å½’æ‰¾<code>[left_index, max_index)</code>å’Œ<code>[max_index + 1, right_index)</code>å³å¯ï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left_index, int right_index) {
    if (right_index - left_index == 1) {
      return new TreeNode(nums[left_index]);
    }

    int max_index = left_index;
    int max_val = -1;
    for (int i = left_index; i &lt; right_index; ++i) {
      if (nums[i] &gt; max_val) {
        max_val = nums[i];
        max_index = i;
      }
    }
    TreeNode* cur = new TreeNode(max_val);
    if (max_index &gt; left_index) {
      cur-&gt;left = traversal(nums, left_index, max_index);
    }
    if (right_index &gt; max_index + 1) {
      cur-&gt;right = traversal(nums, max_index + 1, right_index);
    }
    return cur;
  }
  TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {
    return traversal(nums, 0, nums.size());
  }
};
</code></pre>
<h2 id="617-merge-two-binary-trees">[617] Merge Two Binary Trees</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åŒæ—¶éå†ä¸¤æ£µæ ‘å³å¯ï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ã€‚<br>
è¿™é‡Œå¤ç”¨äº†ä¸¤æ£µæ ‘çš„èŠ‚ç‚¹ã€‚å¦‚æœä¸æƒ³å¤ç”¨ä¹Ÿå¯ä¸€è·¯åˆ›å»ºæ–°èŠ‚ç‚¹å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (!root1) return root2;
    if (!root2) return root1;

    TreeNode* cur = new TreeNode(root1-&gt;val + root2-&gt;val);
    cur-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
    cur-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);
    return cur;
  }
};
</code></pre>
<h2 id="700-search-in-a-binary-search-tree">[700] Search in a Binary Search Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
äºŒå‰æœç´¢æ ‘çš„æœ€åŸºæœ¬æ“ä½œï¼Œæ— éš¾åº¦ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* searchBST(TreeNode* root, int val) {
    TreeNode* cur = root;
    while (cur) {
      if (cur-&gt;val == val) {
        return cur;
      }
      if (cur-&gt;val &lt; val) {
        cur = cur-&gt;right;
      } else {
        cur = cur-&gt;left;
      }
    }
    return cur;
  }
};
</code></pre>
<h2 id="98-validate-binary-search-tree">[98] Validate Binary Search Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å†™äº†ä¸¤ç§è§£æ³•ã€‚ä¸€ç§æ˜¯è‡ªå·±å†™çš„å‰åºéå†ï¼Œéå†è¿‡ç¨‹ä¼ å…¥<code>left_bound</code>å’Œ<code>right_bound</code>ï¼ŒæŠŠå½“å‰èŠ‚ç‚¹çš„å·¦å³å„¿å­ä¸å½“å‰èŠ‚ç‚¹å’Œå¯¹åº”boundåšæ¯”è¾ƒï¼Œç„¶åé€’å½’éå†å…¶å·¦å³å­æ ‘ã€‚<br>
å¦ä¸€ç§è§£æ³•æ˜¯å†™å®Œåçœ‹åˆ°çš„ç½‘ä¸Šçš„è§£æ³•ï¼Œä½¿ç”¨çš„æ˜¯<strong>ä¸­åºéå†</strong>ï¼Œå…¶æ ¸å¿ƒæ˜¯ä½¿ç”¨äº†<strong>äºŒå‰æœç´¢æ ‘ä¸­åºéå†è¾“å‡ºçš„èŠ‚ç‚¹æ•°å€¼æ˜¯æœ‰åºåºåˆ—</strong>çš„æ€§è´¨ã€‚é€šè¿‡ä¸­åºéå†çš„è¿™ä¸ªæ€§è´¨ï¼Œæˆ‘ä»¬åªéœ€è¦è®°å½•ä¸€ä¸ª<code>pre</code>å³å½“å‰èŠ‚ç‚¹å·¦è¾¹çš„èŠ‚ç‚¹ï¼ˆä¹Ÿå¯ä»¥åªè®°å½•æ•°å€¼ï¼Œä½†æ˜¯è¦æ³¨æ„å¦‚æœé¢˜ç›®å‡ºç°<code>long long</code>ç±»å‹çš„æœ€å°å€¼å°±æ²¡æ³•åˆå§‹åŒ–æˆæ›´å°äº†ï¼Œæ‰€ä»¥è®°å½•èŠ‚ç‚¹æ›´å¥½ï¼‰ï¼Œç„¶ååªæ¯”è¾ƒå½“å‰èŠ‚ç‚¹çš„æ•°å€¼å’Œè¿™ä¸ª<code>pre</code>çš„æ•°å€¼å¤§å°å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  bool traversal(TreeNode* cur, long long left_bound, long long right_bound) {
    if (!cur) {
      return true;
    }
    if (cur-&gt;left &amp;&amp;
        (cur-&gt;left-&gt;val &gt;= cur-&gt;val || cur-&gt;left-&gt;val &lt;= left_bound)) {
      return false;
    }
    if (cur-&gt;right &amp;&amp;
        (cur-&gt;right-&gt;val &lt;= cur-&gt;val || cur-&gt;right-&gt;val &gt;= right_bound)) {
      return false;
    }
    return traversal(cur-&gt;left, left_bound, cur-&gt;val) &amp;&amp;
           traversal(cur-&gt;right, cur-&gt;val, right_bound);
  }

  TreeNode* pre = nullptr;

  bool isValidBST(TreeNode* root) {
    // return traversal(root, -__LONG_LONG_MAX__ - 1, __LONG_LONG_MAX__);
    if (!root) {
      return true;
    }
    bool result = isValidBST(root-&gt;left);
    if (pre &amp;&amp; root-&gt;val &lt;= pre-&gt;val) {
      return false;
    } else {
      pre = root;
    }
    result &amp;= isValidBST(root-&gt;right);
    return result;
  }
};
</code></pre>
<h2 id="530-minimum-absolute-difference-in-bst">[530] Minimum Absolute Difference in BST</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å‚ç…§ä¸Šä¸€é¢˜ï¼Œæˆ‘ä»¬å·²ç»çŸ¥é“äº†<strong>äºŒå‰æœç´¢æ ‘ä¸­åºéå†è¾“å‡ºçš„èŠ‚ç‚¹æ•°å€¼æ˜¯æœ‰åºåºåˆ—</strong>ã€‚é€šè¿‡è¿™ä¸ªæ€§è´¨ï¼Œæˆ‘ä»¬åªéœ€åœ¨è¿™ä¸ªæœ‰åºåºåˆ—ä¸­è®¡ç®—å½“å‰èŠ‚ç‚¹å’Œä¸Šä¸€ä¸ªèŠ‚ç‚¹çš„å·®å€¼ï¼Œç„¶åè®°å½•æœ€å°å€¼å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* pre = nullptr;
  int min_abs_diff = __INT_MAX__;
  int getMinimumDifference(TreeNode* root) {
    if (!root) {
      return false;
    }
    getMinimumDifference(root-&gt;left);
    if (pre &amp;&amp; root-&gt;val - pre-&gt;val &lt; min_abs_diff) {
      min_abs_diff = root-&gt;val - pre-&gt;val;
    }
    pre = root;
    getMinimumDifference(root-&gt;right);
    return min_abs_diff;
  }
};
</code></pre>
<h2 id="501-find-mode-in-binary-search-tree">[501] Find Mode in Binary Search Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å’Œä¹‹å‰ä¸€æ ·çš„æ€è·¯ï¼Œé‡‡ç”¨ä¸­åºéå†ã€‚ä½¿ç”¨<code>pre &amp;&amp; cur-&gt;val != pre-&gt;val</code>æ¥åˆ¤æ–­æ˜¯åº”è¯¥æŠŠ<code>cut_count</code>ç½®1è¿˜æ˜¯åŠ 1ã€‚ç„¶åï¼Œå¯¹æ¯”<code>cur_count</code>ä¸<code>max_count</code>ï¼Œæ¥å¯¹ç»“æœ<code>result</code>è¿›è¡Œæ›´æ–°ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; result;
  TreeNode* pre = nullptr;
  int max_count = 0;
  int cur_count = 0;

  void traversal(TreeNode* cur) {
    if (!cur) {
      return;
    }

    traversal(cur-&gt;left);
    if (pre &amp;&amp; cur-&gt;val != pre-&gt;val) {
      cur_count = 1;
    } else {
      cur_count += 1;
    }
    if (cur_count == max_count) {
      result.push_back(cur-&gt;val);
    } else if (cur_count &gt; max_count) {
      result.clear();
      result.push_back(cur-&gt;val);
      max_count = cur_count;
    }
    pre = cur;
    traversal(cur-&gt;right);
  }

  vector&lt;int&gt; findMode(TreeNode* root) {
    if (!root) {
      return result;
    }
    traversal(root);
    return result;
  }
};
</code></pre>
<h2 id="236-lowest-common-ancestor-of-a-binary-tree">[236] Lowest Common Ancestor of a Binary Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ä¸€å¼€å§‹å†™äº†ä¸€ä¸ªnaiveçš„å†™æ³•ï¼šéå†æ ‘ï¼Œåœ¨éå†çš„åŒæ—¶è®°å½•è·¯å¾„ï¼Œä»¥æ­¤åˆ†åˆ«æ‰¾åˆ°åˆ°è¾¾<code>p</code>å’Œ<code>q</code>çš„è·¯å¾„ï¼Œç„¶åå†æŠŠä¸¤ä¸ªè·¯å¾„è¿›è¡Œå¯¹æ¯”ï¼Œæ‰¾åˆ°è·¯å¾„å‡ºç°ä¸ä¸€è‡´çš„åœ°æ–¹ï¼Œå…¶æœ€åä¸€ä¸ªä¸€è‡´çš„èŠ‚ç‚¹å°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆäº†ã€‚ä½†å†™å®Œå‘ç°è¿™ç§è§£æ³•æ•ˆç‡è¾ƒä½ã€‚<br>
å®é™…ä¸Šæˆ‘ä»¬æ²¡æœ‰å¿…è¦è®°å½•è·¯å¾„ã€‚æˆ‘ä»¬åªéœ€è¦åœ¨éå†çš„åŒæ—¶ï¼Œé‡åˆ°<code>p</code>å’Œ<code>q</code>å°±è¿”å›ï¼ˆå¦åˆ™éå†åˆ°åº•ç„¶åè¿”å›ç©ºæŒ‡é’ˆï¼‰ã€‚ä½¿ç”¨ååºéå†ï¼Œæˆ‘ä»¬å¯æŸ¥çœ‹å…¶å·¦å³å­æ ‘æ˜¯å¦éå†åˆ°äº†<code>p</code>æˆ–<code>q</code>ï¼Œè‹¥æ˜¯åˆ™å½“å‰èŠ‚ç‚¹å°±æ˜¯æœ€è¿‘å…¬å…±ç¥–å…ˆã€‚è‹¥<code>left</code>å’Œ<code>right</code>æœ‰ä¸€ä¸ªä¸ºç©ºï¼Œåˆ™è¿”å›å¦ä¸€ä¸ªå³å¯ï¼ˆä¸€æ˜¯ä¼ é€’ç»“æœï¼ŒäºŒæ˜¯<code>p</code>æˆ–<code>q</code>å¯èƒ½æœ¬èº«æ˜¯å…¬å…±ç¥–å…ˆï¼‰ã€‚é€šè¿‡è¿™ç§æ–¹å¼æˆ‘ä»¬é¿å…äº†è·¯å¾„çš„è®°å½•ï¼Œå¤§å¤§æé«˜äº†æ•ˆç‡ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) {
      return nullptr;
    }
    if (root == p || root == q) {
      return root;
    }
    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
    if (left &amp;&amp; right) {
      return root;
    }
    if (!left) {
      return right;
    }
    return left;
  }
};
</code></pre>
<h2 id="235-lowest-common-ancestor-of-a-binary-search-tree">[235] Lowest Common Ancestor of a Binary Search Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åˆ©ç”¨äºŒå‰æœç´¢æ ‘æœ‰åºçš„æ€§è´¨ï¼Œç›´æ¥éå†ï¼Œæ‰¾åˆ°å€¼å¤„äº<code>[p, q]</code>ï¼ˆæˆ–<code>[q, p]</code>ï¼‰åŒºé—´çš„èŠ‚ç‚¹å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) {
      return nullptr;
    }
    if ((p-&gt;val &lt;= root-&gt;val &amp;&amp; q-&gt;val &gt;= root-&gt;val) ||
        p-&gt;val &gt;= root-&gt;val &amp;&amp; q-&gt;val &lt;= root-&gt;val) {
      return root;
    }
    if (p-&gt;val &lt; root-&gt;val) {
      return lowestCommonAncestor(root-&gt;left, p, q);
    } else {
      return lowestCommonAncestor(root-&gt;right, p, q);
    }
  }
};
</code></pre>
<h2 id="701-insert-into-a-binary-search-tree">[701] Insert into a Binary Search Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ä¸€è·¯æŸ¥æ‰¾ï¼Œæ‰¾åˆ°å¯¹åº”ç©ºæŒ‡é’ˆçš„ä½ç½®æ’å…¥å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (!root) {
      return new TreeNode(val);
    }
    TreeNode* cur = root;
    while (true) {
      if (val &gt; cur-&gt;val) {
        if (cur-&gt;right) {
          cur = cur-&gt;right;
        } else {
          cur-&gt;right = new TreeNode(val);
          break;
        }
      } else {
        if (cur-&gt;left) {
          cur = cur-&gt;left;
        } else {
          cur-&gt;left = new TreeNode(val);
          break;
        }
      }
    }
    return root;
  }
};
</code></pre>
<h2 id="450-delete-node-in-a-bst">[450] Delete Node in a BST</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
äºŒå‰æœç´¢æ ‘çš„åŸºæœ¬æ“ä½œä¹‹ä¸€ï¼Œä½†æ˜¯æœ‰ä¸€å®šéš¾åº¦ã€‚è¦åˆ é™¤ä¸€ä¸ªèŠ‚ç‚¹ï¼Œæˆ‘ä»¬è‚¯å®šè¦å…ˆæ‰¾åˆ°è¿™ä¸ªèŠ‚ç‚¹ã€‚è¿™é‡Œåˆ†æˆäº†å‡ ç§æƒ…å†µã€‚</p>
<ul>
<li>è¯¥èŠ‚ç‚¹ä¸å­˜åœ¨ã€‚ä»€ä¹ˆéƒ½ä¸ç”¨å¹²ã€‚</li>
<li>è¯¥èŠ‚ç‚¹åªæœ‰å·¦å­æ ‘æˆ–å³å­æ ‘ã€‚æŠŠå…¶å·¦å­æ ‘æˆ–å³å­æ ‘æ¥åˆ°å…¶çˆ¶èŠ‚ç‚¹ä¸Šå³å¯ï¼ˆè¿˜è¦åˆ¤æ–­ä¸€ä¸‹çˆ¶èŠ‚ç‚¹æ˜¯å¦å­˜åœ¨ä»¥åŠè¯¥èŠ‚ç‚¹æ˜¯å…¶çˆ¶èŠ‚ç‚¹çš„å·¦å­©å­è¿˜æ˜¯å³å­©å­ï¼‰ã€‚</li>
<li>è¯¥èŠ‚ç‚¹åŒæ—¶æœ‰å·¦å­æ ‘å’Œå³å­æ ‘ã€‚å¯ä»¥æ‰¾åˆ°å…¶å³å­æ ‘çš„æœ€å·¦èŠ‚ç‚¹ï¼ˆä¹Ÿå°±æ˜¯æ ‘é‡Œé¢å€¼æœ€æ¥è¿‘è¯¥èŠ‚ç‚¹çš„æ¯”è¯¥èŠ‚ç‚¹å¤§çš„èŠ‚ç‚¹ï¼‰æ›¿æ¢åˆ°è¯¥èŠ‚ç‚¹ä¸Šã€‚å¯ä»¥ç›´æ¥æ›¿æ¢èŠ‚ç‚¹ï¼Œä½†æˆ‘è¿™é‡Œå†™çš„æ˜¯èµ‹å€¼çš„å†™æ³•ï¼ˆ<code>cur-&gt;val = right-&gt;val;</code>ï¼‰ï¼Œç„¶åå†æŠŠè¿™ä¸ªåŸå…ˆçš„å³å­æ ‘æœ€å·¦ï¼ˆä½ç½®çš„ï¼‰èŠ‚ç‚¹åˆ æ‰ã€‚</li>
</ul>
<p>æŠŠå³å­æ ‘æœ€å·¦èŠ‚ç‚¹æŒªè¿‡æ¥çš„æ–¹æ³•åªæ˜¯è§£æ³•ä¹‹ä¸€ï¼Œä¹Ÿå¯ä»¥æŠŠ<code>cur-&gt;left</code>ç›´æ¥æ¥åˆ°å…¶å³å­æ ‘æœ€å·¦èŠ‚ç‚¹çš„å·¦è¾¹ï¼Œå¯å‚è€ƒ<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md">è¿™ç¯‡solution</a>ã€‚ä½†æ˜¯ä¸ªäººæ„Ÿè§‰è¿™æ ·ä¼šä½¿æ ‘çš„æ·±åº¦åŠ æ·±ï¼Œå¤ªä¸ä¼˜é›…ï¼Œæ‰€ä»¥ä¸å–œæ¬¢è¿™ç§æ–¹å¼ã€‚æ€»ä¹‹äºŒå‰æœç´¢æ ‘ä¸æ˜¯å”¯ä¸€çš„ï¼Œè§£æ³•ä¹Ÿä¸æ˜¯åªæœ‰ä¸€ç§ã€‚<br>
æ­¤å¤–ï¼Œä»£ç é™¤äº†è¿­ä»£è¿˜å¯ä½¿ç”¨é€’å½’çš„å®ç°æ–¹å¼ï¼ŒåŒæ ·å¯å‚è€ƒä¸Šé¢çš„solutionï¼Œä½†é€’å½’æ˜¾ç„¶æ²¡æœ‰è¿­ä»£çš„æ–¹å¼æ€§èƒ½é«˜æ•ˆã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* deleteNode(TreeNode* root, int key) {
    TreeNode* cur = root;
    TreeNode* pre = nullptr;

    // find
    while (cur &amp;&amp; key != cur-&gt;val) {
      pre = cur;
      if (key &lt; cur-&gt;val) {
        cur = cur-&gt;left;
      } else {
        cur = cur-&gt;right;
      }
    }
    if (!cur) {
      return root;
    }

    // simple cases
    if (!cur-&gt;left || !cur-&gt;right) {
      if (!pre) {
        // The root node is the target node
        root = cur-&gt;left ? cur-&gt;left : cur-&gt;right;
      } else {
        (pre-&gt;val &gt; cur-&gt;val ? pre-&gt;left : pre-&gt;right) =
            (cur-&gt;left ? cur-&gt;left : cur-&gt;right);
      }
      delete cur;
      return root;
    }

    // the target node has two children
    // find the left most node in the right subtree
    TreeNode* right = cur-&gt;right;
    pre = cur;
    while (right-&gt;left) {
      pre = right;
      right = right-&gt;left;
    }

    // get the value
    cur-&gt;val = right-&gt;val;

    // move the left most node found
    (pre-&gt;val &gt; right-&gt;val ? pre-&gt;left : pre-&gt;right) = right-&gt;right;
    delete right;

    return root;
  }
};
</code></pre>
<h2 id="669-trim-a-binary-search-tree">[669] Trim a Binary Search Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
Mediumä½†æ˜¯å†™èµ·æ¥æ„å¤–çš„å¾ˆç®€å•ã€‚å¦‚æœå½“å‰èŠ‚ç‚¹åœ¨èŒƒå›´å¤–å°±å¯¹å¯¹åº”æ–¹å‘å­æ ‘è¿›è¡Œé€’å½’ï¼Œå¦‚æœåœ¨èŒƒå›´å†…å°±ç›´æ¥ä¸¤ç«¯é€’å½’ä¸€ä¸‹å³å¯ï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* trimBST(TreeNode* root, int low, int high) {
    if (!root) {
      return nullptr;
    }
    if (root-&gt;val &lt; low) {
      return trimBST(root-&gt;right, low, high);
    }
    if (root-&gt;val &gt; high) {
      return trimBST(root-&gt;left, low, high);
    }
    root-&gt;left = trimBST(root-&gt;left, low, high);
    root-&gt;right = trimBST(root-&gt;right, low, high);
    return root;
  }
};
</code></pre>
<h2 id="108-convert-sorted-array-to-binary-search-tree">[108] Convert Sorted Array to Binary Search Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
æ•°ç»„å·²ç»æ˜¯æœ‰åºäº†ï¼Œæ‰€ä»¥ç›´æ¥é€’å½’æ‰¾åŒºé—´ä¸­å€¼äºŒåˆ†å³å¯ï¼Œæ²¡ä»€ä¹ˆéš¾åº¦ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* buildTree(vector&lt;int&gt;&amp; nums, int left, int right) {
    if (left &gt;= right) {
      return nullptr;
    }
    // we can use `int mid = left + ((right - left) / 2);` instead to avoid
    // int overflow.
    int mid = (left + right) / 2;
    TreeNode* cur = new TreeNode(nums[mid]);
    cur-&gt;left = buildTree(nums, left, mid);
    cur-&gt;right = buildTree(nums, mid + 1, right);
    return cur;
  }

  TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
    return buildTree(nums, 0, nums.size());
  }
};
</code></pre>
<h2 id="538-convert-bst-to-greater-tree">[538] Convert BST to Greater Tree</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å†™å‡ºæ¥ä»£ç å¼‚å¸¸ç®€æ´çš„Mediumé¢˜ã€‚æ ¹æ®é¢˜ç›®è¦æ±‚ï¼Œä½¿ç”¨åä¸­åºéå†ï¼ˆå³ä¸­å·¦ï¼‰ã€‚åœ¨éå†è¿‡ç¨‹ä¸­è®°å½•å½“å‰ç´¯åŠ å€¼<code>sum</code>ï¼Œå…ˆç®—å³è¾¹ï¼Œå³å­æ ‘è¿”å›å€¼ç´¯åŠ åˆ°å½“å‰èŠ‚ç‚¹ï¼Œå†ä¼ åˆ°å·¦å­æ ‘å»ç´¯åŠ ï¼Œæœ€åæŠŠæ•´ä¸ªå­æ ‘çš„ç´¯åŠ å€¼å†ä¼ å›çˆ¶èŠ‚ç‚¹å³å¯ã€‚<br>
æ³¨æ„éå†åˆ°ç©ºèŠ‚ç‚¹çš„æ—¶å€™ç›´æ¥è¿”å›<code>sum</code>ï¼Œå³å¯ä»ç´¯åŠ è¿‡çš„å€¼ç»§ç»­ç´¯åŠ ã€‚</p>
<pre><code class="language-c++">class Solution {
 public:
  int traversal(TreeNode* cur, int sum) {
    if (!cur) {
      return sum;
    }
    cur-&gt;val += traversal(cur-&gt;right, sum);
    return traversal(cur-&gt;left, cur-&gt;val);
  }

  TreeNode* convertBST(TreeNode* root) {
    traversal(root, 0);
    return root;
  }
};
</code></pre>
<h2 id="æ€»ç»“">æ€»ç»“</h2>
<p>è¿™ä¸€éƒ¨åˆ†åˆ·çš„é¢˜æ¯”è¾ƒå¤šã€‚æ¦‚æ‹¬èµ·æ¥çš„è¯å°±æ˜¯</p>
<ul>
<li>é¦–å…ˆæŒæ¡äºŒå‰æ ‘çš„åŸºæœ¬éå†æ–¹å¼ï¼Œä¾‹å¦‚å‰ä¸­ååºéå†å’Œå±‚åºéå†ï¼Œå®ç°æ–¹å¼åˆåˆ†ä¸ºé€’å½’æ³•å’Œè¿­ä»£æ³•ï¼Œä¸ºäº†ç»Ÿä¸€å‰ä¸­ååºçš„è¿­ä»£æ³•å®ç°æ–¹å¼åˆæœ‰ç»Ÿä¸€è¿­ä»£æ³•ã€‚</li>
<li>å¤§éƒ¨åˆ†çš„é¢˜éƒ½åªæ˜¯å¯¹äºŒå‰æ ‘åšéå†ï¼Œç„¶ååœ¨éå†çš„è¿‡ç¨‹ä¸­è®°å½•å’Œä¼ é€’ä¸€äº›éœ€è¦çš„ä¸­é—´æ•°æ®å³å¯ã€‚éå†çš„æ–¹å¼å¯æ ¹æ®é¢˜ç›®è¦æ±‚æ¥ï¼Œè¿­ä»£è¿˜æ˜¯é€’å½’ä¹Ÿå¯æ ¹æ®æ€ä¹ˆå®ç°æ–¹ä¾¿æ€ä¹ˆæ¥ã€‚</li>
<li><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal">[106] Construct Binary Tree from Inorder and Postorder Traversal</a>è¦æ±‚é€šè¿‡ä¸­åºå’Œååºéå†çš„ç»“æœæ¥è¿˜åŸæ„é€ å‡ºäºŒå‰æ ‘ã€‚è¿™é‡Œæˆ‘ä»¬è¦åˆ©ç”¨ååºéå†çš„æœ€åä¸€ä¸ªèŠ‚ç‚¹ä¸€å®šæ˜¯æ ¹èŠ‚ç‚¹çš„æ€§è´¨ï¼Œç„¶åå¯¹åº”åˆ°ä¸­åºéå†çš„ä½ç½®æ¥åˆ†å‰²å·¦å³å­æ ‘ï¼Œå†å›åˆ°ååºéå†çš„éƒ¨åˆ†æ‰¾å­æ ‘çš„æ ¹èŠ‚ç‚¹ï¼Œä¸¤ä¸ªéå†ç»“æœæ¥å›åˆ†å‰²å’ŒæŸ¥è¯¢ã€‚æ³¨æ„å‰åºéå†å’Œä¸­åºéå†çš„ç»“æœä¹Ÿå¯ä»¥ç”¨æ¥å”¯ä¸€ç¡®å®šä¸€é¢—äºŒå‰æ ‘ï¼Œä½†æ˜¯å‰åºå’Œååºä¸€èµ·å´ä¸è¡Œï¼Œå› ä¸ºæ²¡æœ‰ä¸­åºéå†æ— æ³•ç¡®å®šå·¦å³éƒ¨åˆ†ï¼Œä¹Ÿå°±æ˜¯æ— æ³•åˆ†å‰²ã€‚</li>
<li>åé¢çš„é¢˜æ˜¯å…³äºäºŒå‰æœç´¢æ ‘ï¼ˆBSTï¼‰çš„ã€‚BSTçš„æŸ¥æ‰¾å’Œæ’å…¥éƒ½å¾ˆç®€å•ï¼Œä½†åˆ é™¤æœ‰ä¸€å®šéš¾åº¦ï¼Œè¿™é‡Œä½¿ç”¨äº†å…¶å³å­æ ‘çš„æœ€å·¦èŠ‚ç‚¹æ¥æ›¿æ¢è¦åˆ é™¤çš„èŠ‚ç‚¹ï¼ˆå…¶åŒæ—¶æœ‰å·¦å³å„¿å­çš„æƒ…å†µï¼‰ã€‚æ­¤å¤–å°±æ˜¯å¯ä»¥æ³¨æ„ä¸€ä¸‹BSTçš„ä¸­åºéå†çš„ç»“æœæ˜¯æœ‰åºåºåˆ—çš„æ€§è´¨ï¼Œåœ¨æŸäº›é¢˜ç›®ä¸­ä¼šå¾ˆæœ‰ç”¨ã€‚</li>
</ul>
<h2 id="è¡¥å……">è¡¥å……</h2>
<h3 id="543-diameter-of-binary-tree">[543] Diameter of Binary Tree</h3>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ä»»æ„ä¸€æ¡è·¯å¾„å¯ä»¥çœ‹æˆæ˜¯æŸä¸€èŠ‚ç‚¹åˆ†åˆ«å‘å·¦å³å„¿å­å‘ä¸‹éå†çš„è·¯å¾„æ‹¼æ¥å¾—åˆ°ï¼Œè€Œè¿™æ ·çš„å·¦å³è·¯å¾„çš„é•¿åº¦åˆ†åˆ«å°±æ˜¯å·¦å³å­æ ‘çš„æ·±åº¦ã€‚<br>
å› æ­¤ï¼Œæˆ‘ä»¬è€ƒè™‘åç»­éå†ï¼Œç»Ÿè®¡å„èŠ‚ç‚¹å·¦å³å­æ ‘çš„æ·±åº¦ï¼Œå†æ¯”è¾ƒæ·±åº¦ä¹‹å’Œæ¥æ›´æ–°<code>maxLength</code>ï¼Œä¾¿å¯å¾—åˆ°ç­”æ¡ˆã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    int traverse(TreeNode *cur, int &amp;maxLengh) {
        if (cur == nullptr) {
            return 0;
        }

        int left = traverse(cur-&gt;left, maxLengh);
        int right = traverse(cur-&gt;right, maxLengh);
        maxLengh = max(maxLengh, left + right);
        return max(left, right) + 1;
    }

    int diameterOfBinaryTree(TreeNode *root) {
        int maxLength = 0;
        traverse(root, maxLength);
        return maxLength;
    }
};
</code></pre>
<h3 id="230-kth-smallest-element-in-a-bst">[230] Kth Smallest Element in a BST</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åˆ©ç”¨äºŒå‰æœç´¢æ ‘ä¸­åºéå†å¾—åˆ°æœ‰åºåºåˆ—çš„æ€§è´¨ï¼Œä¸­åºéå†åˆ°ç¬¬<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>ä¸ªå³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    int kthSmallest(TreeNode *root, int k) {
        stack&lt;TreeNode *&gt; st;
        TreeNode *cur = root;
        while (cur || !st.empty()) {
            if (cur) {
                st.push(cur);
                cur = cur-&gt;left;
            } else {
                cur = st.top();
                st.pop();
                if (--k == 0) {
                    break;
                }
                cur = cur-&gt;right;
            }
        }
        return cur-&gt;val;
    }
};
</code></pre>
<h3 id="199-binary-tree-right-side-view">[199] Binary Tree Right Side View</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å±‚åºéå†ï¼Œå–æ¯å±‚æœ€åä¸€ä¸ªèŠ‚ç‚¹åŠ å…¥ç»“æœå³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    vector&lt;int&gt; rightSideView(TreeNode *root) {
        vector&lt;int&gt; result;
        TreeNode *cur = root;
        queue&lt;TreeNode *&gt; q;
        if (root) {
            q.push(root);
        }
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; ++i) {
                cur = q.front();
                q.pop();
                if (cur-&gt;left) {
                    q.push(cur-&gt;left);
                }
                if (cur-&gt;right) {
                    q.push(cur-&gt;right);
                }
            }
            result.emplace_back(cur-&gt;val);
        }
        return result;
    }
};
</code></pre>
<h3 id="114-flatten-binary-tree-to-linked-list">[114] Flatten Binary Tree to Linked List</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å®¹æ˜“æƒ³åˆ°çš„Naiveæ–¹å¼æ˜¯å‰åºéå†ä¸€éï¼Œå†æŒ‰ç…§éå†çš„ç»“æœä¾æ¬¡æ”¹æŒ‡é’ˆå³å¯ã€‚è§<code>flattenNaive</code>ã€‚<br>
ä¸ºäº†æŠŠç©ºé—´å¤æ‚åº¦ä¼˜åŒ–åˆ°<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>ï¼Œæˆ‘ä»¬å¯ä»¥è§‚å¯Ÿåˆ°ï¼Œå½“å‰èŠ‚ç‚¹çš„å³å„¿å­å°±æ˜¯å·¦å­æ ‘ä¸­æœ€å³èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªè®¿é—®å¯¹è±¡ï¼ŒåŒæ—¶å½“å‰èŠ‚ç‚¹çš„å·¦å„¿å­å°±æ˜¯å½“å‰èŠ‚ç‚¹çš„ä¸‹ä¸€ä¸ªè®¿é—®å¯¹è±¡ã€‚åˆ©ç”¨è¿™ä¸ªç‰¹æ€§ï¼Œæˆ‘ä»¬å¯ä»¥æŠŠå³å­æ ‘æ¥åˆ°å·¦å­æ ‘çš„æœ€å³èŠ‚ç‚¹çš„å³è¾¹ï¼Œå†æŠŠå·¦å­æ ‘æ¥åˆ°å½“å‰èŠ‚ç‚¹çš„å³è¾¹ã€‚è§<code>flatten</code>ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    void flatten(TreeNode *root) {
        TreeNode *cur = root;
        while (cur) {
            if (cur-&gt;left) {
                TreeNode *leftRightMost = cur-&gt;left;
                while (leftRightMost-&gt;right) {
                    leftRightMost = leftRightMost-&gt;right;
                }
                leftRightMost-&gt;right = cur-&gt;right;
                cur-&gt;right = cur-&gt;left;
                cur-&gt;left = nullptr;
            }
            cur = cur-&gt;right;
        }
    }

    void flattenNaive(TreeNode *root) {
        vector&lt;TreeNode *&gt; result;
        stack&lt;TreeNode *&gt; st;
        if (root) {
            st.push(root);
        }

        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            result.emplace_back(cur);
            if (cur-&gt;right) {
                st.push(cur-&gt;right);
            }
            if (cur-&gt;left) {
                st.push(cur-&gt;left);
            }
        }

        int size = result.size();
        for (int i = 0; i &lt; size - 1; ++i) {
            result[i]-&gt;left = nullptr;
            result[i]-&gt;right = result[i + 1];
        }
    }
};
</code></pre>
<h3 id="105-construct-binary-tree-from-preorder-and-inorder-traversal">[105] Construct Binary Tree from Preorder and Inorder Traversal</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ç±»ä¼¼<a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal">[106] Construct Binary Tree from Inorder and Postorder Traversal</a>çš„é¢˜ï¼Œè¿™æ˜¯è¿™é‡Œä»ååºæ¢æˆäº†å‰åºï¼Œæ ¹èŠ‚ç‚¹è‡ªç„¶ä¹Ÿæ˜¯ä»<code>preorder</code>çš„ç¬¬ä¸€ä¸ªå¼€å§‹æ‰¾ã€‚<br>
æ­¤å¤–ï¼Œè¿™é‡Œä½¿ç”¨äº†å“ˆå¸Œè¡¨<code>inorderMap</code>æ¥åŠ é€Ÿäº†å½“å‰èŠ‚ç‚¹å€¼åœ¨<code>inorder</code>ä¸­çš„ç´¢å¼•çš„æŸ¥æ‰¾ã€‚<br>
æœ€åï¼Œè¿™é“é¢˜è¿˜æœ‰è¿­ä»£çš„è§£æ³•ï¼Œè§<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">è¿™ç¯‡solution</a>ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    TreeNode *traversal(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder,
                        int &amp;preIdx, int inorderLeft, int inorderRight,
                        unordered_map&lt;int, int&gt; &amp;inorderMap) {
        if (inorderLeft &gt;= inorderRight) {
            return nullptr;
        }

        TreeNode *cur = new TreeNode(preorder[preIdx]);
        // int inorderIndex =
        //     find(inorder.begin(), inorder.end(), preorder[preIdx]) -
        //     inorder.begin();
        // Opt: unordered_map
        int inorderIndex = inorderMap[preorder[preIdx]];
        ++preIdx;
        cur-&gt;left = traversal(preorder, inorder, preIdx, inorderLeft,
                              inorderIndex, inorderMap);
        cur-&gt;right = traversal(preorder, inorder, preIdx, inorderIndex + 1,
                               inorderRight, inorderMap);
        return cur;
    }

    TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) {
        unordered_map&lt;int, int&gt; inorderMap;
        int preIdx = 0;
        int idx = 0;
        for (int &amp;val : inorder) {
            inorderMap[val] = idx++;
        }
        return traversal(preorder, inorder, preIdx, 0, inorder.size(),
                         inorderMap);
    }
};
</code></pre>
<h3 id="437-path-sum-iii">[437] Path Sum III</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/path-sum-iii/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åœ¨éå†çš„è¿‡ç¨‹è®°å½•å½“å‰å‰ç¼€å’Œ<code>curSum</code>ä»¥åŠpathé‡Œé¢å‡ºç°å„ä¸ªå‰ç¼€å’Œå€¼çš„æ¬¡æ•°<code>prefix</code>ï¼ˆkeyä¸ºå‰ç¼€å’Œçš„å€¼ï¼Œvalueä¸ºå€¼åœ¨å½“å‰pathå‡ºç°çš„æ¬¡æ•°ï¼‰ã€‚é€šè¿‡æŸ¥æ‰¾<code>prefix[curSum - targetSum]</code>çš„å€¼ï¼Œä¾¿å¯å¾—åˆ°ä»¥å½“å‰èŠ‚ç‚¹ä¸ºç»“å°¾çš„æ»¡è¶³æ¡ä»¶çš„pathæ•°ç›®ã€‚<br>
æ³¨æ„<code>prefix[curSum] += 1;</code>éœ€è¦åœ¨<code>ret += prefix[curSum - targetSum];</code>çš„åé¢ã€‚è¿™æ˜¯å› ä¸ºç©ºpathæˆ‘ä»¬æ˜¯ä¸ç®—åšç»“æœçš„ã€‚å¦‚æœåœ¨å‰é¢çš„è¯ï¼Œä¼šå¯¼è‡´<code>targetSum</code>ä¸º0çš„æ—¶å€™è¿™é‡Œ<code>ret</code>çš„å€¼å¤šä¸€ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    int traversal(TreeNode *cur, int targetSum, long long curSum,
                  unordered_map&lt;long long, int&gt; &amp;prefix) {
        if (!cur) {
            return 0;
        }

        int ret = 0;

        curSum += cur-&gt;val;
        ret += prefix[curSum - targetSum];

        prefix[curSum] += 1;
        ret += traversal(cur-&gt;left, targetSum, curSum, prefix);
        ret += traversal(cur-&gt;right, targetSum, curSum, prefix);
        prefix[curSum] -= 1;

        return ret;
    }

    int pathSum(TreeNode *root, int targetSum) {
        unordered_map&lt;long long, int&gt; prefix;
        prefix[0] = 1;
        return traversal(root, targetSum, 0, prefix);
    }
};
</code></pre>
<h3 id="124-binary-tree-maximum-path-sum">[124] Binary Tree Maximum Path Sum</h3>
<blockquote>
<p>éš¾åº¦ï¼šHard<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
æ ‡çš„éš¾åº¦æ˜¯Hardä½†æ„å¤–åœ°å¾ˆç®€å•ï¼ˆå¤§æ¦‚åœ¨Easyåˆ°Mediumä¹‹é—´ï¼‰ã€‚<br>
æ¯æ¡Pathæˆ‘ä»¬å¯ä»¥çœ‹ä½œæ˜¯ä»æŸä¸ªèŠ‚ç‚¹å‡ºå‘åˆ†åˆ«ä»å·¦å³å‘ä¸‹éå†çš„è·¯å¾„çš„æ‹¼æ¥ã€‚å› æ­¤ï¼Œæˆ‘ä»¬å¯ä»¥æŸ¥çœ‹æ¯ä¸ªèŠ‚ç‚¹åˆ†åˆ«ä»å·¦å³å‘ä¸‹èµ°çš„æœ€å¤§è·¯å¾„å’Œï¼Œç„¶åå†åŠ ä¸Šå½“å‰èŠ‚ç‚¹çš„æ•°å€¼ä¸<code>maxSum</code>æ¯”è¾ƒå³å¯ï¼ˆ<code>maxSum = max(cur-&gt;val + left + right, maxSum);</code>ï¼‰ã€‚æ³¨æ„å¦‚æœå‘ä¸‹èµ°çš„è·¯å¾„å’Œä¸ºè´Ÿæ•°ï¼Œåˆ™è¯´æ˜ä¸èµ°è¿™æ¡è·¯å¾„ï¼Œè¿”å›0å³å¯ï¼ˆ<code>return max(0, cur-&gt;val + max(left, right));</code>ï¼‰ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    int traversal(TreeNode *cur, int &amp;maxSum) {
        if (!cur) {
            return 0;
        }

        int left = traversal(cur-&gt;left, maxSum);
        int right = traversal(cur-&gt;right, maxSum);
        maxSum = max(cur-&gt;val + left + right, maxSum);
        return max(0, cur-&gt;val + max(left, right));
    }

    int maxPathSum(TreeNode *root) {
        int maxSum = -__INT_MAX__ - 1;
        traversal(root, maxSum);
        return maxSum;
    }
};
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#144-145-94">[144]ã€[145]ã€[94]</a>
<ul>
<li><a href="#%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86">é€’å½’éå†</a></li>
<li><a href="#%E8%BF%AD%E4%BB%A3%E9%81%8D%E5%8E%86">è¿­ä»£éå†</a></li>
<li><a href="#%E7%BB%9F%E4%B8%80%E8%BF%AD%E4%BB%A3%E6%B3%95">ç»Ÿä¸€è¿­ä»£æ³•</a></li>
</ul>
</li>
<li><a href="#102-binary-tree-level-order-traversal">[102] Binary Tree Level Order Traversal</a></li>
<li><a href="#226-invert-binary-tree">[226] Invert Binary Tree</a></li>
<li><a href="#101-symmetric-tree">[101] Symmetric Tree</a></li>
<li><a href="#104-maximum-depth-of-binary-tree">[104] Maximum Depth of Binary Tree</a></li>
<li><a href="#111-minimum-depth-of-binary-tree">[111] Minimum Depth of Binary Tree</a></li>
<li><a href="#222-count-complete-tree-nodes">[222] Count Complete Tree Nodes</a></li>
<li><a href="#110-balanced-binary-tree">[110] Balanced Binary Tree</a></li>
<li><a href="#257-binary-tree-paths">[257] Binary Tree Paths</a></li>
<li><a href="#404-sum-of-left-leaves">[404] Sum of Left Leaves</a></li>
<li><a href="#513-find-bottom-left-tree-value">[513] Find Bottom Left Tree Value</a></li>
<li><a href="#112-path-sum">[112] Path Sum</a></li>
<li><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal">[106] Construct Binary Tree from Inorder and Postorder Traversal</a></li>
<li><a href="#654-maximum-binary-tree">[654] Maximum Binary Tree</a></li>
<li><a href="#617-merge-two-binary-trees">[617] Merge Two Binary Trees</a></li>
<li><a href="#700-search-in-a-binary-search-tree">[700] Search in a Binary Search Tree</a></li>
<li><a href="#98-validate-binary-search-tree">[98] Validate Binary Search Tree</a></li>
<li><a href="#530-minimum-absolute-difference-in-bst">[530] Minimum Absolute Difference in BST</a></li>
<li><a href="#501-find-mode-in-binary-search-tree">[501] Find Mode in Binary Search Tree</a></li>
<li><a href="#236-lowest-common-ancestor-of-a-binary-tree">[236] Lowest Common Ancestor of a Binary Tree</a></li>
<li><a href="#235-lowest-common-ancestor-of-a-binary-search-tree">[235] Lowest Common Ancestor of a Binary Search Tree</a></li>
<li><a href="#701-insert-into-a-binary-search-tree">[701] Insert into a Binary Search Tree</a></li>
<li><a href="#450-delete-node-in-a-bst">[450] Delete Node in a BST</a></li>
<li><a href="#669-trim-a-binary-search-tree">[669] Trim a Binary Search Tree</a></li>
<li><a href="#108-convert-sorted-array-to-binary-search-tree">[108] Convert Sorted Array to Binary Search Tree</a></li>
<li><a href="#538-convert-bst-to-greater-tree">[538] Convert BST to Greater Tree</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">æ€»ç»“</a></li>
<li><a href="#%E8%A1%A5%E5%85%85">è¡¥å……</a>
<ul>
<li><a href="#543-diameter-of-binary-tree">[543] Diameter of Binary Tree</a></li>
<li><a href="#230-kth-smallest-element-in-a-bst">[230] Kth Smallest Element in a BST</a></li>
<li><a href="#199-binary-tree-right-side-view">[199] Binary Tree Right Side View</a></li>
<li><a href="#114-flatten-binary-tree-to-linked-list">[114] Flatten Binary Tree to Linked List</a></li>
<li><a href="#105-construct-binary-tree-from-preorder-and-inorder-traversal">[105] Construct Binary Tree from Preorder and Inorder Traversal</a></li>
<li><a href="#437-path-sum-iii">[437] Path Sum III</a></li>
<li><a href="#124-binary-tree-maximum-path-sum">[124] Binary Tree Maximum Path Sum</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">ä¸‹ä¸€ç¯‡</div>
            <a href="https://alleny.xyz/post/powerinfer-source-analysis-1/">
              <h3 class="post-title">
                PowerInferæºç è§£æï¼ˆä¸€ï¼‰ï¼šæ¨¡å‹åŠ è½½
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'alleny-blog',
  apikey: '2kPJh2tQ0rWB7n0QOhvb9TLbm946tHMWCixW2qGF9j8tfMBgZoNPfvLpDoxZTZpD',
}
if ('https://disqus.hangyu-yuan.workers.dev/api/') {
  options.api = 'https://disqus.hangyu-yuan.workers.dev/api/'
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Copyright Â© 2023-2025 Allen Yuan. All rights reserved.
  <a class="rss" href="https://alleny.xyz/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
