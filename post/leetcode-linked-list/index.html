<html>
  <head>
    <meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>LeetCodeåˆ·é¢˜è®°å½•ï¼ˆé“¾è¡¨ç¯‡ï¼‰ | AllenY&#39;s blog</title>
<link rel="shortcut icon" href="https://alleny.xyz/favicon.ico?v=1747120786321">
<link href="https://cdn.jsdelivr.net/npm/remixicon@2.3.0/fonts/remixicon.css" rel="stylesheet">
<link rel="stylesheet" href="https://alleny.xyz/styles/main.css">
<link rel="alternate" type="application/atom+xml" title="LeetCodeåˆ·é¢˜è®°å½•ï¼ˆé“¾è¡¨ç¯‡ï¼‰ | AllenY&#39;s blog - Atom Feed" href="https://alleny.xyz/atom.xml">
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Droid+Serif:400,700">


<script async src="https://www.googletagmanager.com/gtag/js?id=G-HPLP8D1S43"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-HPLP8D1S43');
</script>


    <meta name="description" content="LeetCodeåˆ·é¢˜è®°å½•ï¼ˆé“¾è¡¨ç¯‡ï¼‰ï¼Œä¸ªäººå‘ã€‚
ä¸ºäº†é”»ç‚¼ä»£ç èƒ½åŠ›ï¼Œä¼šäº¤æ›¿ä½¿ç”¨ä¸åŒç¼–ç¨‹è¯­è¨€å®Œæˆç­”æ¡ˆã€‚

[203] Remove Linked List Elements

éš¾åº¦ï¼šEasy
è¯­è¨€ï¼šRust

é¢˜ç›®æè¿°ã€‚
åŸºæœ¬çš„æ•°æ®ç»“æ„æ“ä½œï¼ŒæŒ‰é“..." />
    <meta name="keywords" content="LeetCode" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.10.0/katex.min.css">
    <script src="//cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.5.1/build/highlight.min.js"></script>
  </head>
  <body>
    <div class="main">
      <div class="main-content">
        <div class="site-header">
  <a href="https://alleny.xyz">
  <img class="avatar" src="https://alleny.xyz/images/avatar.png?v=1747120786321" alt="">
  </a>
  <h1 class="site-title">
    AllenY&#39;s blog
  </h1>
  <p class="site-description">
    ğŸ§‘ğŸ»â€ğŸ’»ğŸ®ğŸ¿ğŸ¹ğŸ—»
  </p>
  <div class="menu-container">
    
      
        <a href="/" class="menu">
          Home
        </a>
      
    
      
        <a href="/archives" class="menu">
          Archive
        </a>
      
    
      
        <a href="/tags" class="menu">
          Tags
        </a>
      
    
      
        <a href="/post/about" class="menu">
          About
        </a>
      
    
  </div>
  <div class="social-container">
    
      
        <a href="https://github.com/Yuan-Allen" target="_blank">
          <i class="ri-github-line"></i>
        </a>
      
    
      
    
      
        <a href="https://weibo.com/u/6478080851" target="_blank">
          <i class="ri-weibo-line"></i>
        </a>
      
    
      
    
      
    
  </div>
</div>

        <div class="post-detail">
          <article class="post">
            <h2 class="post-title">
              LeetCodeåˆ·é¢˜è®°å½•ï¼ˆé“¾è¡¨ç¯‡ï¼‰
            </h2>
            <div class="post-info">
              <span>
                2024-03-31
              </span>
              <span>
                19 min read
              </span>
              
                <a href="https://alleny.xyz/tag/leetcode/" class="post-tag">
                  # LeetCode
                </a>
              
            </div>
            
            <div class="post-content-wrapper">
              <div class="post-content" v-pre>
                <p>LeetCodeåˆ·é¢˜è®°å½•ï¼ˆé“¾è¡¨ç¯‡ï¼‰ï¼Œä¸ªäººå‘ã€‚<br>
ä¸ºäº†é”»ç‚¼ä»£ç èƒ½åŠ›ï¼Œä¼šäº¤æ›¿ä½¿ç”¨ä¸åŒç¼–ç¨‹è¯­è¨€å®Œæˆç­”æ¡ˆã€‚</p>
<!-- more -->
<h2 id="203-remove-linked-list-elements">[203] Remove Linked List Elements</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šRust</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/remove-linked-list-elements/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
åŸºæœ¬çš„æ•°æ®ç»“æ„æ“ä½œï¼ŒæŒ‰é“ç†æ²¡æœ‰éš¾åº¦å¯è¨€ã€‚é—®é¢˜æ˜¯å¦‚æœç”¨Rustæ¥å†™ï¼Œéš¾åº¦å°±ä¼šæš´å¢ã€‚</p>
<pre><code class="language-rust">    pub fn remove_elements(head: Option&lt;Box&lt;ListNode&gt;&gt;, val: i32) -&gt; Option&lt;Box&lt;ListNode&gt;&gt; {
        let mut dummy_head = Box::new(ListNode::new(0));
        dummy_head.next = head;

        let mut cur = dummy_head.as_mut();
        while let Some(nxt) = cur.next.as_mut() {
            if nxt.val == val {
                cur.next = nxt.next.take();
            } else {
                cur = cur.next.as_mut().unwrap();
            }
        }

        dummy_head.next
    }
</code></pre>
<h2 id="707-design-linked-list">[707] Design Linked List</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/design-linked-list/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å®ç°ä¸€ä¸ªé“¾è¡¨ï¼Œå¯ä»¥æ˜¯å•å‘é“¾è¡¨æˆ–åŒå‘é“¾è¡¨ã€‚åŸºæœ¬çš„æ•°æ®ç»“æ„å®ç°ï¼Œè¿™å±…ç„¶æ˜¯Mediumï¼Ÿ<br>
è™½ç„¶å¦‚æ­¤ï¼Œè¿˜æ˜¯éœ€è¦æ³¨æ„ä¸€äº›ç»†èŠ‚ï¼Œä¸èƒ½çœ‹é”™é¢˜ç›®ï¼Œä¾‹å¦‚<code>addAtIndex</code>æ˜¯åœ¨æŒ‡å®šèŠ‚ç‚¹ä¹‹å‰è€Œä¸æ˜¯ä¹‹åæ’å…¥ï¼›ä»¥åŠå½“<code>index</code>ç­‰äº<code>length</code>æ—¶éœ€è¦åœ¨é“¾è¡¨å°¾éƒ¨æ’å…¥ã€‚<br>
æœ¬äººè¿™é‡Œå®ç°çš„æ˜¯åŒé“¾è¡¨ã€‚ç›¸æ¯”é¢˜ç›®è¦æ±‚å®ç°çš„å‡½æ•°ï¼Œé¢å¤–å¢åŠ å®ç°äº†å¯å¤ç”¨å‡½æ•°<code>get_node</code>ç”¨æ¥ç²¾ç®€ä»£ç ã€‚å®é™…ä¸Šè¿™é‡Œ<code>addAtHead</code>å’Œ<code>addAtTail</code>å‡½æ•°è¿˜å¯ä»¥å¤ç”¨<code>addAtIndex</code>çš„ä»£ç ï¼Œä½†æ˜¯æ²¡æœ‰å¿…è¦äº†ï¼Œå› ä¸ºè¿™ä¸¤ä¸ªå‡½æ•°æœ¬èº«å°±å¾ˆç®€å•ï¼Œä¹Ÿä¸éœ€è¦ä¸€äº›å¤šä½™çš„æ¡ä»¶åˆ¤æ–­ï¼Œä¸å¤ç”¨å¯ä»¥æå‡ä¸€ä¸‹æ€§èƒ½ã€‚<br>
æ­¤å¤–ï¼Œè¿™é‡Œçš„å®ç°è¿˜åŠ äº†ä¸€ä¸ªä¼˜åŒ–ï¼Œå³<code>get_node</code>çš„æ—¶å€™ä¼šåˆ¤æ–­ä¸€ä¸‹ç›®æ ‡æ˜¯åœ¨é“¾è¡¨å‰åŠæ®µè¿˜æ˜¯ååŠæ®µï¼Œå³ä»<code>head</code>éå†è¿‡å»å¿«è¿˜æ˜¯ä»<code>tail</code>éå†è¿‡å»å¿«ï¼Œå……åˆ†æ¦¨å¹²åŒå‘é“¾è¡¨æ€§èƒ½ã€‚</p>
<pre><code class="language-c++">class MyLinkedList {
 public:
  struct Node {
    int val;
    Node* next;
    Node* prev;
    Node(int val) : val(val), next(nullptr), prev(nullptr) {}
  };

  Node* head;
  Node* tail;
  int length;

  MyLinkedList() {
    head = new Node(0);
    tail = new Node(0);
    length = 0;

    head-&gt;next = tail;
    tail-&gt;prev = head;
  }

  Node* get_node(int index) {
    if (index &lt; 0 || index &gt;= length) {
      return nullptr;
    }

    Node* curr = head-&gt;next;
    if (index &lt; length / 2) {
      for (int i = 0; i &lt; index; ++i) {
        curr = curr-&gt;next;
      }
    } else {
      // Opt: near to tail
      curr = tail-&gt;prev;
      for (int i = 0; i &lt; length - index - 1; ++i) {
        curr = curr-&gt;prev;
      }
    }

    return curr;
  }

  int get(int index) {
    Node* node = get_node(index);

    return node != nullptr ? node-&gt;val : -1;
  }

  void addAtHead(int val) {
    Node* node = new Node(val);
    head-&gt;next-&gt;prev = node;
    node-&gt;next = head-&gt;next;
    node-&gt;prev = head;
    head-&gt;next = node;

    length++;
  }

  void addAtTail(int val) {
    Node* node = new Node(val);
    tail-&gt;prev-&gt;next = node;
    node-&gt;prev = tail-&gt;prev;
    node-&gt;next = tail;
    tail-&gt;prev = node;

    length++;
  }

  void addAtIndex(int index, int val) {
    Node* node = new Node(val);
    Node* curr = tail;

    if (index != length) {
      curr = get_node(index);
    }
    if (curr == nullptr) {
      return;
    }

    node-&gt;prev = curr-&gt;prev;
    curr-&gt;prev-&gt;next = node;
    node-&gt;next = curr;
    curr-&gt;prev = node;
    length++;
  }

  void deleteAtIndex(int index) {
    Node* curr = get_node(index);
    if (curr == nullptr) {
      return;
    }

    curr-&gt;prev-&gt;next = curr-&gt;next;
    curr-&gt;next-&gt;prev = curr-&gt;prev;
    delete curr;
    length--;
  }
};
</code></pre>
<h2 id="206-reverse-linked-list">[206] Reverse Linked List</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šPython</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/reverse-linked-list/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
æ²¡æœ‰ä»»ä½•éš¾åº¦çš„æç®€é¢˜ç›®ï¼ŒåŒ…å«<code>return</code>ä¸€å…±åªç”¨å…«è¡Œä»£ç ã€‚éå†é“¾è¡¨ï¼Œæ¯æ¬¡è®°å½•ä¸€ä¸‹ä¸‹ä¸€ä¸ªèŠ‚ç‚¹ï¼ˆ<code>succ</code>ï¼‰ï¼Œç„¶åç¿»è½¬å½“å‰èŠ‚ç‚¹æŒ‡é’ˆå³å¯ã€‚</p>
<pre><code class="language-python">    def reverseList(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        prev = None
        curr = head

        while curr is not None:
            succ = curr.next
            curr.next = prev
            prev = curr
            curr = succ

        return prev
</code></pre>
<h2 id="24-swap-nodes-in-pairs">[24] Swap Nodes in Pairs</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
é¢˜ç›®ä¸éš¾ï¼Œè„‘é‡Œæƒ³å¥½æ¯æ¬¡å¾ªç¯æ—¶è¦åšçš„æ“ä½œå³å¯ã€‚<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0024.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md">ç½‘ä¸Šæœ‰è§£æ³•</a>æ˜¯æŠŠæ¯æ¬¡æ“ä½œåˆ†ä¸ºä¸‰ä¸ªæ­¥éª¤ã€‚æœ¬äººçš„è§£æ³•åªæŠŠæ“ä½œåˆ†ä¸ºä¸¤ä¸ªæ­¥éª¤ï¼Œç¼ºç‚¹æ˜¯æ¯æ¬¡è¦æ£€æŸ¥ä¸€ä¸‹<code>curr-&gt;next</code>æ˜¯å¦å­˜åœ¨ï¼Œå³å…ƒç´ ä¸ªæ•°æ˜¯å¦æ˜¯å¥‡æ•°ä¸ªã€‚</p>
<pre><code class="language-c++">  ListNode* swapPairs(ListNode* head) {
    ListNode* dummy_head = new ListNode(0, head);
    ListNode* prev = dummy_head;
    ListNode* curr = head;
    ListNode* next_pair = nullptr;
    while (curr) {
      if (!(curr-&gt;next)) {
        prev-&gt;next = curr;
        prev = curr;
        break;
      }
      next_pair = curr-&gt;next-&gt;next;

      curr-&gt;next-&gt;next = curr;
      prev-&gt;next = curr-&gt;next;

      prev = curr;
      curr = next_pair;
    }
    prev-&gt;next = nullptr;

    ListNode* result = dummy_head-&gt;next;
    delete dummy_head;
    return result;
  }
</code></pre>
<h2 id="19-remove-nth-node-from-end-of-list">[19] Remove Nth Node From End of List</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šPython</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
å°å­¦ç”Ÿéƒ½ä¼šçš„æœ€ç›´è§‚çš„æƒ³æ³•å°±æ˜¯å…ˆæ‰«ä¸€éå¾—å‡ºsizeå†éå†ç¬¬äºŒéæ‰¾è¦åˆ é™¤çš„nodeï¼Œä½†æ˜¯è¦æ‰«æä¸¤éï¼Œä¸å¤Ÿä¼˜é›…ã€‚ç½‘ä¸Šçš„è§£æ³•æ˜¯ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼Œä¸€å‰ä¸€åä¿æŒè·ç¦»ï¼Œå°±å¯ä»¥æ‰¾åˆ°å€’æ•°ç¬¬Nä¸ªnodeã€‚è¿™ç§è§£æ³•çœ‹ä¼¼åªç”¨äº†ä¸€æ¬¡éå†ï¼Œä½†æ¯æ¬¡å¾ªç¯ä»ä¸€æ¬¡æ“ä½œå˜æˆäº†ä¸¤æ¬¡æ“ä½œï¼Œæœ¬è´¨å…¶å®æ˜¯ä¸€æ ·çš„ï¼Œçœ‹èµ·æ¥èŠ±é‡Œèƒ¡å“¨äº†è€Œå·²ï¼ˆæ¯«æ— å«é‡‘é‡çš„Mediumï¼‰ã€‚ä½†å¾ªç¯å˜é‡æ›´æ–°å’Œæ¡ä»¶åˆ¤æ–­æœ¬èº«ä¹Ÿæ˜¯æœ‰å¼€é”€çš„ï¼Œå¿«æ…¢æŒ‡é’ˆè¿™ç§è§£æ³•æŠŠä¸¤ä¸ªå¾ªç¯æ‹æ‰åˆæˆä¸€ä¸ªå¾ªç¯ï¼Œä¹Ÿä¸èƒ½è¯´æ²¡æœ‰æå‡å§ã€‚<br>
çœŸæ­£çš„åªéœ€è¦ä¸€æ¬¡Walkçš„è§£æ³•åº”è¯¥æ˜¯ä½¿ç”¨å“ˆå¸Œè¡¨æŠŠnodeå­˜èµ·æ¥ï¼Œä½†æ˜¯è¿™éœ€è¦O(n)çš„ç©ºé—´å¤æ‚åº¦ï¼Œæ€§ä»·æ¯”è²Œä¼¼ä¸æ˜¯å¾ˆé«˜ã€‚</p>
<pre><code class="language-python">    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -&gt; Optional[ListNode]:
        dummy_head = ListNode(0, head)
        fast = dummy_head
        slow = dummy_head
        for _ in range(0, n):
            fast = fast.next
            if fast is None:
                # Actually this will not happen because 1 &lt;= n &lt;= sz
                return None
        fast = fast.next
        while fast is not None:
            slow = slow.next
            fast = fast.next
        slow.next = slow.next.next
        return dummy_head.next
</code></pre>
<h2 id="160-intersection-of-two-linked-lists">[160] Intersection of Two Linked Lists</h2>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
é¢˜ç›®è¦æ±‚O(m+n)çš„æ—¶é—´å¤æ‚åº¦å’ŒO(1)çš„ç©ºé—´å¤æ‚åº¦ï¼Œå› æ­¤å“ˆå¸Œè¡¨ä¹‹ç±»çš„æŠŠèŠ‚ç‚¹å­˜ä¸‹æ¥çš„è§£æ³•æ˜¯ä¸èƒ½ç”¨çš„ã€‚ä¸€ç§å®¹æ˜“æƒ³åˆ°çš„åšæ³•æ˜¯å…ˆç®—ä¸€ä¸‹ä¸¤ä¸ªé“¾è¡¨çš„é•¿åº¦ï¼Œç„¶åæŠŠé“¾è¡¨å°¾éƒ¨å¯¹é½ï¼Œä»çŸ­é“¾è¡¨çš„å¤´éƒ¨å¼€å§‹ä¾æ¬¡å¯¹æ¯”ä¸¤ä¸ªé“¾è¡¨å¯¹åº”ä½ç½®çš„èŠ‚ç‚¹æ˜¯å¦ç›¸åŒï¼ˆè¯´äººè¯å°±æ˜¯æŠŠé•¿é“¾è¡¨å¼€å¤´è¶…å‡ºçš„éƒ¨åˆ†æˆªæ–­ï¼‰ã€‚<br>
ç½‘ä¸Šä¹Ÿæœ‰ä¸€ç§<a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/solutions/811625/xiang-jiao-lian-biao-by-leetcode-solutio-a8jn/">åŒæŒ‡é’ˆçš„è§£æ³•</a>ï¼Œç”¨äº†ä¸€ç‚¹æ•°å­¦æŠ€å·§ï¼Œè¯´å®è¯çœŸçš„åˆ°äº†é¢è¯•ç¬”è¯•ä¸´æ—¶å¾ˆéš¾æƒ³å‡ºæ¥ã€‚å¯¹é½é“¾è¡¨çš„æ–¹æ³•è™½ç„¶ä»£ç é•¿äº†ä¸€äº›ä½†æ€è·¯å¾ˆç®€å•ï¼Œä¸ªäººè¿˜æ˜¯æ›´æ¨èã€‚</p>
<pre><code class="language-c++">  ListNode *getIntersectionNode(ListNode *headA, ListNode *headB) {
    int size_a = 0;
    int size_b = 0;
    int diff = 0;
    ListNode *tmp_a = headA;
    ListNode *tmp_b = headB;
    while (tmp_a) {
      tmp_a = tmp_a-&gt;next;
      size_a++;
    }
    while (tmp_b) {
      tmp_b = tmp_b-&gt;next;
      size_b++;
    }

    tmp_a = headA;
    tmp_b = headB;
    diff = size_a - size_b;
    while (diff &gt; 0) {
      tmp_a = tmp_a-&gt;next;
      --diff;
    }
    while (diff &lt; 0) {
      tmp_b = tmp_b-&gt;next;
      ++diff;
    }
    while (tmp_a &amp;&amp; tmp_b) {
      if (tmp_a == tmp_b) {
        return tmp_a;
      }
      tmp_a = tmp_a-&gt;next;
      tmp_b = tmp_b-&gt;next;
    }
    return nullptr;
  }
</code></pre>
<h2 id="142-linked-list-cycle-ii">[142] Linked List Cycle II</h2>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šPython</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/linked-list-cycle-ii/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
è¾ƒæœ‰éš¾åº¦çš„ä¸€é“é¢˜ã€‚<br>
å›¾è®ºä¸­ï¼Œç¯æ˜¯åªæœ‰é¦–æœ«é¡¶ç‚¹é‡å¤çš„éç©ºè·¯å¾„ã€‚ç›´è§‚æƒ³æ³•æ˜¯åˆ¤æ–­éå†ä¸­æ˜¯å¦ä¼šç¬¬äºŒæ¬¡ç»è¿‡åŒä¸€ä¸ªç‚¹ï¼Œä½†ç”±äºé¢˜ç›®è¦æ±‚O(1)çš„ç©ºé—´å¤æ‚åº¦ï¼Œæˆ‘ä»¬æ˜¾ç„¶å¹¶ä¸èƒ½ç”¨å“ˆå¸Œè¡¨ä¹‹ç±»çš„æ•°æ®ç»“æ„æŠŠè§è¿‡çš„ç‚¹éƒ½å­˜ä¸‹æ¥ã€‚å› æ­¤è¿™é“é¢˜åªèƒ½ç”¨ä¸€äº›æ•°å­¦æ¨æ–­æ¥è§£ï¼Œè€Œéš¾åº¦ä¹Ÿæºäºæ­¤ã€‚<br>
æ•°å­¦æ¨å¯¼çš„å…·ä½“è¿‡ç¨‹å¯ä»¥å‚è€ƒ<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0142.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8II.md">è¿™ç¯‡è§£ç­”</a>ã€‚ç®€å•æ¥è¯´ï¼Œå…³é”®åœ¨äºé€šè¿‡ä»¥ä¸‹ä¸¤ç‚¹</p>
<ul>
<li>å¿«æŒ‡é’ˆèµ°è¿‡çš„é•¿åº¦æ˜¯æ…¢æŒ‡é’ˆçš„ä¸¤å€</li>
<li>æŠŠå¿«æŒ‡é’ˆå’Œæ…¢æŒ‡é’ˆèµ°è¿‡çš„é•¿åº¦éƒ½ç”¨<code>x</code>ï¼Œ<code>y</code>å’Œ<code>z</code>è¡¨ç¤ºå‡ºæ¥</li>
</ul>
<p>æ¥å…±åŒè§£å‡ºä»å¤´èŠ‚ç‚¹åˆ°ç¯å…¥å£çš„è·ç¦»<code>x</code>ã€‚ç”±äºé€šè¿‡ç¬¬ä¸€æ¬¡å¿«æ…¢æŒ‡é’ˆçš„ç›¸é‡ï¼Œ<code>y</code>å’Œ<code>z</code>éƒ½å·²ç»æ˜¯å·²çŸ¥å€¼ï¼Œæ‰€ä»¥æˆ‘ä»¬å°±å¯ä»¥æˆåŠŸæ‰¾å‡º<code>x</code>ï¼Œå¹¶ä¸”å‘ç°<code>x</code>åŸæ¥å°±ç­‰äº<code>z</code>å†åŠ ä¸Šè‹¥å¹²åœˆç¯çš„é•¿åº¦ã€‚æœ€åï¼ŒåŒæ—¶ä»å¤´ç»“ç‚¹å’Œç›¸é‡èŠ‚ç‚¹å‡ºå‘ï¼Œæ‰¾å‡º<code>x</code>å¯¹åº”ä½ç½®çš„èŠ‚ç‚¹å³å¯ã€‚</p>
<pre><code class="language-python">    def detectCycle(self, head: Optional[ListNode]) -&gt; Optional[ListNode]:
        slow = head
        fast = head
        while True:
            if fast is None or fast.next is None:
                return None
            fast = fast.next.next
            slow = slow.next  # No need to check slow
            if slow == fast:
                break
        slow = head
        while slow != fast:
            slow = slow.next
            fast = fast.next
        return slow
</code></pre>
<h2 id="æ€»ç»“">æ€»ç»“</h2>
<p>æ¶‰åŠé“¾è¡¨åŸºæœ¬æ“ä½œçš„é¢˜ï¼ˆå¦‚<a href="#203-remove-linked-list-elements">203</a>ã€<a href="#707-design-linked-list">707</a>ã€<a href="#206-reverse-linked-list">206</a>å’Œ<a href="#24-swap-nodes-in-pairs">24</a>ï¼‰åŸºæœ¬æ²¡æœ‰éš¾åº¦ï¼Œè¦ç‚¹å°±æ˜¯åŠ ä¸€ä¸ª<code>dummy_head</code>å¯ä»¥å¤§å¤§å‡å°ä»£ç çš„å¤æ‚ç¨‹åº¦ï¼ˆé¿å…å¯¹å¤´ç»“ç‚¹ç‰¹æ®Šæƒ…å†µçš„åˆ¤æ–­ï¼‰ã€‚<br>
æ¶‰åŠç®—æ³•çš„é¢˜ç›®åˆ™éƒ½ä¼šè¦æ±‚O(1)çš„ç©ºé—´å¤æ‚åº¦ï¼Œä¹Ÿå°±æ˜¯æˆ‘ä»¬ä¸èƒ½æŠŠèŠ‚ç‚¹éƒ½å­˜ä¸‹æ¥ã€‚åœ¨é“¾è¡¨æœ‰é™çš„éå†æ–¹å¼ä¸‹ï¼Œå¤§å¤šæ•°é¢˜ç›®éƒ½ä¼šä½¿ç”¨åŒæŒ‡é’ˆæ¥è§£ï¼Œé€šè¿‡æ¨å¯¼ä»¥åŠåˆ©ç”¨å¤šä¸ªæŒ‡é’ˆä¹‹é—´çš„å…³ç³»æ¥è¾¾æˆæˆ‘ä»¬æƒ³è¦çš„ç›®çš„ï¼Œä¾‹å¦‚</p>
<ul>
<li><a href="#19-remove-nth-node-from-end-of-list">[19] Remove Nth Node From End of List</a><br>
ä¸¤ä¸ªæŒ‡é’ˆé—´çš„è·ç¦»ä¿æŒå›ºå®šï¼Œå› æ­¤å‰ä¸€ä¸ªæŒ‡é’ˆå°±æ˜¯å€’æ•°ç¬¬Nä¸ªèŠ‚ç‚¹ã€‚</li>
<li><a href="#160-intersection-of-two-linked-lists">[160] Intersection of Two Linked Lists</a><br>
ä¸¤ä¸ªæŒ‡é’ˆä»ä¸åŒé“¾è¡¨å¼€å§‹äº¤é”™éå†ï¼Œåˆ°ç›¸äº¤èŠ‚ç‚¹èµ°è¿‡çš„è·ç¦»ç›¸åŒã€‚</li>
<li><a href="#142-linked-list-cycle-ii">[142] Linked List Cycle II</a>
<ul>
<li>ä¸¤ä¸ªæŒ‡é’ˆèµ°è¿‡çš„è·ç¦»æœ‰ä¸¤å€çš„å…³ç³»ï¼Œå¯ä»¥åˆ—æ–¹ç¨‹æŠŠ<code>x</code>ç”¨å·²çŸ¥çš„<code>y</code>å’Œ<code>z</code>è¡¨ç¤ºã€‚</li>
<li>ä¸¤ä¸ªæŒ‡é’ˆèµ°è¿‡çš„è·ç¦»ç›¸åŒï¼Œæ¥æ‰¾åˆ°<code>x</code>å¯¹åº”çš„èŠ‚ç‚¹ã€‚</li>
</ul>
</li>
</ul>
<h2 id="è¡¥å……">è¡¥å……</h2>
<h3 id="234-palindrome-linked-list">[234] Palindrome Linked List</h3>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/palindrome-linked-list/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
éš¾ç‚¹åœ¨äº<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>çš„æ—¶é—´å¤æ‚åº¦å’Œ<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>çš„ç©ºé—´å¤æ‚åº¦ã€‚<br>
è¿™é‡Œæˆ‘ä»¬å…ˆä½¿ç”¨å¿«æ…¢æŒ‡é’ˆï¼ˆå¿«æŒ‡é’ˆèµ°ä¸¤æ­¥ï¼Œæ…¢æŒ‡é’ˆèµ°ä¸€æ­¥ï¼‰çš„æ–¹å¼æ‰¾åˆ°é“¾è¡¨ä¸­é—´ä½ç½®ï¼ˆå…¶å®å…ˆéå†ä¸€éå¾—åˆ°é“¾è¡¨é•¿åº¦å†ç›´æ¥èµ°åˆ°ä¸­é—´ä¹Ÿæ˜¯ä¸€æ ·çš„ï¼‰ã€‚ç„¶åæˆ‘ä»¬ç¿»è½¬é“¾è¡¨çš„ååŠéƒ¨åˆ†ï¼Œå†åŒæ—¶éå†å‰åŠå’ŒååŠéƒ¨åˆ†çœ‹æ˜¯å¦ä¸€æ ·å³å¯ã€‚<br>
è¯¥ç®—æ³•è¿‡ç¨‹ä¿®æ”¹äº†åŸé“¾è¡¨ã€‚è™½ç„¶ä¸æ¢å¤é“¾è¡¨ä¹Ÿèƒ½é€šè¿‡æµ‹è¯•ï¼Œä½†æˆ‘ä»¬è¿˜æ˜¯é€šè¿‡<code>slow-&gt;next = reverseList(reversedHead);</code>çš„æ–¹å¼æ¢å¤äº†é“¾è¡¨ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    bool isPalindrome(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        bool result = true;
        while (fast-&gt;next &amp;&amp; fast-&gt;next-&gt;next) {
            slow = slow-&gt;next;
            fast = fast-&gt;next-&gt;next;
        }

        ListNode *reversedHead = reverseList(slow-&gt;next);

        ListNode *p1 = head;
        ListNode *p2 = reversedHead;
        while (p2) {
            if (p1-&gt;val != p2-&gt;val) {
                result = false;
            }
            p1 = p1-&gt;next;
            p2 = p2-&gt;next;
        }

        // Optional: recover the list
        slow-&gt;next = reverseList(reversedHead);

        return result;
    }

    ListNode *reverseList(ListNode *head) {
        ListNode *cur = head;
        ListNode *pre = nullptr;
        while (cur) {
            ListNode *succ = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = succ;
        }
        return pre;
    }
};
</code></pre>
<h3 id="141-linked-list-cycle">[141] Linked List Cycle</h3>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/linked-list-cycle/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ç›¸å½“äº<a href="#142-linked-list-cycle-ii">[142] Linked List Cycle II</a>çš„å‰ç½®é¢˜ç›®ã€‚è¿™é‡Œä¸éœ€è¦æ‰¾åˆ°ç¯çš„å…¥å£ï¼Œåªéœ€è¦åˆ¤æ–­æ˜¯å¦å­˜åœ¨ç¯å³å¯ã€‚æˆ‘ä»¬ä½¿ç”¨å¿«æ…¢æŒ‡é’ˆçœ‹æ˜¯å¦èƒ½ç›¸é‡å³å¯ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    bool hasCycle(ListNode *head) {
        ListNode *fast = head;
        ListNode *slow = head;
        while (fast &amp;&amp; fast-&gt;next) {
            fast = fast-&gt;next-&gt;next;
            slow = slow-&gt;next;
            if (fast == slow) {
                return true;
            }
        }
        return false;
    }
};
</code></pre>
<h3 id="21-merge-two-sorted-lists">[21] Merge Two Sorted Lists</h3>
<blockquote>
<p>éš¾åº¦ï¼šEasy<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ç±»ä¼¼å½’å¹¶æ’åºï¼Œæ¯æ¬¡é€‰ä¸¤ä¸ªé“¾è¡¨é‡Œé¢å¤§çš„é‚£ä¸ªèŠ‚ç‚¹ä½œä¸ºåç»§å³å¯ã€‚<br>
è¿™é‡Œç”¨<code>dummy</code>èŠ‚ç‚¹ç®€åŒ–äº†å¤´ç»“ç‚¹åˆ¤æ–­ï¼Œåˆç”¨äº†<code>succ</code>ä½œä¸º<code>p1</code>æˆ–<code>p2</code>çš„å¼•ç”¨æ¥å‡å°‘é‡å¤ä»£ç ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    ListNode *mergeTwoLists(ListNode *list1, ListNode *list2) {
        ListNode *p1 = list1;
        ListNode *p2 = list2;
        ListNode *dummy = new ListNode(0);
        ListNode *cur = dummy;
        while (p1 &amp;&amp; p2) {
            ListNode *&amp;succ = p1-&gt;val &lt; p2-&gt;val ? p1 : p2;
            cur-&gt;next = succ;
            cur = succ;
            succ = succ-&gt;next;
        }
        cur-&gt;next = p1 ? p1 : p2;
        ListNode *result = dummy-&gt;next;
        delete dummy;
        return result;
    }
};
</code></pre>
<h3 id="2-add-two-numbers">[2] Add Two Numbers</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/add-two-numbers/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
é“¾è¡¨å·²ç»å€’åºï¼Œé‚£ä¹ˆå°±å¾ˆæ–¹ä¾¿ï¼ŒæŒ‰ä½ç›¸åŠ <code>num1 + num2 + carry</code>ï¼Œå¾—åˆ°ä¸‹ä¸€ä½çš„æ•°å­—<code>sum % 10</code>å’Œ<code>carry = sum / 10</code>ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode *dummy = new ListNode(0);
        ListNode *cur = dummy;
        int carry = 0;
        while (l1 || l2 || carry) {
            int num1 = l1 ? l1-&gt;val : 0;
            int num2 = l2 ? l2-&gt;val : 0;
            int sum = num1 + num2 + carry;
            cur-&gt;next = new ListNode(sum % 10);
            carry = sum / 10;
            if (l1) {
                l1 = l1-&gt;next;
            }
            if (l2) {
                l2 = l2-&gt;next;
            }
            cur = cur-&gt;next;
        }
        ListNode *result = dummy-&gt;next;
        delete dummy;
        return result;
    }
};
</code></pre>
<h3 id="25-reverse-nodes-in-k-group">[25] Reverse Nodes in k-Group</h3>
<blockquote>
<p>éš¾åº¦ï¼šHard<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
æ¯æ¬¡æ‰¾åˆ°å½“å‰ç»„çš„å¼€å¤´<code>curHead</code>å’Œä¸‹ä¸€ç»„çš„å¼€å¤´<code>nextHead</code>ï¼Œç„¶åä¸€ç»„ä¸€ç»„ç¿»è½¬å³å¯ã€‚<br>
é—®é¢˜åœ¨äºï¼Œç¿»è½¬åæˆ‘ä»¬è¿˜éœ€è¦æŠŠå½“å‰ç»„é‡æ–°ä¸å‰åç»„è¿ä¸Šã€‚å› æ­¤æˆ‘ä»¬ç”¨<code>pre</code>è®°å½•ä¸Šä¸€ç»„çš„ç»“å°¾ï¼Œç¿»è½¬åæ‰‹åŠ¨æŠŠ<code>pre</code>è¿ä¸Šå½“å‰ç»„ç¿»è½¬åçš„å¼€å¤´ã€‚æˆ‘ä»¬åˆæŠŠ<code>nextHead</code>ä¼ ç»™ç¿»è½¬å‡½æ•°ï¼Œä½¿å½“å‰ç»„çš„æ—§å¼€å¤´å³æ–°ç»“å°¾è¿ä¸Š<code>nextHead</code>ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    ListNode *reverseKGroup(ListNode *head, int k) {
        ListNode *pre = nullptr;
        ListNode *curHead = head;
        ListNode *nextHead = curHead;
        ListNode *newHead = head;
        while (curHead) {
            for (int i = 0; i &lt; k; ++i) {
                if (!nextHead) {
                    return newHead;
                }
                nextHead = nextHead-&gt;next;
            }
            (pre ? pre-&gt;next : newHead) = reverseOneList(curHead, nextHead);
            pre = curHead; // curHead become tail now
            curHead = nextHead;
        }
        return newHead;
    }

    ListNode *reverseOneList(ListNode *head, ListNode *end) {
        ListNode *cur = head;
        ListNode *pre = end;
        while (cur != end) {
            ListNode *succ = cur-&gt;next;
            cur-&gt;next = pre;
            pre = cur;
            cur = succ;
        }
        return pre;
    }
};
</code></pre>
<h3 id="138-copy-list-with-random-pointer">[138] Copy List with Random Pointer</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ä¸‰æ¬¡éå†ã€‚</p>
<ul>
<li>ç¬¬ä¸€æ¬¡éå†æŠŠå¤åˆ¶çš„èŠ‚ç‚¹æ’åˆ°åŸèŠ‚ç‚¹åé¢å˜æˆ<code>A --&gt; A' --&gt; B --&gt; B' --&gt; C --&gt; C'</code>ã€‚</li>
<li>ç¬¬äºŒæ¬¡éå†ç”¨æ¥å¡«<code>random</code>ã€‚<code>A'</code>çš„<code>random</code>å°±æ˜¯<code>A</code>çš„<code>random</code>çš„<code>next</code>ã€‚</li>
<li>ç¬¬ä¸‰æ¬¡éå†ç”¨æ¥æŠŠ<code>A' --&gt; B' --&gt; C'</code>æ‹†å‡ºæ¥ã€‚</li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    Node *copyRandomList(Node *head) {
        if (!head) {
            return nullptr;
        }

        // A --&gt; A' --&gt; B --&gt; B' --&gt; C --&gt; C'
        Node *cur = head;
        while (cur) {
            Node *nxt = cur-&gt;next;
            cur-&gt;next = new Node(cur-&gt;val);
            cur-&gt;next-&gt;next = nxt;
            cur = nxt;
        }

        // Set random pointers for A', B' and C'
        cur = head;
        while (cur) {
            cur-&gt;next-&gt;random = cur-&gt;random ? cur-&gt;random-&gt;next : nullptr;
            cur = cur-&gt;next-&gt;next;
        }

        // Extract the new list
        cur = head;
        Node *newHead = head-&gt;next;
        while (cur) {
            Node *nxt = cur-&gt;next-&gt;next;
            cur-&gt;next-&gt;next = nxt ? nxt-&gt;next : nullptr;
            cur-&gt;next = nxt;
            cur = nxt;
        }
        return newHead;
    }
};
</code></pre>
<h3 id="148-sort-list">[148] Sort List</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/sort-list/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
è¾ƒæœ‰éš¾åº¦çš„ä¸€é“é¢˜ã€‚éš¾åº¦åœ¨äºï¼Œä¸ºäº†åŒæ—¶è¾¾åˆ°<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>çš„æ—¶é—´å¤æ‚åº¦å’Œ<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>çš„ç©ºé—´å¤æ‚åº¦ï¼Œæˆ‘ä»¬è€ƒè™‘ä½¿ç”¨è‡ªåº•å‘ä¸Šï¼ˆè¿­ä»£æ³•ï¼‰çš„å½’å¹¶æ’åºã€‚è€Œè¿™æ ·çš„ä»£ç å®ç°åœ¨é“¾è¡¨ä¸Šæ˜¾ç„¶æ˜¯æ¯”è¾ƒå¤æ‚çš„ï¼Œå¾ˆå®¹æ˜“å‡ºé”™ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    ListNode *sortList(ListNode *head) {
        if (!head) {
            return nullptr;
        }

        ListNode *dummy = new ListNode(0, head);

        // Get the length of the list
        ListNode *cur = head;
        int length = 0;
        while (cur) {
            ++length;
            cur = cur-&gt;next;
        }

        // Merge Sort
        for (int i = 1; i &lt; length; i &lt;&lt;= 1) {
            ListNode *pre = dummy;
            cur = dummy-&gt;next;
            while (cur) {
                // 1. Get head1
                ListNode *head1 = cur;

                // 2. Get head2
                for (int j = 1; j &lt; i &amp;&amp; cur-&gt;next; ++j) {
                    cur = cur-&gt;next;
                }
                // Now cur is the tail of list1.
                // cur-&gt;next is head2.
                ListNode *head2 = cur-&gt;next;
                cur-&gt;next = nullptr;
                cur = head2;

                // 3. Get next cur
                for (int j = 1; j &lt; i &amp;&amp; cur; ++j) {
                    cur = cur-&gt;next;
                }
                ListNode *nxt = nullptr;
                if (cur) {
                    nxt = cur-&gt;next;
                    cur-&gt;next = nullptr;
                }

                // 4. Merge
                pre-&gt;next = merge(head1, head2);

                // 5. Set next pre and cur
                while (pre-&gt;next) {
                    pre = pre-&gt;next;
                }
                cur = nxt;
            }
        }

        ListNode *result = dummy-&gt;next;
        delete dummy;
        return result;
    }

    ListNode *merge(ListNode *head1, ListNode *head2) {
        ListNode *dummy = new ListNode(0);
        ListNode *pre = dummy;
        while (head1 &amp;&amp; head2) {
            ListNode *&amp;choosen = head1-&gt;val &lt; head2-&gt;val ? head1 : head2;
            pre-&gt;next = choosen;
            pre = choosen;
            choosen = choosen-&gt;next;
        }
        pre-&gt;next = head1 ? head1 : head2;
        ListNode *head = dummy-&gt;next;
        delete dummy;
        return head;
    }
};
</code></pre>
<h3 id="23-merge-k-sorted-lists">[23] Merge k Sorted Lists</h3>
<blockquote>
<p>éš¾åº¦ï¼šHard<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ç›¸æ¯”<a href="#21-merge-two-sorted-lists">[21] Merge Two Sorted Lists</a>åªæ˜¯æŠŠä¸¤ä¸ªé“¾è¡¨æ‰©å±•æˆäº†kä¸ªé“¾è¡¨ã€‚<br>
ç®€å•çš„æƒ³æ³•æ˜¯æˆ‘ä»¬æ¯æ¬¡ä»kä¸ªé“¾è¡¨é‡Œé¢å–å€¼æœ€å°çš„é‚£ä¸ªèŠ‚ç‚¹å³å¯ã€‚è¿™é‡Œåˆ™ä½¿ç”¨ä¼˜å…ˆçº§é˜Ÿåˆ—è¿›ä¸€æ­¥ä¼˜åŒ–äº†è¿™ä¸ªä»kä¸ªé‡Œé¢æ‰¾æœ€å°èŠ‚ç‚¹çš„è¿‡ç¨‹ã€‚</p>
<pre><code class="language-c++">class Solution {
  public:
    ListNode *mergeKLists(vector&lt;ListNode *&gt; &amp;lists) {
        auto cmp = [](const ListNode *a, const ListNode *b) {
            return a-&gt;val &gt; b-&gt;val;
        };

        ListNode *dummy = new ListNode(0);
        ListNode *pre = dummy;
        priority_queue&lt;ListNode *, vector&lt;ListNode *&gt;, decltype(cmp)&gt; q;

        for (ListNode *head : lists) {
            if (head) {
                q.push(head);
            }
        }
        while (!q.empty()) {
            ListNode *node = q.top();
            q.pop();
            pre-&gt;next = node;
            pre = node;
            if (node-&gt;next) {
                q.push(node-&gt;next);
            }
        }
        ListNode *result = dummy-&gt;next;
        delete dummy;
        return result;
    }
};
</code></pre>
<h3 id="146-lru-cache">[146] LRU Cache</h3>
<blockquote>
<p>éš¾åº¦ï¼šMedium<br>
è¯­è¨€ï¼šC++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/lru-cache/description/">é¢˜ç›®æè¿°</a>ã€‚<br>
ä½¿ç”¨å“ˆå¸Œè¡¨+åŒå‘é“¾è¡¨å³å¯ï¼Œå“ˆå¸Œè¡¨æŒ‡å‘åŒå‘é“¾è¡¨ä¸­çš„èŠ‚ç‚¹ã€‚<br>
å“ˆå¸Œè¡¨è´Ÿè´£å®Œæˆ<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>æŸ¥æ‰¾ï¼ŒåŒå‘é“¾è¡¨è´Ÿè´£å®Œæˆ<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>ç§»åŠ¨ï¼ˆæ’å…¥æˆ–åˆ é™¤ï¼‰ã€‚</p>
<pre><code class="language-c++">class LRUCache {
    struct ListNode {
        int key;
        int val;
        ListNode *prev;
        ListNode *succ;

        ListNode(int key, int val)
            : key(key), val(val), prev(nullptr), succ(nullptr) {};
        ListNode(int key, int val, ListNode *prev, ListNode *succ)
            : key(key), val(val), prev(prev), succ(succ) {};
    };

    ListNode *dummyHead;
    ListNode *dummyTail;
    unordered_map&lt;int, ListNode *&gt; umap;
    int capacity;
    int size;

  public:
    LRUCache(int capacity) : capacity(capacity) {
        dummyHead = new ListNode(-1, 0);
        dummyTail = new ListNode(-1, 0);
        dummyHead-&gt;succ = dummyTail;
        dummyTail-&gt;prev = dummyHead;

        size = 0;
    }

    ListNode *getNode(int key) {
        auto iter = umap.find(key);
        if (iter == umap.end()) {
            return nullptr;
        }
        ListNode *node = iter-&gt;second;
        node-&gt;succ-&gt;prev = node-&gt;prev;
        node-&gt;prev-&gt;succ = node-&gt;succ;

        node-&gt;succ = dummyHead-&gt;succ;
        node-&gt;prev = dummyHead;
        dummyHead-&gt;succ-&gt;prev = node;
        dummyHead-&gt;succ = node;
        return node;
    }

    int get(int key) {
        ListNode *node = getNode(key);
        return node ? node-&gt;val : -1;
    }

    void put(int key, int value) {
        ListNode *node = getNode(key);
        if (!node) {
            node = new ListNode(key, value, dummyHead, dummyHead-&gt;succ);
            dummyHead-&gt;succ-&gt;prev = node;
            dummyHead-&gt;succ = node;
            size += 1;
            umap[key] = node;

            if (size &gt; capacity) {
                node = dummyTail-&gt;prev;
                node-&gt;prev-&gt;succ = dummyTail;
                dummyTail-&gt;prev = node-&gt;prev;
                umap.erase(node-&gt;key);
                delete node;
                size -= 1;
            }
        } else {
            node-&gt;val = value;
        }
    }
};
</code></pre>

              </div>
              <div class="toc-container">
                <ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#203-remove-linked-list-elements">[203] Remove Linked List Elements</a></li>
<li><a href="#707-design-linked-list">[707] Design Linked List</a></li>
<li><a href="#206-reverse-linked-list">[206] Reverse Linked List</a></li>
<li><a href="#24-swap-nodes-in-pairs">[24] Swap Nodes in Pairs</a></li>
<li><a href="#19-remove-nth-node-from-end-of-list">[19] Remove Nth Node From End of List</a></li>
<li><a href="#160-intersection-of-two-linked-lists">[160] Intersection of Two Linked Lists</a></li>
<li><a href="#142-linked-list-cycle-ii">[142] Linked List Cycle II</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">æ€»ç»“</a></li>
<li><a href="#%E8%A1%A5%E5%85%85">è¡¥å……</a>
<ul>
<li><a href="#234-palindrome-linked-list">[234] Palindrome Linked List</a></li>
<li><a href="#141-linked-list-cycle">[141] Linked List Cycle</a></li>
<li><a href="#21-merge-two-sorted-lists">[21] Merge Two Sorted Lists</a></li>
<li><a href="#2-add-two-numbers">[2] Add Two Numbers</a></li>
<li><a href="#25-reverse-nodes-in-k-group">[25] Reverse Nodes in k-Group</a></li>
<li><a href="#138-copy-list-with-random-pointer">[138] Copy List with Random Pointer</a></li>
<li><a href="#148-sort-list">[148] Sort List</a></li>
<li><a href="#23-merge-k-sorted-lists">[23] Merge k Sorted Lists</a></li>
<li><a href="#146-lru-cache">[146] LRU Cache</a></li>
</ul>
</li>
</ul>
</li>
</ul>

              </div>
            </div>
          </article>
        </div>

        
          <div class="next-post">
            <div class="next">ä¸‹ä¸€ç¯‡</div>
            <a href="https://alleny.xyz/post/leetcode-array/">
              <h3 class="post-title">
                LeetCodeåˆ·é¢˜è®°å½•ï¼ˆæ•°ç»„ç¯‡ï¼‰
              </h3>
            </a>
          </div>
        

        
          

          
            <link rel="stylesheet" href="https://unpkg.com/disqusjs@1.1/dist/disqusjs.css">
<script src="https://unpkg.com/disqusjs@1.1/dist/disqus.js"></script>

<div id="disqus_thread"></div>

<script>

var options = {
  shortname: 'alleny-blog',
  apikey: '2kPJh2tQ0rWB7n0QOhvb9TLbm946tHMWCixW2qGF9j8tfMBgZoNPfvLpDoxZTZpD',
}
if ('https://disqus.hangyu-yuan.workers.dev/api/') {
  options.api = 'https://disqus.hangyu-yuan.workers.dev/api/'
}
var dsqjs = new DisqusJS(options)

</script>

          
        

        <div class="site-footer">
  Copyright Â© 2023-2025 Allen Yuan. All rights reserved.
  <a class="rss" href="https://alleny.xyz/atom.xml" target="_blank">
    <i class="ri-rss-line"></i> RSS
  </a>
</div>

      </div>
    </div>

    <script>
      hljs.initHighlightingOnLoad()

      let mainNavLinks = document.querySelectorAll(".markdownIt-TOC a");

      // This should probably be throttled.
      // Especially because it triggers during smooth scrolling.
      // https://lodash.com/docs/4.17.10#throttle
      // You could do like...
      // window.addEventListener("scroll", () => {
      //    _.throttle(doThatStuff, 100);
      // });
      // Only not doing it here to keep this Pen dependency-free.

      window.addEventListener("scroll", event => {
        let fromTop = window.scrollY;

        mainNavLinks.forEach((link, index) => {
          let section = document.getElementById(decodeURI(link.hash).substring(1));
          let nextSection = null
          if (mainNavLinks[index + 1]) {
            nextSection = document.getElementById(decodeURI(mainNavLinks[index + 1].hash).substring(1));
          }
          if (section.offsetTop <= fromTop) {
            if (nextSection) {
              if (nextSection.offsetTop > fromTop) {
                link.classList.add("current");
              } else {
                link.classList.remove("current");    
              }
            } else {
              link.classList.add("current");
            }
          } else {
            link.classList.remove("current");
          }
        });
      });

    </script>
  </body>
</html>
