<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://alleny.xyz</id>
    <title>AllenY&apos;s blog</title>
    <updated>2025-05-13T07:19:56.289Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://alleny.xyz"/>
    <link rel="self" href="https://alleny.xyz/atom.xml"/>
    <subtitle>🧑🏻‍💻🎮🍿🎹🗻</subtitle>
    <logo>https://alleny.xyz/images/avatar.png</logo>
    <icon>https://alleny.xyz/favicon.ico</icon>
    <rights>All rights reserved 2025, AllenY&apos;s blog</rights>
    <entry>
        <title type="html"><![CDATA[FlashAttention简析]]></title>
        <id>https://alleny.xyz/post/flashattention/</id>
        <link href="https://alleny.xyz/post/flashattention/">
        </link>
        <updated>2025-02-15T11:44:25.000Z</updated>
        <summary type="html"><![CDATA[<p>FlashAttention 由斯坦福大学和纽约州立大学布法罗分校的研究人员提出，它是一种优化 Transformer 自注意力计算的算法，通过减少 GPU 内存访问提高计算效率，加速训练并支持更长序列处理。本文为对该算法的简单介绍分析。</p>
]]></summary>
        <content type="html"><![CDATA[<p>FlashAttention 由斯坦福大学和纽约州立大学布法罗分校的研究人员提出，它是一种优化 Transformer 自注意力计算的算法，通过减少 GPU 内存访问提高计算效率，加速训练并支持更长序列处理。本文为对该算法的简单介绍分析。</p>
<!-- more -->
<h2 id="背景">背景</h2>
<h3 id="attention">Attention</h3>
<figure data-type="image" tabindex="1"><img src="https://alleny.xyz/post-images/1739614257370.png" alt="" loading="lazy"></figure>
<h3 id="memory-hierarchy">Memory Hierarchy</h3>
<p><img src="https://alleny.xyz/post-images/1739518220515.png" alt="" loading="lazy"><br>
下面的HBM和DRAM大而慢，上面的SRAM快而小。</p>
<h2 id="flashattention的垫脚石online-softmax">FlashAttention的垫脚石：Online Softmax</h2>
<h3 id="safe-softmax">(Safe) Softmax</h3>
<p>回顾Softmax的公式：<br>
<img src="https://alleny.xyz/post-images/1739612065781.png" alt="" loading="lazy"></p>
<p>看起来简单又美好。然而，注意到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><msub><mi>x</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">e^{x_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>是非常容易溢出的。例如，F16的最大表示值为65536，而<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>只需要大于等于11便可使其超出F16的最大表示范围。</p>
<p>因此，实际应用中常常使用一种叫做“safe” softmax的trick。<br>
<img src="https://alleny.xyz/post-images/1739612293951.png" alt="" loading="lazy"><br>
其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi><mo>=</mo><msubsup><mi>max</mi><mo>⁡</mo><mrow><mi>j</mi><mo>=</mo><mn>1</mn></mrow><mi>N</mi></msubsup><mo>(</mo><msub><mi>x</mi><mi>j</mi></msub><mo>)</mo></mrow><annotation encoding="application/x-tex">m = \max^N_{j=1}(x_j)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.236103em;vertical-align:-0.394772em;"></span><span class="mop"><span class="mop">max</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>，即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>中的最大值。如此一来，我们便有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub><mo>−</mo><mi>m</mi><mo>≤</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">x_i - m \le 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.7719400000000001em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">m</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span>。</p>
<p>于是，计算一次safe softmax，我们需要3-pass：</p>
<ul>
<li>找到最大值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">d_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</li>
<li>计算每个softmax结果。<br>
<img src="https://alleny.xyz/post-images/1739612501510.png" alt="" loading="lazy"></li>
</ul>
<p>需要注意<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>是在global memory中的（因为SRAM中放不下所有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">x</span></span></span></span>）。因此这里涉及到了对global memory的3轮读写，非常不I/O efficient。</p>
<h3 id="从3-pass到2-pass">从3-pass到2-pass</h3>
<p>注意到，我们先用了一个pass来找到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，再把这个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>用到第二个pass计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">d_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。那么，我们能不能把这两个过程合并起来呢？换句话说，是否能不用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，而是用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>d</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">d_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>？</p>
<p>于是，我们尝试使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>来代替<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。既然使用的不是正确的最大值<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，那么我们还需要在过程中把之前所使用的错误的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">m_{i-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>值去掉，替换成新的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_{i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>（通过乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>e</mi><msub><mi>m</mi><mrow><mi>i</mi><mo>−</mo><mn>1</mn></mrow></msub></msup><mo>−</mo><msup><mi>e</mi><msub><mi>m</mi><mi>i</mi></msub></msup></mrow><annotation encoding="application/x-tex">e^{m_{i-1}}-e^{m_i}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.747722em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32808571428571426em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20252142857142857em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">e</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span></span>）。如此一来，最终<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mrow><mi>N</mi><mo>−</mo><mn>1</mn></mrow></msub></mrow><annotation encoding="application/x-tex">m_{N-1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span></span></span></span>会被替换成<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">m_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>,便可使最终的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>d</mi><mi>N</mi><mo mathvariant="normal">′</mo></msubsup><mo>=</mo><msub><mi>d</mi><mi>N</mi></msub></mrow><annotation encoding="application/x-tex">d&#x27;_N = d_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.027223em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.32833099999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>凑项，我们便可得到如下公式。</p>
<figure data-type="image" tabindex="2"><img src="https://alleny.xyz/post-images/1739613153848.png" alt="" loading="lazy"></figure>
<p>如此合并，便可得到如下的2-pass online softmax。<br>
<img src="https://alleny.xyz/post-images/1739613689906.png" alt="" loading="lazy"></p>
<p>很遗憾，到了这里就不能继续合并了。因为每个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的计算都严格依赖于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>d</mi><mi>N</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.027223em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<h2 id="flashattention">FlashAttention</h2>
<p><strong>基本思路：尽量避免将中间结果写入DRAM。</strong></p>
<p>传统Attention中<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>S</mi></mrow><annotation encoding="application/x-tex">S</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.05764em;">S</span></span></span></span>矩阵的内存效率是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><msup><mi>N</mi><mn>2</mn></msup><mo>)</mo></mrow><annotation encoding="application/x-tex">O(N^2)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">)</span></span></span></span>的，这使得Attention计算过程的I/O开销不可小觑。</p>
<p>在矩阵乘法中，我们可以通过tiling的方式，减小每个block需处理的数据大小，从而将数据放置到较小的SRAM中以加速I/O。</p>
<p>要加速Attention计算过程，我们可以很容易想到可以把算子做Fusion，并通过分块的方式尽量将中间结果写到SRAM，从而减少对DRAM的读写。如果没有softmax过程，仅仅是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi><msup><mi>K</mi><mi>T</mi></msup><mi>V</mi></mrow><annotation encoding="application/x-tex">QK^TV</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.035771em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span></span></span></span></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>的矩阵相乘，那么确实通过tiling就可以简单做到。</p>
<p>但现在的问题是，softmax是对矩阵的一整行而言的。如果做了分块，我们还如何正确计算softmax？也就是说，<strong>softmax的存在使对attention做fusion变得困难</strong>。</p>
<p>而FlashAttention的作者则正是利用了前文提到的online softmax所使用的思路，从而完成了这一过程。我们可以认为，online softmax使对softmax分块变为了可能。作者将这个过程一整个整合到了attention计算中，从而完成了attention计算的分块和fusion。</p>
<p>更重要的是，原本由于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>a</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">a_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">a</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的计算依赖于<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>d</mi><mi>N</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.027223em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span></span></span></span>导致2-pass无法继续合并。而attention计算中，我们最终只关注softmax乘上<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>并累加的结果<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>。<strong>这使得，我们可以在计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>的过程中同时不断修正<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi></mrow><annotation encoding="application/x-tex">O</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span></span></span></span>，使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">O_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>的计算过程不依赖<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>d</mi><mi>N</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.027223em;vertical-align:-0.275331em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.424669em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.10903em;">N</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.275331em;"><span></span></span></span></span></span></span></span></span></span>而是<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>d</mi><mi>i</mi><mo mathvariant="normal">′</mo></msubsup></mrow><annotation encoding="application/x-tex">d&#x27;_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.010556em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">d</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>，使得进一步的合并变得可能</strong>，如下所示。</p>
<figure data-type="image" tabindex="3"><img src="https://alleny.xyz/post-images/1739617904209.png" alt="" loading="lazy"></figure>
<p>最终，分块后的计算变为了one-pass。</p>
<figure data-type="image" tabindex="4"><img src="https://alleny.xyz/post-images/1739618029585.png" alt="" loading="lazy"></figure>
<p>结合分块，最终有整体伪代码如下。</p>
<figure data-type="image" tabindex="5"><img src="https://alleny.xyz/post-images/1739618083294.png" alt="" loading="lazy"></figure>
<p>简单来说，外循环对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>K</mi></mrow><annotation encoding="application/x-tex">K</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">K</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>分块，内循环对<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>Q</mi></mrow><annotation encoding="application/x-tex">Q</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8777699999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">Q</span></span></span></span>分块。然后，计算<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mrow><mi>i</mi><mi>j</mi></mrow></msub><mo>=</mo><msub><mi>Q</mi><mi>i</mi></msub><msubsup><mi>K</mi><mi>j</mi><mi>T</mi></msubsup></mrow><annotation encoding="application/x-tex">S_{ij} = Q_iK^T_j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.969438em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">i</span><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.236103em;vertical-align:-0.394772em;"></span><span class="mord"><span class="mord mathdefault">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.07153em;">K</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8413309999999999em;"><span style="top:-2.441336em;margin-left:-0.07153em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.394772em;"><span></span></span></span></span></span></span></span></span></span>，计算局部<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>m</mi></mrow><annotation encoding="application/x-tex">m</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">m</span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>P</mi></mrow><annotation encoding="application/x-tex">P</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.13889em;">P</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span></span></span></span>，更新<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>m</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msup></mrow><annotation encoding="application/x-tex">m^{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.664392em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mi>l</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msup></mrow><annotation encoding="application/x-tex">l^{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span></span></span></span></span></span></span></span>，乘<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>V</mi></mrow><annotation encoding="application/x-tex">V</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.22222em;">V</span></span></span></span>累加到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>O</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">O_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.02778em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>并同时用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msubsup><mi>m</mi><mi>i</mi><mrow><mi>n</mi><mi>e</mi><mi>w</mi></mrow></msubsup></mrow><annotation encoding="application/x-tex">m_i^{new}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.923056em;vertical-align:-0.258664em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.664392em;"><span style="top:-2.441336em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">n</span><span class="mord mathdefault mtight">e</span><span class="mord mathdefault mtight" style="margin-right:0.02691em;">w</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.258664em;"><span></span></span></span></span></span></span></span></span></span>在线更新旧的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>m</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">m_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault">m</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>。</p>
<h2 id="总结">总结</h2>
<p>我们可以对FlashAttention的优化思路有如下概括：</p>
<p>目标：优化Attention的I/O效率。<br>
--&gt; 使用tiling和算子融合，使中间结果可以放到SRAM，减少对DRAM的I/O。<br>
--&gt; 问题：softmax的存在使tiling变得困难。<br>
--&gt; 应用online softmax方法。</p>
<p>至此，对FlashAttention的基本思路有了大概的了解。后续FlashAttention-v2又在此基础上有一些新的的优化，例如交换了内外分块循环的顺序等，这里就不多描述了。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题记录（技巧篇）]]></title>
        <id>https://alleny.xyz/post/leetcode-misc/</id>
        <link href="https://alleny.xyz/post/leetcode-misc/">
        </link>
        <updated>2024-12-18T02:20:12.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode刷题记录（技巧篇），个人向。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode刷题记录（技巧篇），个人向。</p>
<!-- more -->
<h2 id="136-single-number">[136] Single Number</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/single-number/description/">题目描述</a>。<br>
简单的位运算，全部异或一遍即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    int singleNumber(vector&lt;int&gt; &amp;nums) {
        int result = 0;
        for (int num : nums) {
            result ^= num;
        }
        return result;
    }
};
</code></pre>
<h2 id="169-majority-element">[169] Majority Element</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/majority-element/description/">题目描述</a>。<br>
题目难点在于要求了<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的时间复杂度和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>的空间复杂度。<br>
这里使用了 Boyer-Moore 投票算法，具体可参考<a href="https://leetcode.cn/problems/majority-element/solutions/146074/duo-shu-yuan-su-by-leetcode-solution/">这篇solution</a>。<br>
简单来说，这里维护了<code>candidate</code>和<code>count</code>两个变量。在当前元素和<code>candidate</code>相等时，<code>count+=1</code>，否则<code>count-=1</code>。此外，若<code>count == 0</code>，则会先更新<code>candidate</code>为当前元素。</p>
<pre><code class="language-c++">class Solution {
  public:
    int majorityElement(vector&lt;int&gt; &amp;nums) {
        int candidate = 0;
        int count = 0;
        for (int num : nums) {
            if (count == 0) {
                candidate = num;
            }
            if (candidate == num) {
                count += 1;
            } else {
                count -= 1;
            }
        }
        return candidate;
    }
};
</code></pre>
<h2 id="75-sort-colors">[75] Sort Colors</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/sort-colors/description/">题目描述</a>。<br>
题目要求one-pass和constant extra space。constant extra space很简单，关键在于这个one-pass。<br>
已知用一个指针可以很容易想到先把0都换到前面，再把1都换到前面，但这样需要two-pass。既然一个指针是two-pass，那我们就使用两个指针，分别负责填两个颜色。<br>
我们可以使用一个指针用来填红色（代表数字0），一个用来填蓝色（代表数字2）。第一个指针从开头开始，另一个指针从尾部开始。遇到0，我们就把数字换到开头指针（<code>resPos</code>）；遇到2，我们就把数字换到尾部指针（<code>bluePos</code>）。<br>
但遇到2时，不能只是换一遍这么简单，因为可能换回来的还是2。因此我们应该连续不断地把2换到后面（同时也在不断<code>bludPos -= 1</code>），直到换回来的不是2。这时候换回来的有可能是0，我们还需要把0换到<code>redPos</code>，然后才开始考虑下一个元素。<br>
为什么遇到0时只需要换一次，而不需要像遇到2一样一直换？这是因为遇到0且换回0只会发生在当前位置元素自己和自己交换的情况，不会忽略其他未处理的0。遇到0也不可能换回2，因为遇到过的2已经被换到最后了。<strong>这里出现差异的根本原因是，我们在遍历数组时是从开头即<code>redPos</code>这边遍历过来的，遇到0时从<code>redPos</code>换回来的元素都是从遍历过的位置换回来的，而遇到2时从<code>bluePos</code>换回的元素是来自还没遍历过的位置的</strong>。<br>
另一种双指针的方法是一个指针处理0，一个指针处理1，可参考<a href="https://leetcode.cn/problems/sort-colors/solutions/437968/yan-se-fen-lei-by-leetcode-solution/">这篇solution</a>。</p>
<pre><code class="language-c++">class Solution {
  public:
    void sortColors(vector&lt;int&gt; &amp;nums) {
        int redPos = 0;
        int bluePos = nums.size() - 1;
        int tmp = 0;
        for (int i = 0; i &lt;= bluePos; ++i) {
            while (i &lt;= bluePos &amp;&amp; nums[i] == 2) {
                tmp = nums[bluePos];
                nums[bluePos] = 2;
                nums[i] = tmp;
                bluePos -= 1;
            }
            if (nums[i] == 0) {
                tmp = nums[redPos];
                nums[redPos] = 0;
                nums[i] = tmp;
                redPos += 1;
            }
        }
    }
};
</code></pre>
<h2 id="31-next-permutation">[31] Next Permutation</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/next-permutation/description/">题目描述</a>。</p>
<ul>
<li><strong>从后向前</strong>遍历，寻找相邻的递增序列<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[i, i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]&lt;nums[i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i+1, end]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>都是递减序列。</li>
<li>再次<strong>从后向前</strong>遍历，直到遇到第一个<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span></span>使<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>&lt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]&lt;nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>。此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>就是比<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>大一点但是在<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i+1, end]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>中尽可能小的数。</li>
<li>交换<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>和<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span>。</li>
<li>此时<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>e</mi><mi>n</mi><mi>d</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">[i+1, end]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">e</span><span class="mord mathdefault">n</span><span class="mord mathdefault">d</span><span class="mclose">]</span></span></span></span>仍为递减序列。我们倒序该部分使其变成递增序列。
<ul>
<li>注意如果第一步中我们没有找到这样的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo separator="true">,</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[i, i+1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>，说明整个数组都是递减序列，此时我们直接倒序整个数组即可。</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    void nextPermutation(vector&lt;int&gt; &amp;nums) {
        int n = nums.size();
        int i = n - 2;
        while (i &gt;= 0 &amp;&amp; nums[i] &gt;= nums[i + 1]) {
            --i;
        }
        if (i &gt;= 0) {
            for (int j = n - 1; j &gt; i; --j) {
                if (nums[j] &gt; nums[i]) {
                    int tmp = nums[i];
                    nums[i] = nums[j];
                    nums[j] = tmp;
                    break;
                }
            }
        }
        for (int left = i + 1, right = n - 1; left &lt; right; ++left, --right) {
            int tmp = nums[left];
            nums[left] = nums[right];
            nums[right] = tmp;
        }
    }
};
</code></pre>
<h2 id="287-find-the-duplicate-number">[287] Find the Duplicate Number</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/find-the-duplicate-number/description/">题目描述</a>。<br>
把<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span>到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">nums[i]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span></span></span>看作是有一条边，有重复数字就变成了图有环，重复数字就是环的入口，寻找重复数字就是寻找这个环的入口。整道题就变成了<a href="https://alleny.xyz/post/leetcode-linked-list/#142-linked-list-cycle-ii">[142] Linked List Cycle II</a>。</p>
<pre><code class="language-c++">class Solution {
  public:
    int findDuplicate(vector&lt;int&gt; &amp;nums) {
        int fast = 0;
        int slow = 0;
        do {
            slow = nums[slow];
            fast = nums[fast];
            fast = nums[fast];
        } while (slow != fast);
        slow = 0;
        while (slow != fast) {
            slow = nums[slow];
            fast = nums[fast];
        }
        return slow;
    }
};
</code></pre>
<h2 id="总结">总结</h2>
<p>这部分什么类型的题都有。<a href="#136-single-number">[136] Single Number</a>考察的是位运算；<a href="#169-majority-element">[169] Majority Element</a>用了Boyer-Moore 投票算法；<a href="#75-sort-colors">[75] Sort Colors</a>使用了双指针；<a href="#31-next-permutation">[31] Next Permutation</a>算是一道找规律的题目，最后是用了两次从后向前的遍历再加上倒序；<a href="#287-find-the-duplicate-number">[287] Find the Duplicate Number</a>则是被转化成了环形链表的题目。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题记录（动态规划篇）]]></title>
        <id>https://alleny.xyz/post/leetcode-dynamic-programming/</id>
        <link href="https://alleny.xyz/post/leetcode-dynamic-programming/">
        </link>
        <updated>2024-11-30T08:09:41.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode刷题记录（动态规划篇），个人向。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode刷题记录（动态规划篇），个人向。</p>
<!-- more -->
<h2 id="70-climbing-stairs">[70] Climbing Stairs</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/climbing-stairs/description/">题目描述</a>。<br>
第<code>i</code>层可以从<code>i - 1</code>层跳一步或者从<code>i - 2</code>层跳两步，所以有<code>dp[i] = dp[i - 1] + dp[i - 2];</code>。<br>
注意我们这里不关心<code>dp[0]</code>是多少。因为按照定义，应该有<code>dp[0] = 0</code>，但是又应该要<code>dp[0] = 1</code>才能递归正确。实际上这道题<code>n</code>是大于等于1的，所以<code>dp[0]</code>也正好没有意义。我们直接初始化<code>dp[1]</code>和<code>dp[2]</code>，然后从<code>dp[3]</code>开始计算即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    int climbStairs(int n) {
        if (n &lt;= 1) {
            return n;
        }
        vector&lt;int&gt; dp(n + 1);
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i &lt; n + 1; ++i) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
};
</code></pre>
<h2 id="118-pascals-triangle">[118] Pascal's Triangle</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/pascals-triangle/description/">题目描述</a>。<br>
就按照杨辉三角形（英文这边叫Pascal’s Triangle）定义一行一行算即可，类似动态规划已经把状态转移方程告诉你，直接填表就行了，无思考难度。<br>
我们先把每一行的最左右两边填上1（<code>result[i][0] = result[i][i] = 1;</code>），然后再依次填中间的，省去了边界特殊情况判断的麻烦。</p>
<pre><code class="language-c++">class Solution {
  public:
    vector&lt;vector&lt;int&gt;&gt; generate(int numRows) {
        vector&lt;vector&lt;int&gt;&gt; result(numRows);
        for (int i = 0; i &lt; numRows; ++i) {
            result[i].resize(i + 1);
            result[i][0] = result[i][i] = 1;
            for (int j = 1; j &lt; i; ++j) {
                result[i][j] = result[i - 1][j - 1] + result[i - 1][j];
            }
        }
        return result;
    }
};
</code></pre>
<h2 id="198-house-robber">[198] House Robber</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/house-robber/description/">题目描述</a>。<br>
比较基础的动态规划，代码照着写就完事。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>2</mn><mo>]</mo><mo>+</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i] = \max (dp[i-2] + nums[i], dp[i -1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>1</mn><mo>]</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[0] = nums[0], dp[1] = \max (nums[0], nums[1])</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    int rob(vector&lt;int&gt; &amp;nums) {
        int n = nums.size();
        if (n == 1) {
            return nums[0];
        }
        vector&lt;int&gt; dp(n);
        dp[0] = nums[0];
        dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i &lt; n; ++i) {
            dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
        }
        return dp[n - 1];
    }
};
</code></pre>
<h2 id="279-perfect-squares">[279] Perfect Squares</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/perfect-squares/description/">题目描述</a>。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><msup><mi>j</mi><mn>2</mn></msup><mo>]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>j</mi><mo>∗</mo><mi>j</mi><mo>&lt;</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">dp[i] = \min (dp[i - j^2] + 1, dp[i]), \forall j * j &lt;= i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.064108em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141079999999999em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[0] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ul>
<p>代码照着写就完事。</p>
<pre><code class="language-c++">class Solution {
  public:
    int numSquares(int n) {
        vector&lt;int&gt; dp(n + 1, __INT_MAX__);
        dp[0] = 0;
        for (int i = 1; i &lt;= n; ++i) {
            for (int j = 1; j * j &lt;= i; ++j) {
                dp[i] = min(dp[i - j * j] + 1, dp[i]);
            }
        }
        return dp[n];
    }
};
</code></pre>
<h2 id="322-coin-change">[322] Coin Change</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/coin-change/description/">题目描述</a>。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mi>c</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>c</mi><mo>&lt;</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">dp[i] = \min (dp[i - c] + 1, dp[i]), \forall c &lt;= i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">c</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">c</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathdefault">i</span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">dp[0] = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></li>
</ul>
<p>就上题的状态转移方程稍微改一丢丢，一类题，没什么区别。<br>
需要注意的是若无解需要返回<code>-1</code>，所以需要额外注意一下<code>dp</code>值为<code>__INT_MAX__</code>的情况。</p>
<pre><code class="language-c++">class Solution {
  public:
    int coinChange(vector&lt;int&gt; &amp;coins, int amount) {
        vector&lt;int&gt; dp(amount + 1, __INT_MAX__);
        dp[0] = 0;
        for (int i = 1; i &lt;= amount; ++i) {
            for (int c : coins) {
                if (c &lt;= i &amp;&amp; dp[i - c] != __INT_MAX__) {
                    dp[i] = min(dp[i - c] + 1, dp[i]);
                }
            }
        }
        return dp[amount] == __INT_MAX__ ? -1 : dp[amount];
    }
};
</code></pre>
<h2 id="139-word-break">[139] Word Break</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/word-break/description/">题目描述</a>。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>∧</mo><mo>(</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>:</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>∈</mo><mi>w</mi><mi>o</mi><mi>r</mi><mi>d</mi><mi>D</mi><mi>i</mi><mi>c</mi><mi>t</mi><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>j</mi><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i] = dp[j] \wedge (s[j:i-1]\in wordDict), \forall j\in [0, i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.74285em;vertical-align:-0.08333em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02691em;">w</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">d</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">c</span><span class="mord mathdefault">t</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi></mrow><annotation encoding="application/x-tex">dp[0] = true</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.61508em;vertical-align:0em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span></span></span></span><br>
代码照着写就行。取子串用<code>substr</code>，然后查找用<code>find</code>。<br>
注意这里<code>i</code>表示的是考虑的字符串的长度，而<code>j</code>是<code>suffix</code>的起始位置。<br>
此外这里把<code>!dp[i]</code>条件放入了内层<code>for</code>循环条件判断，一方面该判断的存在可提前结束循环，减少计算，另一方面写法又精简了代码。</li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    bool wordBreak(string s, vector&lt;string&gt; &amp;wordDict) {
        int n = s.size();
        vector&lt;bool&gt; dp(n + 1, false);
        dp[0] = true;
        for (int i = 1; i &lt;= n; ++i) {
            for (int j = 0; j &lt; i &amp;&amp; !dp[i]; ++j) {
                string suffix = s.substr(j, i - j);
                dp[i] = dp[j] &amp;&amp; find(wordDict.begin(), wordDict.end(),
                                      suffix) != wordDict.end();
            }
        }
        return dp[n];
    }
};
</code></pre>
<h2 id="300-longest-increasing-subsequence">[300] Longest Increasing Subsequence</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/longest-increasing-subsequence/description/">题目描述</a>。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>&gt;</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i] = \max (dp[j] + 1, dp[i]), \forall nums[i] &gt; nums[j]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>i</mi><mo>∈</mo><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>n</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[i] = 1, \forall i\in [0, n-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>代码照着写就行。<br>
此外，注意题目要返回的是<strong>最长</strong>递增子序列的长度，因此要返回的不是<code>dp[n-1]</code>，而是需要记录一下值最大的那个<code>dp[i]</code>，然后返回该值。<br>
最后，这道题还有<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mi>l</mi><mi>o</mi><mi>g</mi><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(nlogn)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mord mathdefault">o</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>时间复杂度的解法，可参考<a href="https://leetcode.cn/problems/longest-increasing-subsequence/solutions/147667/zui-chang-shang-sheng-zi-xu-lie-by-leetcode-soluti/">这篇solution</a>。但本人这里主要关注动态规划，因此这种解法不做研究。</p>
<pre><code class="language-c++">class Solution {
  public:
    int lengthOfLIS(vector&lt;int&gt; &amp;nums) {
        int n = nums.size();
        int ret = 1;
        vector&lt;int&gt; dp(n, 1);
        for (int i = 1; i &lt; n; ++i) {
            for (int j = 0; j &lt; i; ++j) {
                if (nums[i] &gt; nums[j]) {
                    dp[i] = max(dp[j] + 1, dp[i]);
                }
            }
            ret = max(ret, dp[i]);
        }
        return ret;
    }
};
</code></pre>
<h2 id="152-maximum-product-subarray">[152] Maximum Product Subarray</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/maximum-product-subarray/description/">题目描述</a>。<br>
因为“负负得正”情况的存在，我们需要同时记录和考虑最小值和最大值。<br>
这里我们使用<code>dpMin[i]</code>表示以<code>nums[i]</code>结尾的乘积最小子数组的乘积，使用<code>dpMax[i]</code>表示以<code>nums[i]</code>结尾的乘积最大子数组的乘积。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mi>M</mi><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>min</mi><mo>⁡</mo><mo>(</mo><mrow><mi>d</mi><mi>p</mi><mi>M</mi><mi>i</mi><mi>n</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>∗</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo separator="true">,</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo></mrow><mo>)</mo></mrow><annotation encoding="application/x-tex">dpMin[i] = \min ({dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i], nums[i]})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">min</span><span class="mopen">(</span><span class="mord"><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span></span><span class="mclose">)</span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mi>M</mi><mi>i</mi><mi>n</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mi>M</mi><mi>a</mi><mi>x</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mn>0</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">dpMin[0] = nums[0], dpMax[0] = nums[0]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="mord mathdefault">a</span><span class="mord mathdefault">x</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span></span></span></span></li>
</ul>
<p>最后返回<code>dpMax</code>中最大的那一个即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    int maxProduct(vector&lt;int&gt; &amp;nums) {
        int n = nums.size();
        vector&lt;int&gt; dpMin(n);
        vector&lt;int&gt; dpMax(n);
        dpMin[0] = nums[0];
        dpMax[0] = nums[0];
        int ret = nums[0];
        for (int i = 1; i &lt; n; ++i) {
            dpMin[i] =
                min({dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i], nums[i]});
            dpMax[i] =
                max({dpMin[i - 1] * nums[i], dpMax[i - 1] * nums[i], nums[i]});
            ret = max(ret, dpMax[i]);
        }
        return ret;
    }
};
</code></pre>
<h2 id="416-partition-equal-subset-sum">[416] Partition Equal Subset Sum</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/partition-equal-subset-sum/description/">题目描述</a>。<br>
把<code>halfSum</code>看做背包容量，<code>num</code>同时看做物品重量与价值，这道题便是0-1背包问题。<br>
0-1背包问题可使用二维动态规划求解，可参考<a href="https://leetcode.cn/problems/partition-equal-subset-sum/solutions/442320/fen-ge-deng-he-zi-ji-by-leetcode-solution/">这篇solution</a>。但实际上，每一行的<code>dp</code>值只与上一行的<code>dp</code>值相关，因此在这里我们使用滚动数组的方式，将空间复杂度降到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>t</mi><mi>a</mi><mi>r</mi><mi>g</mi><mi>e</mi><mi>t</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(target)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault">e</span><span class="mord mathdefault">t</span><span class="mclose">)</span></span></span></span>。<br>
需要注意的是，第二层的循环我们需要从大到小计算，因为如果我们从小到大更新 <code>dp</code> 值，那么在计算 <code>dp[j]</code> 值的时候，<code>dp[j−nums[i]]</code> 已经是被更新过的状态，不再是上一行的 <code>dp</code> 值。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>∣</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>j</mi><mi mathvariant="normal">−</mi><mi>n</mi><mi>u</mi><mi>m</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>]</mo></mrow><annotation encoding="application/x-tex">dp[j]=dp[j] ∣ dp[j−nums[i]]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">∣</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mord">−</span><span class="mord mathdefault">n</span><span class="mord mathdefault">u</span><span class="mord mathdefault">m</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mclose">]</span></span></span></span></li>
<li>初始状态<code>dp[0] = true</code></li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    bool canPartition(vector&lt;int&gt; &amp;nums) {
        int halfSum = 0;
        int n = nums.size();
        for (int num : nums) {
            halfSum += num;
        }
        if (halfSum % 2 == 1) {
            return false;
        }
        halfSum /= 2;

        vector&lt;bool&gt; dp(halfSum + 1);
        dp[0] = true;
        for (int num : nums) {
            for (int i = halfSum; i &gt;= num; --i) {
                dp[i] = dp[i] || dp[i - num];
            }
        }
        return dp[halfSum];
    }
};
</code></pre>
<h2 id="32-longest-valid-parentheses">[32] Longest Valid Parentheses</h2>
<blockquote>
<p>难度：Hard<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/longest-valid-parentheses/description/">题目描述</a>。<br>
这道题标的是Hard难度，但实际上比想象简单很多，即只要把状态转移方程写出来即可。<br>
我们使用<code>dp[i]</code>表示以<code>s[i]</code>结尾的最长有效括号长度。如果<code>s[i]</code>是<code>'('</code>，那么<code>dp[i]</code>只能是0，因此我们只需要考虑<code>s[i]</code>为<code>')'</code>的情况。<br>
对于<code>s[i]</code>为<code>')'</code>的情况，我们需要找到<code>s[i]</code>前面紧挨着的（即以<code>s[i-1]</code>结尾的）最长有效括号长度，然后再看前面的这个最长有效序列的上一个字符是不是<code>'('</code>，如果是，则长度要加上新的这对括号即<code>+2</code>。最后我们还要拼上更早的有效序列长度，即<code>dp[i−dp[i−1]−2]</code>。<br>
简单来说，对于有效括号序列<code>&quot;...(...)&quot;</code>，两个括号对应<code>+2</code>，括号里的<code>...</code>对应<code>dp[i-1]</code>，最早的<code>...</code>对应<code>dp[i−dp[i−1]−2]</code>，因此有<code>dp[i] = dp[i−1]+dp[i−dp[i−1]−2]+2</code>。<br>
<a href="https://leetcode.cn/problems/longest-valid-parentheses/solutions/314683/zui-chang-you-xiao-gua-hao-by-leetcode-solution/">官方题解</a>把字符串分为了“……()”和“……))”两种情况讨论。但实际上，这两种情况完全可以合并为一种。如果是“……()”的情况，那么<code>dp[i−1]</code>就是0，<code>dp[i−dp[i−1]−2]</code>就是<code>dp[i-2]</code>，因此<code>dp[i−1]+dp[i−dp[i−1]−2]+2</code>就等价于<code>dp[i−2]+2</code>。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mi mathvariant="normal">−</mi><mn>1</mn><mo>]</mo><mi mathvariant="normal">−</mi><mn>2</mn><mo>]</mo><mo>+</mo><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup><msup><mo>)</mo><mo mathvariant="normal">′</mo></msup><mo>∧</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>−</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><msup><mo>=</mo><mo mathvariant="normal">′</mo></msup><msup><mo>(</mo><mo mathvariant="normal">′</mo></msup></mrow><annotation encoding="application/x-tex">dp[i] = dp[i−1]+dp[i−dp[i−1]−2]+2, \forall s[i] == &#x27;)&#x27; \wedge s[i - dp[i - 1] - 1] == &#x27;(&#x27;</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mord">−</span><span class="mord">1</span><span class="mclose">]</span><span class="mord">−</span><span class="mord">2</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mclose"><span class="mclose">)</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.751892em;vertical-align:0em;"></span><span class="mrel"><span class="mrel">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.001892em;vertical-align:-0.25em;"></span><span class="mopen"><span class="mopen">(</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.751892em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>i</mi></mrow><annotation encoding="application/x-tex">dp[i] = 0, \forall i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">i</span></span></span></span></li>
</ul>
<p>加上一些边界条件的判断，便得到如下代码。</p>
<pre><code class="language-c++">class Solution {
  public:
    int longestValidParentheses(string s) {
        int n = s.size();
        if (n &lt; 2) {
            return 0;
        }
        vector&lt;int&gt; dp(n, 0); // Defaults to 0
        int maxLength = dp[0];
        for (int i = 1; i &lt; n; ++i) {
            int leftIndex = i - dp[i - 1] - 1;
            if (s[i] == ')' &amp;&amp; leftIndex &gt;= 0 &amp;&amp; s[leftIndex] == '(') {
                dp[i] = dp[i - 1] + 2 + (leftIndex &gt; 0 ? dp[leftIndex - 1] : 0);
                maxLength = max(maxLength, dp[i]);
            }
        }
        return maxLength;
    }
};
</code></pre>
<h2 id="62-unique-paths">[62] Unique Paths</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/unique-paths/description/">题目描述</a>。<br>
非常简单基础的多维动态规划。简单的递推公式，简单的实现。<br>
这里直接在初始化的时候就把所有值初始化为1，避免了后续对第一行和第一列的冗余初始化。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i - 1][j] + dp[i][j - 1], \forall 1 \le i &lt; m, 1 \le j &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>m</mi><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[0][j] = 1, dp[i][0] = 1, \forall 0 \le i &lt; m, 0 \le j &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    int uniquePaths(int m, int n) {
        vector&lt;vector&lt;int&gt;&gt; dp(m, vector&lt;int&gt;(n, 1));

        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }

        return dp[m - 1][n - 1];
    }
};
</code></pre>
<h2 id="64-minimum-path-sum">[64] Minimum Path Sum</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/minimum-path-sum/description/">题目描述</a>。<br>
和上一题一样实际属于简单题。简单的递推公式，简单的实现。</p>
<ul>
<li>状态转移方程
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[0][i] += dp[0][i-1], \forall 1 \le i &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>+</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[i][0] += dp[i - 1][0], \forall 1 \le i &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>+</mo><mo>=</mo><mi>m</mi><mi>i</mi><mi>n</mi><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[i][j] += min(dp[i - 1][j], dp[i][j - 1]), \forall 1 \le i &lt; m, 1 \le j &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mord">+</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">m</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
</ul>
</li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>g</mi><mi>r</mi><mi>i</mi><mi>d</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>m</mi><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[i][j] = grid[i][j], \forall 0 \le i &lt; m, 0 \le j &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.03588em;">g</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">i</span><span class="mord mathdefault">d</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    int minPathSum(vector&lt;vector&lt;int&gt;&gt; &amp;grid) {
        int m = grid.size();
        int n = grid[0].size();
        vector&lt;vector&lt;int&gt;&gt; dp(grid);

        for (int i = 1; i &lt; n; ++i) {
            dp[0][i] += dp[0][i - 1];
        }
        for (int i = 1; i &lt; m; ++i) {
            dp[i][0] += dp[i - 1][0];
        }

        for (int i = 1; i &lt; m; ++i) {
            for (int j = 1; j &lt; n; ++j) {
                dp[i][j] += min(dp[i - 1][j], dp[i][j - 1]);
            }
        }

        return dp[m - 1][n - 1];
    }
};
</code></pre>
<h2 id="5-longest-palindromic-substring">[5] Longest Palindromic Substring</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/longest-palindromic-substring/description/">题目描述</a>。<br>
主要难点在于填表的顺序该怎么规定怎么写。由于<code>dp[i][j]</code>需要用到<code>dp[i+1][j-1]</code>，这里我们用子串长度<code>l</code>作为外层循环变量，子串起点<code>i</code>作为内层循环变量，从短的子串最后填表到长的子串，以满足填表的顺序要求。</p>
<ul>
<li>状态转移方程<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mo>(</mo><mi>s</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mo>=</mo><mi>s</mi><mo>[</mo><mi>j</mi><mo>]</mo><mo>∧</mo><mo>(</mo><mi>l</mi><mo>&gt;</mo><mn>2</mn><mo>?</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>+</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>:</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo>)</mo><mo>)</mo></mrow><annotation encoding="application/x-tex">dp[i][j] = (s[i] == s[j] \wedge (l &gt; 2 ? dp[i + 1][j - 1] : true))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">s</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∧</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">?</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">:</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span></li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>i</mi><mo>]</mo><mo>=</mo><mi>t</mi><mi>r</mi><mi>u</mi><mi>e</mi><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>0</mn><mo>≤</mo><mi>i</mi><mo>&lt;</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[i][i] = true, \forall 0 \le i &lt; n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault" style="margin-right:0.02778em;">r</span><span class="mord mathdefault">u</span><span class="mord mathdefault">e</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69862em;vertical-align:-0.0391em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    string longestPalindrome(string s) {
        int n = s.size();
        int startIndex = 0, length = 1;
        vector&lt;vector&lt;bool&gt;&gt; dp(n, vector&lt;bool&gt;(n, true));
        for (int l = 2; l &lt;= n; ++l) {
            for (int i = 0; i + l - 1 &lt; n; ++i) {
                int j = i + l - 1;
                dp[i][j] = s[i] == s[j] &amp;&amp; (l &gt; 2 ? dp[i + 1][j - 1] : true);
                if (dp[i][j] &amp;&amp; l &gt; length) {
                    startIndex = i;
                    length = l;
                }
            }
        }
        return s.substr(startIndex, length);
    }
};
</code></pre>
<h2 id="1143-longest-common-subsequence">[1143] Longest Common Subsequence</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/longest-common-subsequence/description/">题目描述</a>。<br>
如果<code>text1</code>和<code>text2</code>的当前字符一样，则最长公共子序列的长度为<code>dp[i-1][j-1]</code>加上1即当前匹配的字符，否则把之前的最长公共子序列即<code>max(dp[i-1][j], dp[i][j-1])</code>传递过来。<br>
为了实现方便，这里<code>dp[i][j]</code>表示的是<code>text1</code>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[0, i-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这部分子串和<code>text2</code>的<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mn>0</mn><mo separator="true">,</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow><annotation encoding="application/x-tex">[0, j-1]</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span>这部分子串的最长公共子序列，即当我们要填<code>dp[i][j]</code>时，我们要对比的是<code>text1[i-1]</code>和<code>text2[j-1]</code>而不是<code>text1[i]</code>和<code>text2[j]</code>。我们让这样一来，我们可以直接初始化<code>dp</code>整个表格为<code>0</code>（主要目的是为了直接初始化第一行和第一列为0），省去了专门的初始化步骤，也省去了填表时对于第一行第一列的特殊判断。</p>
<ul>
<li>状态转移方程
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mn>1</mn><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>=</mo><mo>=</mo><mi>t</mi><mi>e</mi><mi>x</mi><mi>t</mi><mn>2</mn><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[i][j] = dp[i-1][j-1] + 1, \forall text1[i-1] == text2[j-1], 1 \le i \le m, 1 \le j \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord">1</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">t</span><span class="mord mathdefault">e</span><span class="mord mathdefault">x</span><span class="mord mathdefault">t</span><span class="mord">2</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mi>max</mi><mo>⁡</mo><mo>(</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>)</mo><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>1</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi><mo separator="true">,</mo><mn>1</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[i][j] = \max (dp[i-1][j], dp[i][j-1]), \forall 1 \le i \le m, 1 \le j \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">max</span><span class="mopen">(</span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mclose">)</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
</ul>
</li>
<li>初始状态<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mn>0</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mn>0</mn><mo>]</mo><mo>=</mo><mn>0</mn><mo separator="true">,</mo><mi mathvariant="normal">∀</mi><mn>0</mn><mo>≤</mo><mi>i</mi><mo>≤</mo><mi>m</mi><mo separator="true">,</mo><mn>0</mn><mo>≤</mo><mi>j</mi><mo>≤</mo><mi>n</mi></mrow><annotation encoding="application/x-tex">dp[0][j] = 0, dp[i][0] = 0, \forall 0 \le i \le m, 0 \le j \le n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord">0</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">∀</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.79549em;vertical-align:-0.13597em;"></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord mathdefault">m</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≤</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">n</span></span></span></span></li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    int longestCommonSubsequence(string text1, string text2) {
        int m = text1.size();
        int n = text2.size();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
        for (int i = 1; i &lt; m + 1; ++i) {
            for (int j = 1; j &lt; n + 1; ++j) {
                if (text1[i - 1] == text2[j - 1]) {
                    dp[i][j] = dp[i - 1][j - 1] + 1;
                } else {
                    dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]);
                }
            }
        }
        return dp[m][n];
    }
};
</code></pre>
<h2 id="72-edit-distance">[72] Edit Distance</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/edit-distance/description/">题目描述</a>。<br>
经典的编辑距离问题，本科生和研究生的算法课都讲过一次的内容。<br>
在该题目中，替换和增加删除的成本都是1。如果不是1，公式也只需要稍加修改即可。</p>
<ul>
<li>状态转移方程</li>
</ul>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo><mo>=</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>j</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>i</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mi>i</mi></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mtext>if </mtext><mi>j</mi><mo>=</mo><mn>0</mn></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mi>min</mi><mo>⁡</mo><mrow><mo fence="true">{</mo><mtable><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><msub><mi>α</mi><mrow><msub><mi>x</mi><mi>i</mi></msub><msub><mi>y</mi><mi>j</mi></msub></mrow></msub><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo>]</mo><mo>[</mo><mi>j</mi><mo>]</mo></mrow></mstyle></mtd></mtr><mtr><mtd><mstyle scriptlevel="0" displaystyle="false"><mrow><mn>1</mn><mo>+</mo><mi>d</mi><mi>p</mi><mo>[</mo><mi>i</mi><mo>]</mo><mo>[</mo><mi>j</mi><mo>−</mo><mn>1</mn><mo>]</mo></mrow></mstyle></mtd></mtr></mtable></mrow></mrow></mstyle></mtd><mtd><mstyle scriptlevel="0" displaystyle="false"><mtext>otherwise</mtext></mstyle></mtd></mtr></mtable></mrow></mrow><annotation encoding="application/x-tex">dp[i][j] =
\begin{cases} 
j &amp; \text{if } i = 0 \\
i &amp; \text{if } j = 0 \\
\min \begin{cases}
\alpha_{x_i y_j} + dp[i-1][j-1] \\
1 + dp[i-1][j] \\
1 + dp[i][j-1]
\end{cases} &amp; \text{otherwise}
\end{cases}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:7.2000399999999996em;vertical-align:-3.3500199999999998em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8500199999999998em;"><span style="top:-0.6999900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-0.6999900000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-0.9999899999999999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.29999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.59999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-1.89999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.90001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.200010000000001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.50001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-5.80001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-6.100019999999999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.3500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8499999999999996em;"><span style="top:-7.252000000000001em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05724em;">j</span></span></span><span style="top:-5.812em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord mathdefault">i</span></span></span><span style="top:-2.9699999999999998em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mop">min</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen"><span class="delimsizing mult"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.35002em;"><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎩</span></span></span><span style="top:-2.19999em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-3.1500100000000004em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎨</span></span></span><span style="top:-4.30001em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎪</span></span></span><span style="top:-4.60002em;"><span class="pstrut" style="height:3.15em;"></span><span class="delimsizinginner delim-size4"><span>⎧</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.8500199999999998em;"><span></span></span></span></span></span></span><span class="mord"><span class="mtable"><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:2.41em;"><span style="top:-4.41em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord"><span class="mord mathdefault" style="margin-right:0.0037em;">α</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.15139200000000003em;"><span style="top:-2.5500000000000003em;margin-left:-0.0037em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathdefault mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span><span class="mord mtight"><span class="mord mathdefault mtight" style="margin-right:0.03588em;">y</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:-0.03588em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathdefault mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2818857142857143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.34731999999999996em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span><span style="top:-2.97em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mclose">]</span></span></span><span style="top:-1.5300000000000002em;"><span class="pstrut" style="height:3.008em;"></span><span class="mord"><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault">d</span><span class="mord mathdefault">p</span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mclose">]</span><span class="mopen">[</span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">]</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.9099999999999997em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span><span class="arraycolsep" style="width:1em;"></span><span class="col-align-l"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:3.8499999999999996em;"><span style="top:-7.252000000000001em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-5.812em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord text"><span class="mord">if </span></span><span class="mord mathdefault" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mord">0</span></span></span><span style="top:-2.9699999999999998em;"><span class="pstrut" style="height:4.41em;"></span><span class="mord"><span class="mord text"><span class="mord">otherwise</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:3.35em;"><span></span></span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>最后得出代码如下。</p>
<pre><code class="language-c++">class Solution {
  public:
    int minDistance(string word1, string word2) {
        int m = word1.size();
        int n = word2.size();
        vector&lt;vector&lt;int&gt;&gt; dp(m + 1, vector&lt;int&gt;(n + 1, 0));
        for (int i = 0; i &lt; m + 1; ++i) {
            dp[i][0] = i;
        }
        for (int j = 0; j &lt; n + 1; ++j) {
            dp[0][j] = j;
        }

        for (int i = 1; i &lt; m + 1; ++i) {
            for (int j = 1; j &lt; n + 1; ++j) {
                dp[i][j] = min(dp[i - 1][j - 1] +
                                   (word1[i - 1] == word2[j - 1] ? 0 : 1),
                               min(dp[i - 1][j], dp[i][j - 1]) + 1);
            }
        }

        return dp[m][n];
    }
};
</code></pre>
<h2 id="总结">总结</h2>
<p>动态规划总体来说是比较容易的内容，没有哪道题卡了很久，也基本都是类似的套路。<br>
无论是一维还是多维动态规划，都有以下类似的步骤：</p>
<ul>
<li>思考dp表格的含义，定义出dp表格</li>
<li>思考出状态转移方程</li>
<li>通过状态转移方程，得出填表顺序</li>
<li>通过填表顺序，得出哪些状态应该是初始状态，并对初始状态做初始化</li>
<li>按填表顺序和状态转移方程填表</li>
<li>根据题目定义找到所需的返回结果并返回</li>
</ul>
<p>基本每道题都按如上套路即可，因此没太多讨论意义。只需要注意一下在<a href="#416-partition-equal-subset-sum">[416] Partition Equal Subset Sum</a>中我们使用滚动数组的方式（本质是利用了填表顺序的特性，即下一行最多只依赖上一行的内容），将原本的二维动态规划压缩到了一维的空间复杂度。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题记录（贪心算法篇）]]></title>
        <id>https://alleny.xyz/post/leetcode-greedy/</id>
        <link href="https://alleny.xyz/post/leetcode-greedy/">
        </link>
        <updated>2024-11-23T08:58:48.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode刷题记录（贪心算法篇），个人向。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode刷题记录（贪心算法篇），个人向。</p>
<!-- more -->
<h2 id="121-best-time-to-buy-and-sell-stock">[121] Best Time to Buy and Sell Stock</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/">题目描述</a>。<br>
遍历一遍数组即可。其中记录一下历史价格最低值，然后查看当前价格减去历史最低值（即当前利润）是否大于最大利润即可，最后返回最大利润。</p>
<pre><code class="language-c++">class Solution {
  public:
    int maxProfit(vector&lt;int&gt; &amp;prices) {
        int max_profit = 0;
        int buy = prices[0];

        for (int p : prices) {
            if (p &lt;= buy) {
                buy = p;
            } else if (p - buy &gt; max_profit) {
                max_profit = p - buy;
            }
        }

        return max_profit;
    }
};
</code></pre>
<h2 id="55-jump-game">[55] Jump Game</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/jump-game/description/">题目描述</a>。<br>
这道题只要想清楚，我们不需要关心<strong>怎么</strong>从起点跳到终点，只需要知道<strong>能不能</strong>跳到终点，这道题就变得很简单。<br>
我们可以在遍历数组的同时更新能跳到的位置的覆盖范围（覆盖到了，就说明能跳到这里，怎么跳的不关心），最后看覆盖的范围有没有到最后一个位置即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    bool canJump(vector&lt;int&gt; &amp;nums) {
        int curPos = 0;
        int maxJump = 0;
        int dest = nums.size() - 1;
        while (maxJump &lt; dest &amp;&amp; curPos &lt;= maxJump) {
            maxJump = max(maxJump, curPos + nums[curPos]);
            curPos += 1;
        }
        return maxJump &gt;= dest;
    }
};
</code></pre>
<h2 id="45-jump-game-ii">[45] Jump Game II</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/jump-game-ii/description/">题目描述</a>。<br>
相比上一题，这题需要记录步数。<br>
我们依然不用关注是如何跳到终点的，即不需要关注具体路径。<br>
相比上一题，我们需要分别记录一下当前<code>step</code>能到达的最远距离<code>curMaxPos</code>和下一<code>step</code>能到达的最远距离<code>nextMaxPos</code>，然后在<code>curPos</code>到达<code>curMaxPos</code>时说明当前<code>step</code>已经走完，<code>nextMaxPos</code>已经更新完毕，此时更新一下<code>step</code>和<code>curMaxPos</code>，开始下一轮迭代。<br>
注意<code>for</code>循环判断条件为<code>curMaxPos &lt; dest</code>而不是<code>nextMaxPos &lt; dest</code>，否则最终<code>step</code>可能会少一。</p>
<pre><code class="language-c++">class Solution {
  public:
    int jump(vector&lt;int&gt; &amp;nums) {
        int step = 0;
        int curMaxPos = 0;
        int nextMaxPos = 0;
        int dest = nums.size() - 1;

        for (int curPos = 0; curMaxPos &lt; dest; ++curPos) {
            nextMaxPos = max(nextMaxPos, curPos + nums[curPos]);
            if (curPos == curMaxPos) {
                step += 1;
                curMaxPos = nextMaxPos;
            }
        }

        return step;
    }
};
</code></pre>
<h2 id="763-partition-labels">[763] Partition Labels</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/partition-labels/description/">题目描述</a>。<br>
和贪心好像没多大关系。<br>
先遍历一遍字符串，统计各个字符的最远出现位置。<br>
然后，第二次遍历字符串，遍历同时记录一下遍历到的字符的最远出现下标（<code>end = max(end, map[s[i] - 'a']);</code>）。当遍历到达记录的遍历过字符的最远出现下标了，就说明当前片段遍历结束，记录一下结果（<code>end - start + 1</code>），然后开始下一片段（<code>start = end + 1;</code>）。</p>
<pre><code class="language-c++">class Solution {
  public:
    vector&lt;int&gt; partitionLabels(string s) {
        int length = s.size();
        int map[26] = {0};
        int start = 0, end = 0;
        vector&lt;int&gt; result;
        for (int i = 0; i &lt; length; ++i) {
            map[s[i] - 'a'] = i;
        }

        for (int i = 0; i &lt; length; ++i) {
            end = max(end, map[s[i] - 'a']);
            if (i == end) {
                result.push_back(end - start + 1);
                start = end + 1;
            }
        }

        return result;
    }
};
</code></pre>
<h2 id="总结">总结</h2>
<p>贪心的本质是选择每一阶段的局部最优，从而达到全局最优。</p>
<ul>
<li>对于<a href="#121-best-time-to-buy-and-sell-stock">121</a>来说，我们计算当前的最大利润，最后得到整体的最大利润。</li>
<li>对于<a href="#55-jump-game">55</a>来说，我们计算当前能够跳到的最大范围，最后得到整体能跳到的最大范围，再看是否覆盖了终点位置。</li>
<li>对于<a href="#45-jump-game-ii">45</a>来说，我们根据上一<code>step</code>能跳到的最大距离来计算当前<code>step</code>能跳到的最大距离，最后返回跳到终点时（即整体）的<code>step</code>数。</li>
<li><a href="#763-partition-labels">763</a>和贪心关系不大。硬要说的话，我们通过统计当前遍历过字符的最远出现位置，最后得到当前片段整体的终止位置。</li>
</ul>
<h2 id="补充">补充</h2>
<h3 id="53-maximum-subarray">[53] Maximum Subarray</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/maximum-subarray/description/">题目描述</a>。<br>
当当前子数组和为负值，则立即抛弃当前累加过的值，直接以下一个数字为新的起点。过程中记录最大子数组和即可。<br>
这道题也可用动态规划的思想，参考<code>maxSubArrayDP</code>。但动态规划需要<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mi>n</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">O(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathdefault">n</span><span class="mclose">)</span></span></span></span>的空间复杂度，所以还不如贪心了。这里动态规划中<code>dp[i]</code>也只与<code>dp[i-1]</code>相关，所以我们也可以把贪心的方式理解成是给动态规划的方法做了空间上的优化得到。</p>
<pre><code class="language-c++">class Solution {
  public:
    int maxSubArray(vector&lt;int&gt; &amp;nums) {
        int result = nums[0];
        int count = 0;

        for (const int &amp;num : nums) {
            count += num;
            result = max(result, count);
            count = max(count, 0);
        }

        return result;
    }

    int maxSubArrayDP(vector&lt;int&gt; &amp;nums) {
        int n = nums.size();
        vector&lt;int&gt; dp(n);
        dp[0] = nums[0];
        int result = nums[0];
        for (int i = 1; i &lt; n; ++i) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]);
            result = max(result, dp[i]);
        }
        return result;
    }
};
</code></pre>
<h3 id="56-merge-intervals">[56] Merge Intervals</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/merge-intervals/description/">题目描述</a>。<br>
先按照起点排序，然后看当前终点是否超过<code>intervals[i+1]</code>的起点。若不超过，说明两个区间没有重叠，压一下结果并更新一下起点。过程中不断更新终点。</p>
<pre><code class="language-c++">class Solution {
  public:
    vector&lt;vector&lt;int&gt;&gt; merge(vector&lt;vector&lt;int&gt;&gt; &amp;intervals) {
        int n = intervals.size();
        vector&lt;vector&lt;int&gt;&gt; result;
        sort(intervals.begin(), intervals.end(),
             [](const vector&lt;int&gt; &amp;a, const vector&lt;int&gt; &amp;b) {
                 return a[0] &lt; b[0];
             });

        int curStart = intervals[0][0], curEnd = intervals[0][1];
        bool flag = false;
        for (int i = 0; i &lt; n - 1; ++i) {
            if (intervals[i + 1][0] &gt; curEnd) {
                result.push_back({curStart, curEnd});
                curStart = intervals[i + 1][0];
            }
            curEnd = max(curEnd, intervals[i + 1][1]);
        }
        result.push_back({curStart, curEnd});
        return result;
    }
};
</code></pre>
<h3 id="122-best-time-to-buy-and-sell-stock-ii">[122] Best Time to Buy and Sell Stock II</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/description/">题目描述</a>。<br>
把问题分解成判断每一天即<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>[</mo><mi>i</mi><mo>−</mo><mn>1</mn><mo separator="true">,</mo><mi>i</mi><mo>)</mo></mrow><annotation encoding="application/x-tex">[i-1, i)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">[</span><span class="mord mathdefault">i</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathdefault">i</span><span class="mclose">)</span></span></span></span>天的收益，即可使用贪心算法累加收益。</p>
<pre><code class="language-c++">class Solution {
  public:
    int maxProfit(vector&lt;int&gt; &amp;prices) {
        int profit = 0;
        int n = prices.size();
        for (int i = 1; i &lt; n; ++i) {
            profit += max(prices[i] - prices[i - 1], 0);
        }

        return profit;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题记录（二分查找篇）]]></title>
        <id>https://alleny.xyz/post/leetcode-binary-search/</id>
        <link href="https://alleny.xyz/post/leetcode-binary-search/">
        </link>
        <updated>2024-11-12T06:44:09.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode刷题记录（二分查找篇），个人向。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode刷题记录（二分查找篇），个人向。</p>
<!-- more -->
<h2 id="35-search-insert-position">[35] Search Insert Position</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/search-insert-position/description/">题目描述</a>。<br>
基本的二分查找，在此基础上增加了一个寻找插入位置（即使不存在，也应该返回可以插入的位置）。此类题目注意循环不变量即可，例如以下代码坚持了左闭右开<code>[left, right)</code>的写法。</p>
<pre><code class="language-c++">class Solution {
  public:
    int searchInsert(vector&lt;int&gt; &amp;nums, int target) {
        int left = 0;
        int right = nums.size();
        while (left &lt; right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (target &gt; nums[mid]) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }

        return right;
    }
};
</code></pre>
<h2 id="74-search-a-2d-matrix">[74] Search a 2D Matrix</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/search-a-2d-matrix/description/">题目描述</a>。<br>
两次二分查找，没什么好说的。需要注意第一次查找的结果是<code>down - 1</code>。<br>
还有一种解法是把矩阵拉平，即把矩阵的几行拼起来成一行数组，然后直接在数组上做一次二分查找。可参考<a href="https://leetcode.cn/problems/search-a-2d-matrix/solutions/688117/sou-suo-er-wei-ju-zhen-by-leetcode-solut-vxui/">这篇solution</a>。</p>
<pre><code class="language-c++">class Solution {
  public:
    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target) {
        int m = matrix.size();
        int n = matrix[0].size();
        int up = 0;
        int down = m;
        int row = 0;
        while (up &lt; down) {
            row = up + (down - up) / 2; // To avoid overflow
            if (target == matrix[row][0]) {
                return true;
            } else if (target &lt; matrix[row][0]) {
                down = row;
            } else {
                up = row + 1;
            }
        }
        row = down - 1;
        if (row &lt; 0) {
            return false;
        }
        int left = 0;
        int right = n;
        while (left &lt; right) {
            int col = left + (right - left) / 2;
            if (target == matrix[row][col]) {
                return true;
            } else if (target &lt; matrix[row][col]) {
                right = col;
            } else {
                left = col + 1;
            }
        }
        return false;
    }
};
</code></pre>
<h2 id="34-find-first-and-last-position-of-element-in-sorted-array">[34] Find First and Last Position of Element in Sorted Array</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/">题目描述</a>。<br>
先尝试自己写了一种解法。先用二分查找找到<code>target</code>，再在该数字左边（包括该数字）用二分查找找到最左的<code>target</code>（即左边的数字不等于<code>target</code>），同理再找到最右的<code>target</code>，最后返回即可。但该代码太过繁琐冗长。<br>
另一种解法的核心是，通过调整<code>nums[mid] == target</code>时是应该调整左边界还是右边界，来找到<code>target</code>的左边界和右边界，最后返回即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    vector&lt;int&gt; searchRangeDivide(vector&lt;int&gt; &amp;nums, int target) {
        int size = nums.size();
        if (size == 0) {
            return vector&lt;int&gt;(2, -1);
        }
        int left = 0, right = size;
        int mid = 0;
        vector&lt;int&gt; result;
        while (left &lt; right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                break;
            } else if (nums[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        if (nums[mid] != target) {
            result.assign(2, -1);
            return result;
        }

        if (mid == 0 || nums[mid - 1] != target) {
            result.push_back(mid);
        } else {
            int left_left = 0, left_right = mid + 1;
            while (left_left &lt; left_right) {
                int left_mid = left_left + (left_right - left_left) / 2;
                if (nums[left_mid] == target &amp;&amp;
                    (left_mid == 0 || nums[left_mid - 1] != target)) {
                    result.push_back(left_mid);
                    break;
                } else if (nums[left_mid] &gt;= target) {
                    left_right = left_mid;
                } else {
                    left_left = left_mid + 1;
                }
            }
        }

        if (mid == size - 1 || nums[mid + 1] != target) {
            result.push_back(mid);
        } else {
            int right_left = mid, right_right = size;
            while (right_left &lt; right_right) {
                int right_mid = right_left + (right_right - right_left) / 2;
                if (nums[right_mid] == target &amp;&amp;
                    (right_mid == size - 1 || nums[right_mid + 1] != target)) {
                    result.push_back(right_mid);
                    break;
                } else if (nums[right_mid] &lt;= target) {
                    right_left = right_mid + 1;
                } else {
                    right_right = right_mid;
                }
            }
        }

        return result;
    }

    int findTarget(const vector&lt;int&gt; &amp;nums, int target, bool left_flag) {
        int left = 0, right = nums.size();
        int border = -1;
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                border = mid;
                if (left_flag) {
                    right = mid;
                } else {
                    left = mid + 1;
                }
            } else if (nums[mid] &lt; target) {
                left = mid + 1;
            } else {
                right = mid;
            }
        }
        return border;
    }

    vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target) {
        int left = findTarget(nums, target, true);
        int right = findTarget(nums, target, false);
        if (left == -1 || right == -1) {
            return {-1, -1};
        } else if (right &gt;= left) {
            return {left, right};
        } else {
            return {-1, -1};
        }
    }
};
</code></pre>
<h2 id="33-search-in-rotated-sorted-array">[33] Search in Rotated Sorted Array</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/description/">题目描述</a>。<br>
判断<code>first</code>即<code>nums[0]</code>与<code>target</code>和<code>nums[mid]</code>三者之间的大小关系即可。<code>nums[mid] &lt; target</code>的情况下，可能<code>target</code>比<code>first</code>大，即<code>target</code>在左边的递增序列部分，而<code>nums[mid]</code>在右边的序列部分，此时应该调整右指针而不是左指针。同理，<code>target &lt;= nums[mid]</code>的情况也有可能是<code>first ... nums[mid] ... target</code>这样的排列，此时应该调整左指针而不是右指针。<br>
另一种思考方式是，先考虑<code>nums[mid]</code>和<code>first</code>之间的大小关系，从而得知是<code>nums[mid]</code>左边有序还是右边有序，然后根据<code>target</code>是否落在该有序部分来决定是该搜索<code>mid</code>左边还是右边。具体可参考<a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/solutions/220083/sou-suo-xuan-zhuan-pai-xu-shu-zu-by-leetcode-solut/">这篇solution</a>。</p>
<pre><code class="language-c++">class Solution {
  public:
    int search(vector&lt;int&gt; &amp;nums, int target) {
        int left = 0;
        int right = nums.size();
        int first = nums[0];
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            }
            if (nums[mid] &lt; target) {
                if (first &lt;= target &amp;&amp;
                    first &gt;= nums[mid]) { // first ... target ... nums[mid]
                    right = mid;
                } else {
                    left = mid + 1;
                }
            } else {
                if (target &lt; first &amp;&amp;
                    nums[mid] &gt;= first) { // first ... nums[mid] ... target
                    left = mid + 1;
                } else {
                    right = mid;
                }
            }
        }

        return -1;
    }
};
</code></pre>
<h2 id="153-find-minimum-in-rotated-sorted-array">[153] Find Minimum in Rotated Sorted Array</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/find-minimum-in-rotated-sorted-array/description/">题目描述</a>。<br>
判断<code>nums[mid]</code>与右边界元素即<code>nums[right]</code>之间的大小关系。如果<code>nums[mid] &lt; nums[right]</code>，则说明<code>nums[mid]</code>在数组右边递增部分（较小部分），最小值索引在<code>[left, mid]</code>之间，可调整右指针使查找范围靠左；反之则调整左指针使查找范围靠右。由于是闭区间，最终会<code>left == right</code>即区间长度为一，此时返回结果即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    int findMin(vector&lt;int&gt; &amp;nums) {
        int left = 0;
        int right = nums.size() - 1;
        while (left &lt; right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] &lt; nums[right]) {
                right = mid;
            } else {
                left = mid + 1;
            }
        }
        return nums[right];
    }
};
</code></pre>
<h2 id="4-median-of-two-sorted-arrays">[4] Median of Two Sorted Arrays</h2>
<blockquote>
<p>难度：Hard<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/median-of-two-sorted-arrays/description/">题目描述</a>。<br>
较有挑战性的一道题目。即使知道大概的算法，实际实现时也要注意各种边界条件的处理等。</p>
<ul>
<li>
<p>首先，我们假设<code>nums1</code>的长度不长于<code>nums2</code>。如果不满足，就交换一下<code>nums1</code>和<code>nums2</code>即可。</p>
</li>
<li>
<p>我们想找到一个划分，该划分把<code>nums1</code>和<code>nums2</code>各自分为了左右部分，我们可以称其为<code>nums1_left_part</code>, <code>nums1_right_part</code>, <code>nums2_left_part</code>和<code>nums2_right_part</code>。该划分满足：</p>
<ul>
<li>如果总长度<code>m + n</code>为偶数，则划分左部分（即<code>nums1_left_part</code>与<code>nums2_left_part</code>）长度之和与右部分相等；若为奇数，则左部分数量比右部分多1。</li>
<li>左部分的所有元素均不大于右部分的所有元素。</li>
</ul>
<p>当我们找到了这样的一个划分，中位数就是左部分的最大元素和右部分的最小元素的平均值（或者就是左边的最大元素，取决于<code>m + n</code>是否为奇数）。</p>
</li>
<li>
<p>我们可以通过二分查找的方式来找到这个划分的位置。先使用二分查找找到<code>nums1</code>中的划分位置<code>i</code>，然后以此作为自变量，把<code>nums2</code>对应的划分位置<code>j</code>作为因变量，通过<code>i + j = (m + n + 1) / 2</code>的方式把<code>j</code>算出来。<code>+1</code>是为了保证左半部分元素的数量大于等于右半部分的数量（如果是偶数，没有影响；如果是奇数，则左边比右边多1）。</p>
</li>
<li>
<p>然后，我们比较划分左右的四个元素，接着比较<code>nums1[i-1]</code>和<code>nums2[j]</code>的大小。若满足<code>nums1[i-1] &lt;= nums2[j]</code>，则记录此时左边最大值和右边最小值，然后更新左指针（尝试从<code>nums1</code>的更右边去划分）；否则，更新右指针（说明<code>nums1</code>划分得太靠右了，需要往左划分来减小<code>nums1[i-1]</code>的值同时增大<code>nums2[j]</code>的值）。这样，我们会找到一个最大的<code>i</code>使得<code>nums1[i-1] &lt;= nums2[j]</code>，此时也会自动满足<code>nums2[j-1] &lt;= nums1[i]</code>，这是因为<code>i</code>已经是最大的，说明<code>i+1</code>不满足，说明<code>nums1[i]</code> &gt;= <code>nums2[j-1]</code>，就正好是第二个公式。这样一来，我们找到了划分的位置，在保证左右元素数量相等（或左边多一）的同时使左边的所有元素均不大于右边的所有元素。</p>
</li>
<li>
<p>最后，根据<code>m + n</code>是否是偶数，返回左边最大值(<code>median1</code>)与右边最小值(<code>median2</code>)的平均值或直接返回<code>median1</code>即可。</p>
</li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    double findMedianSortedArrays(vector&lt;int&gt; &amp;nums1, vector&lt;int&gt; &amp;nums2) {
        if (nums1.size() &gt; nums2.size()) {
            // to make sure that nums1.size() &lt;= nums2.size()
            return findMedianSortedArrays(nums2, nums1);
        }

        int m = nums1.size();
        int n = nums2.size();
        int left = 0, right = m;
        int median1 = 0, median2 = 0;

        while (left &lt;= right) {
            int i = (left + right) / 2;
            // i + j = (m + n + 1) / 2
            int j = (m + n + 1) / 2 - i;

            int nums_im1 = (i == 0 ? INT_MIN : nums1[i - 1]);
            int nums_i = (i == m ? INT_MAX : nums1[i]);
            int nums_jm1 = (j == 0 ? INT_MIN : nums2[j - 1]);
            int nums_j = (j == n ? INT_MAX : nums2[j]);

            if (nums_im1 &lt;= nums_j) {
                median1 = max(nums_im1, nums_jm1);
                median2 = min(nums_i, nums_j);
                left = i + 1;
            } else {
                right = i - 1;
            }
        }

        return (m + n) % 2 == 0 ? (median1 + median2) / 2.0 : median1;
    }
};
</code></pre>
<h2 id="总结">总结</h2>
<p>定义左边界<code>left</code>和右边界<code>right</code>，然后判断<code>mid</code>与目标<code>target</code>之间的大小关系，以此来更新左边界或者右边界，应该是二分查找类题的基础模版。需要注意的是，需要约定好左边界和右边界分别是开区间还是闭区间，然后在实现时始终遵守这一点。例如本人习惯定义<code>[left, right)</code>，则<code>while</code>循环的条件应该是<code>left &lt; right</code>而不是<code>left &lt;= right</code>。</p>
<p><a href="#33-search-in-rotated-sorted-array">33</a>和<a href="#153-find-minimum-in-rotated-sorted-array">153</a>都涉及到了Rotated Sorted Array。这里可以通过对比<code>mid</code>与array第一个元素或最后一个元素的大小关系来得知<code>mid</code>处于哪一段有序序列中，以此信息来调整<code>left</code>或<code>right</code>。</p>
<p>最后的<a href="#4-median-of-two-sorted-arrays">4</a>是较有难度的题。这里我们先确保<code>nums1.size() &lt;= nums2.size()</code>，然后使用二分查找的方式找到<code>nums1</code>中的划分位置<code>i</code>，并以此为自变量计算出<code>nums2</code>中的划分位置出<code>j</code>。我们通过比较划分左右四个元素的大小关系（实际只需要比较两个即<code>nums1[i-1]</code>和<code>nums2[j]</code>)来更新左或右指针，直到找到最大的<code>i</code>使得<code>nums1[i-1] &lt;= nums2[j]</code>，此时直接计算出中位数即可（<code>(median1 + median2) / 2.0</code>或<code>median1</code>）。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题记录（回溯篇）]]></title>
        <id>https://alleny.xyz/post/leetcode-backtracking/</id>
        <link href="https://alleny.xyz/post/leetcode-backtracking/">
        </link>
        <updated>2024-10-31T05:29:50.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode刷题记录（回溯篇），个人向。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode刷题记录（回溯篇），个人向。</p>
<!-- more -->
<h2 id="46-permutations">[46] Permutations</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/permutations/description/">题目描述</a>。<br>
使用<code>used</code>来记录当前已使用的元素，尝试增加<code>used</code>，递归调用，记录<code>path</code>，在<code>path</code>长度达到<code>nums.size()</code>时将结果记录到<code>result</code>即可。</p>
<pre><code class="language-c++">class Solution {
public:
  void backtracking(vector&lt;int&gt; &amp;nums, vector&lt;bool&gt; &amp;used, vector&lt;int&gt; &amp;path,
                    vector&lt;vector&lt;int&gt;&gt; &amp;result) {
    int size = nums.size();

    if (path.size() == size) {
      result.push_back(path);
      return;
    }

    for (int i = 0; i &lt; size; ++i) {
      if (used[i]) {
        continue;
      }
      used[i] = true;
      path.push_back(nums[i]);
      backtracking(nums, used, path, result);
      path.pop_back();
      used[i] = false;
    }
    return;
  }
  vector&lt;vector&lt;int&gt;&gt; permute(vector&lt;int&gt; &amp;nums) {
    vector&lt;bool&gt; used(nums.size(), false);
    vector&lt;int&gt; path;
    vector&lt;vector&lt;int&gt;&gt; result;
    backtracking(nums, used, path, result);
    return result;
  }
};
</code></pre>
<h2 id="78-subsets">[78] Subsets</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/subsets/description/">题目描述</a>。<br>
相比上一题求全排列，这一题的不同点有二：</p>
<ul>
<li>我们要求的是子集，单个集合不要求包含所有元素，因此在这棵递归树上，我们要求的不止是叶子节点，而是所有节点。因此不是在递归结束的时候记录结果，而是每次调用都记录一下结果。</li>
<li>相比全排列，集合对元素的顺序不再做要求。因此相比之前使用<code>used</code>数组，这里可以只记录<code>startIndex</code>，然后每次递归从<code>startIndex</code>往后遍历，来做到包含不同的元素组合。</li>
</ul>
<pre><code class="language-c++">class Solution {
  public:
    void backtracking(vector&lt;int&gt; &amp;nums, int startIndex, vector&lt;int&gt; &amp;path,
                      vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        int size = nums.size();
        result.push_back(path);
        for (int i = startIndex; i &lt; size; ++i) {
            path.push_back(nums[i]);
            backtracking(nums, i + 1, path, result);
            path.pop_back();
        }
    }

    vector&lt;vector&lt;int&gt;&gt; subsets(vector&lt;int&gt; &amp;nums) {
        vector&lt;int&gt; path;
        vector&lt;vector&lt;int&gt;&gt; result;
        backtracking(nums, 0, path, result);
        return result;
    }
};
</code></pre>
<h2 id="17-letter-combinations-of-a-phone-number">[17] Letter Combinations of a Phone Number</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/">题目描述</a>。<br>
构造一个<code>mapping</code>用来存数字到字母的映射，同时用<code>mapping[digits[startIndex] - '2']</code>来取这个映射。回溯部分和之前大同小异，更新一下startIndex，同时记录路径，最后加进<code>result</code>即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    const vector&lt;string&gt; mapping = {&quot;abc&quot;, &quot;def&quot;,  &quot;ghi&quot;, &quot;jkl&quot;,
                                    &quot;mno&quot;, &quot;pqrs&quot;, &quot;tuv&quot;, &quot;wxyz&quot;};

    void backtracking(string &amp;digits, int startIndex, string &amp;path,
                      vector&lt;string&gt; &amp;result) {
        int size = digits.size();
        if (startIndex &gt;= size) {
            if (size &gt; 0) {
                result.push_back(path);
            }
            return;
        }

        string chars = mapping[digits[startIndex] - '2'];
        int numChars = chars.size();

        for (int i = 0; i &lt; numChars; ++i) {
            path.push_back(chars[i]);
            backtracking(digits, startIndex + 1, path, result);
            path.pop_back();
        }
    }

    vector&lt;string&gt; letterCombinations(string digits) {
        vector&lt;string&gt; result;
        string path;
        backtracking(digits, 0, path, result);
        return result;
    }
};
</code></pre>
<h2 id="39-combination-sum">[39] Combination Sum</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/combination-sum/description/">题目描述</a>。<br>
对回溯的代码逐渐熟练，同样是一次写出答案。<br>
和之前的代码大同小异。这里因为<code>candidates[i]</code>是大于0的，所以出现<code>new_sum == target</code>就不用继续递归了。<br>
当我们选择了某个数字，则以后的递归只会考虑该数字以及之后的数字，不再考虑之前的数字，这保证了结果的唯一性（不出现重复组合）。<br>
这道题的关键在于数字是可以重复使用的，这里我们用递归参数所使用的<code>index</code>为<code>i</code>而不是<code>i+1</code>来体现。</p>
<pre><code class="language-c++">class Solution {
  public:
    void backtracking(const vector&lt;int&gt; &amp;candidates, const int target,
                      int index, int cur_sum, vector&lt;int&gt; &amp;choosen,
                      vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        int size = candidates.size();
        if (index &gt;= size) {
            return;
        }

        for (int i = index; i &lt; size; ++i) {
            int new_sum = cur_sum + candidates[i];
            if (new_sum &gt; target) {
                continue;
            }
            choosen.push_back(candidates[i]);
            if (new_sum == target) {
                result.push_back(choosen);
                // 0 will not appear in candidates, and 2 &lt;= candidates[i] &lt;= 40
                // so no need to backtrack further
            } else {
                backtracking(candidates, target, i, new_sum, choosen, result);
            }
            choosen.pop_back();
        }
    }

    vector&lt;vector&lt;int&gt;&gt; combinationSum(vector&lt;int&gt; &amp;candidates, int target) {
        vector&lt;int&gt; choosen;
        vector&lt;vector&lt;int&gt;&gt; result;
        backtracking(candidates, target, 0, 0, choosen, result);
        return result;
    }
};
</code></pre>
<h2 id="22-generate-parentheses">[22] Generate Parentheses</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/generate-parentheses/description/">题目描述</a>。<br>
回溯时同时记录左括号和右括号的剩余数量。若左括号剩余数量大于0则可以添加左括号。若右括号剩余数量大于左括号（防止先右括号后左括号导致无法匹配）则可以添加右括号。</p>
<pre><code class="language-c++">class Solution {
  public:
    void backtracking(int left, int right, string &amp;s, vector&lt;string&gt; &amp;result) {
        if (left == 0 &amp;&amp; right == 0) {
            result.push_back(s);
            return;
        }

        if (left &gt; 0) {
            s.push_back('(');
            backtracking(left - 1, right, s, result);
            s.pop_back();
        }
        if (right &gt; left) {
            s.push_back(')');
            backtracking(left, right - 1, s, result);
            s.pop_back();
        }
    }

    vector&lt;string&gt; generateParenthesis(int n) {
        string s;
        vector&lt;string&gt; result;
        backtracking(n, n, s, result);
        return result;
    }
};
</code></pre>
<h2 id="79-word-search">[79] Word Search</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/word-search/description/">题目描述</a>。<br>
代码有些类似DFS。记录当前坐标<code>x</code>和<code>y</code>以及要匹配的字符的index <code>k</code>。如果当前字符不对则递归终止，否则看<code>k</code>是否已经到<code>word</code>的最后一个了，如果没有就通过DFS的方式去搜索周围四个。</p>
<pre><code class="language-c++">class Solution {
  public:
    vector&lt;pair&lt;int, int&gt;&gt; directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    bool backtracking(const vector&lt;vector&lt;char&gt;&gt; &amp;board, const string &amp;word,
                      int x, int y, int k, vector&lt;vector&lt;bool&gt;&gt; &amp;visited) {
        if (board[x][y] != word[k]) {
            return false;
        } else if (k == word.size() - 1) {
            return true;
        }

        int m = board.size();
        int n = board[0].size();
        visited[x][y] = true;
        for (auto [dx, dy] : directions) {
            int nx = x + dx, ny = y + dy;
            if (nx &lt; 0 || ny &lt; 0 || nx &gt;= m || ny &gt;= n || visited[nx][ny]) {
                continue;
            }
            if (backtracking(board, word, nx, ny, k + 1, visited)) {
                return true;
            }
        }
        visited[x][y] = false;
        return false;
    }

    bool exist(vector&lt;vector&lt;char&gt;&gt; &amp;board, string word) {
        int m = board.size();
        int n = board[0].size();

        vector&lt;vector&lt;bool&gt;&gt; visited(board.size(),
                                     vector&lt;bool&gt;(board[0].size(), false));
        for (int i = 0; i &lt; m; ++i) {
            for (int j = 0; j &lt; n; ++j) {
                if (backtracking(board, word, i, j, 0, visited)) {
                    return true;
                }
            }
        }
        return false;
    }
};
</code></pre>
<h2 id="131-palindrome-partitioning">[131] Palindrome Partitioning</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/palindrome-partitioning/description/">题目描述</a>。<br>
还是回溯题的老套路。记录一下<code>startIndex</code>，然后<code>for</code>循环从<code>startIndex</code>开始找下一个回文子串。若<code>startIndex</code>到<code>i</code>是回文子串，则记录到<code>path</code>，然后从<code>i+1</code>递归即可。<br>
至于判断是否是回文串，这里写了两个版本。一种是常规使用双指针来判断字符串是否是回文串（<code>isPalindrome</code>）；另一种是优化方法，使用了动态规划做预处理，提前算好所有子串是否是回文串（<code>palindromeTable</code>），判断的时候直接查表即可，避免了重复计算。</p>
<pre><code class="language-c++">class Solution {
    vector&lt;vector&lt;bool&gt;&gt; palindromeTable;

    bool isPalindrome(const string &amp;s, int startIndex, int endIndex) {
        while (startIndex &lt;= endIndex) {
            if (s[startIndex] != s[endIndex]) {
                return false;
            }
            ++startIndex;
            --endIndex;
        }
        return true;
    }

    void backtracking(const string &amp;s, int startIndex, vector&lt;string&gt; &amp;path,
                      vector&lt;vector&lt;string&gt;&gt; &amp;result) {
        int size = s.size();
        if (startIndex &gt;= size) {
            result.push_back(path);
            return;
        }

        for (int i = startIndex; i &lt; size; ++i) {
            // if (isPalindrome(s, startIndex, i)) {
            if (palindromeTable[startIndex][i]) {
                path.push_back(s.substr(startIndex, i - startIndex + 1));
                backtracking(s, i + 1, path, result);
                path.pop_back();
            }
        }
    }

  public:
    vector&lt;vector&lt;string&gt;&gt; partition(string s) {
        vector&lt;string&gt; path;
        vector&lt;vector&lt;string&gt;&gt; result;

        int size = s.size();
        palindromeTable.assign(size, vector&lt;bool&gt;(size, true));
        for (int i = size - 1; i &gt;= 0; --i) {
            for (int j = i + 1; j &lt; size; ++j) {
                palindromeTable[i][j] =
                    palindromeTable[i + 1][j - 1] &amp;&amp; s[i] == s[j];
            }
        }

        backtracking(s, 0, path, result);

        return result;
    }
};
</code></pre>
<h2 id="51-n-queens">[51] N-Queens</h2>
<blockquote>
<p>难度：Hard<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/n-queens/description/">题目描述</a>。<br>
大名鼎鼎的N皇后问题。看似暴力穷举的背后又存在许多可剪枝优化的空间。</p>
<ul>
<li>每轮递归无需两个坐标轴双重循环遍历。我们可规定递归的顺序是从最上面一行到最下面一行，每次在一行里面找下一个N皇后的位置。这样一方面保证了顺序（防止出现重复结果），另一方面我们实际只需要一层循环，即遍历这一行的位置，看哪一列可作为N皇后的位置即可。如果找到位置，再递归进入下一行的遍历查找。</li>
<li>检查位置是否合法时，由于我们填N皇后的位置是从上到下（按行）来填的，因此我们只需要检查行坐标小于当前坐标的那些位置即可，可减少检查判断的数量。（要注意皇后除了横着竖着还能斜着走，一开始不了解规则都没注意这个）</li>
</ul>
<p>当我们最后填完了最后一行（<code>n == row</code>），说明每一行我们都已经找到了一个合法的N皇后的位置，将此时的棋盘加入结果即可（<code>result.push_back(board);</code>）。</p>
<pre><code class="language-c++">class Solution {
    bool check(int n, int x, int y, const vector&lt;string&gt; &amp;board) {
        for (int i = 0; i &lt; x; ++i) {
            if (board[i][y] == 'Q') {
                return false;
            }
        }

        const vector&lt;pair&lt;int, int&gt;&gt; direction = {{-1, 1}, {-1, -1}};
        for (int i = 1; i &lt; n; ++i) {
            for (auto [dx, dy] : direction) {
                int nx = x + i * dx;
                int ny = y + i * dy;
                if (nx &lt; 0 || ny &lt; 0 || ny &gt;= n) {
                    continue;
                }
                if (board[nx][ny] == 'Q') {
                    return false;
                }
            }
        }
        return true;
    }

    void backtracking(int n, int row, vector&lt;string&gt; &amp;board,
                      vector&lt;vector&lt;string&gt;&gt; &amp;result) {
        if (n == row) {
            result.push_back(board);
            return;
        }

        for (int j = 0; j &lt; n; ++j) {
            if (check(n, row, j, board)) {
                board[row][j] = 'Q';
                backtracking(n, row + 1, board, result);
                board[row][j] = '.';
            }
        }
    }

  public:
    vector&lt;vector&lt;string&gt;&gt; solveNQueens(int n) {
        vector&lt;string&gt; board(n, string(n, '.'));
        vector&lt;vector&lt;string&gt;&gt; result;

        backtracking(n, 0, board, result);

        return result;
    }
};
</code></pre>
<h2 id="总结">总结</h2>
<p>回溯的题目基本都存在一套函数模版：</p>
<pre><code class="language-c++">void backtracking(parameters) {
    if (termination_condition) {
        store_result;
        return;
    }

    for (choice : elements in the current level's set (the number of children of a tree node is the size of the set)) {
        process_node;
        backtracking(path, choices); // recursive call
        backtrack, undo processing result
    }
}
</code></pre>
<p>这里的几道题目的代码基本都是按着上面的模版来的，无非有一些小修改。除了<a href="#22-generate-parentheses">[22] Generate Parentheses</a>在递归上略为特殊，其记录了剩余左括号和右括号的数量，然后再根据该数量关系来决定如何递归。</p>
<h2 id="补充">补充</h2>
<h3 id="47-permutations-ii">[47] Permutations II</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/permutations-ii/description/">题目描述</a>。<br>
本题为<a href="#46-permutations">[46] Permutations</a>的进阶版本，相比前一道题多了数字可重复的条件，因此要考虑结果去重的问题。本人在字节一面做完上题后随后被追问到了这个进阶版本的题目。<br>
做法应该是先把数组排序，使相同的数字都在一起。然后，我们希望相同一个数字的使用情况一定是从左到右，例如有<code>[1, 2a, 2b, 3]</code>（其中的ab用来标识），我们希望只出现先选<code>2a</code>再选<code>2b</code>，而不会选了<code>2b</code>又选<code>2a</code>的情况出现。因此，我们在原来条件<code>used[i]</code>的基础上，又增加了<code>nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]</code>的判断条件。即，如果上一个数字和当前数字相等，且上一个数字还没选，那么当前数字也不该被选。</p>
<pre><code class="language-c++">class Solution {
    void backtracking(vector&lt;int&gt; &amp;nums, vector&lt;bool&gt; &amp;used, vector&lt;int&gt; &amp;path,
                      vector&lt;vector&lt;int&gt;&gt; &amp;result) {
        int n = nums.size();
        if (path.size() &gt;= n) {
            result.emplace_back(path);
            return;
        }

        for (int i = 0; i &lt; n; ++i) {
            if (used[i] || i &gt; 0 &amp;&amp; nums[i] == nums[i - 1] &amp;&amp; !used[i - 1]) {
                continue;
            }
            used[i] = true;
            path.push_back(nums[i]);
            backtracking(nums, used, path, result);
            path.pop_back();
            used[i] = false;
        }
    }

  public:
    vector&lt;vector&lt;int&gt;&gt; permuteUnique(vector&lt;int&gt; &amp;nums) {
        vector&lt;vector&lt;int&gt;&gt; result;
        vector&lt;int&gt; path;
        vector&lt;bool&gt; used(nums.size(), false);

        sort(nums.begin(), nums.end());

        backtracking(nums, used, path, result);

        return result;
    }
};
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题记录（图论篇）]]></title>
        <id>https://alleny.xyz/post/leetcode-graph/</id>
        <link href="https://alleny.xyz/post/leetcode-graph/">
        </link>
        <updated>2024-10-28T08:58:14.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode刷题记录（图论篇），个人向。<br>
之后为了提高效率，转而以<a href="https://leetcode.cn/studyplan/top-100-liked/">Hot 100</a>作为刷题蓝图。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode刷题记录（图论篇），个人向。<br>
之后为了提高效率，转而以<a href="https://leetcode.cn/studyplan/top-100-liked/">Hot 100</a>作为刷题蓝图。</p>
<!-- more -->
<h2 id="200-number-of-islands">[200] Number of Islands</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/number-of-islands/description/">题目描述</a>。<br>
把<code>1</code>看成节点，上下左右相邻的<code>1</code>之间看成有边，相当于求图有几个连通分量。依次以不同的起点做遍历，查看有几个可开始遍历的起点即可。遍历使用DFS或BFS都可以，这里也同时给出了两种遍历的写法。</p>
<pre><code class="language-c++">class Solution {
 public:
  void dfs(vector&lt;vector&lt;char&gt;&gt;&amp; grid, vector&lt;vector&lt;bool&gt;&gt;&amp; visited, int x,
           int y, const vector&lt;pair&lt;int, int&gt;&gt;&amp; directions) {
    visited[x][y] = true;
    int m = grid.size(), n = grid[0].size();

    for (auto [dx, dy] : directions) {
      int nx = x + dx, ny = y + dy;
      if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; !visited[nx][ny] &amp;&amp;
          grid[nx][ny] == '1') {
        dfs(grid, visited, nx, ny, directions);
      }
    }
  }

  // use DFS
  int numIslands(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
    int m = grid.size(), n = grid[0].size(), result = 0;
    vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));
    vector&lt;pair&lt;int, int&gt;&gt; directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};

    for (int i = 0; i &lt; m; ++i) {
      for (int j = 0; j &lt; n; ++j) {
        if (!visited[i][j] &amp;&amp; grid[i][j] == '1') {
          ++result;
          dfs(grid, visited, i, j, directions);
        }
      }
    }
    return result;
  }

  // use BFS
  int numIslandsBFS(vector&lt;vector&lt;char&gt;&gt;&amp; grid) {
    int m = grid.size(), n = grid[0].size(), result = 0;
    vector&lt;vector&lt;bool&gt;&gt; visited(m, vector&lt;bool&gt;(n, false));
    vector&lt;pair&lt;int, int&gt;&gt; directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    queue&lt;pair&lt;int, int&gt;&gt; q;

    for (int i = 0; i &lt; m; ++i) {
      for (int j = 0; j &lt; n; ++j) {
        if (!visited[i][j] &amp;&amp; grid[i][j] == '1') {
          ++result;
          q.push({i, j});
          visited[i][j] = true;

          while (!q.empty()) {
            auto [x, y] = q.front();
            q.pop();

            for (auto [dx, dy] : directions) {
              int nx = x + dx, ny = y + dy;
              if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; m &amp;&amp; ny &lt; n &amp;&amp; !visited[nx][ny] &amp;&amp;
                  grid[nx][ny] == '1') {
                q.push({nx, ny});
                visited[nx][ny] = true;
              }
            }
          }
        }
      }
    }
    return result;
  }
};
</code></pre>
<h2 id="994-rotting-oranges">[994] Rotting Oranges</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/rotting-oranges/description/">题目描述</a>。<br>
模拟广度优先搜索。需要注意的是，我们为了把每一轮新访问到的节点区分出来，需要先记录一下队列的大小，然后处理该指定数量的元素来作为BFS的一轮（类似于树的层序遍历，为了区分出每一层，队列大小就是该层的节点数量）。</p>
<pre><code class="language-c++">class Solution {
 public:
  int orangesRotting(vector&lt;vector&lt;int&gt;&gt;&amp; grid) {
    int nr = grid.size();
    int nc = grid[0].size();
    vector&lt;pair&lt;int, int&gt;&gt; directions = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};
    int result = 0;
    queue&lt;pair&lt;int, int&gt;&gt; q;
    int count = 0;

    for (int i = 0; i &lt; nr; ++i) {
      for (int j = 0; j &lt; nc; ++j) {
        if (grid[i][j] == 1) {
          count += 1;
        } else if (grid[i][j] == 2) {
          q.push({i, j});
        }
      }
    }

    while (count &gt; 0 &amp;&amp; !q.empty()) {
      ++result;
      int size = q.size();
      for (int i = 0; i &lt; size; ++i) {
        auto [x, y] = q.front();
        q.pop();
        for (auto [dx, dy] : directions) {
          int nx = x + dx, ny = y + dy;
          if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; nr &amp;&amp; ny &lt; nc &amp;&amp; grid[nx][ny] == 1) {
            grid[nx][ny] = 2;
            count -= 1;
            q.push({nx, ny});
          }
        }
      }
    };

    return count ? -1 : result;
  }
};
</code></pre>
<h2 id="207-course-schedule">[207] Course Schedule</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/course-schedule/description/">题目描述</a>。<br>
基本的拓扑排序，只不过从算法变成具体实现的代码需要注意的细节还是比较多。<br>
先把输入<code>prerequisites</code>转成邻接表以及同时统计节点度数，然后把入度为0的点放入队列进行BFS即可（遍历到的节点从图中去掉，取新的入度为0的节点入队）。最后查看是否每个节点都遍历到了（能从图中去掉）即可。<br>
这道题也可使用DFS，可参考<a href="https://leetcode.cn/problems/course-schedule/solutions/359392/ke-cheng-biao-by-leetcode-solution/">这篇solution</a>。</p>
<pre><code class="language-c++">class Solution {
 public:
  bool canFinish(int numCourses, vector&lt;vector&lt;int&gt;&gt;&amp; prerequisites) {
    unordered_map&lt;int, vector&lt;int&gt;&gt; map;
    vector&lt;int&gt; degree(numCourses, 0);
    for (auto edge : prerequisites) {
      map[edge[1]].push_back(edge[0]);
      degree[edge[0]] += 1;
    }

    queue&lt;int&gt; q;
    for (int i = 0; i &lt; numCourses; ++i) {
      if (degree[i] == 0) {
        q.push(i);
      }
    }

    int visited = 0;
    while (!q.empty()) {
      ++visited;
      int cur = q.front();
      q.pop();
      for (auto course : map[cur]) {
        if (--degree[course] == 0) {
          q.push(course);
        }
      }
    }

    return visited == numCourses;
  }
};
</code></pre>
<h2 id="208-implement-trie-prefix-tree">[208] Implement Trie (Prefix Tree)</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/implement-trie-prefix-tree/description/">题目描述</a>。<br>
题目限定了英文小写字符，因此直接指定26个children，以children的index来对应相应的小写字符。此外，使用<code>bool</code>变量<code>isEnd</code>来表示当前<code>node</code>是否可作为单词的结尾。<br>
插入时类似链表，一层一层往下插入，在结尾<code>node</code>标记一下<code>isEnd</code>为<code>true</code>即可。查找时也类似链表查找，需要注意的是<code>search</code>需要最后找到的<code>node</code>刚好是可作为结尾的<code>node</code>（<code>isEnd</code>为<code>true</code>），而<code>startWith</code>只需要找到对应<code>node</code>（说明存在该前缀）即可。</p>
<pre><code class="language-c++">class Trie {
  vector&lt;Trie*&gt; children;
  bool isEnd;

 public:
  Trie() {
    isEnd = false;
    children = vector&lt;Trie*&gt;(26);
  }

  void insert(string word) {
    Trie* node = this;
    for (auto c : word) {
      if (node-&gt;children[c - 'a'] == nullptr) {
        node-&gt;children[c - 'a'] = new Trie();
      }
      node = node-&gt;children[c - 'a'];
    }
    node-&gt;isEnd = true;
  }

  bool search(string word) {
    Trie* node = this;
    for (auto c : word) {
      if (node-&gt;children[c - 'a'] == nullptr) {
        return false;
      }
      node = node-&gt;children[c - 'a'];
    }
    return node-&gt;isEnd;
  }

  bool startsWith(string prefix) {
    Trie* node = this;
    for (auto c : prefix) {
      if (node-&gt;children[c - 'a'] == nullptr) {
        return false;
      }
      node = node-&gt;children[c - 'a'];
    }
    return true;
  }
};
</code></pre>
<h2 id="总结">总结</h2>
<p>由于现在暂时改成按照Hot 100来刷，所以相比之前长篇的二叉树，这里图论只刷了4道。<br>
首先要注意的是图的表示形式，有邻接表和邻接矩阵，但一般来说邻接表用得多一些。（若稠密图，也可使用邻接矩阵）。<br>
图的遍历方式主要是DFS与BFS，一些题目使用两种遍历方式都可（<a href="#200-number-of-islands">200</a>、<a href="#207-course-schedule">207</a>），一些题目则只适合其中一种（<a href="#994-rotting-oranges">994</a>）。<br>
最后的实现前缀树（<a href="#208-implement-trie-prefix-tree">208</a>）则和链表的操作很类似，只不过一个节点同时对应了很多个后继而已。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PowerInfer源码解析（三）：算子实现]]></title>
        <id>https://alleny.xyz/post/powerinfer-source-analysis-3/</id>
        <link href="https://alleny.xyz/post/powerinfer-source-analysis-3/">
        </link>
        <updated>2024-09-29T06:27:35.000Z</updated>
        <summary type="html"><![CDATA[<p>这次我们来解析一下PowerInfer主要所使用到的算子是如何实现的。</p>
]]></summary>
        <content type="html"><![CDATA[<p>这次我们来解析一下PowerInfer主要所使用到的算子是如何实现的。</p>
<!-- more -->
<h2 id="相关">相关</h2>
<ul>
<li><a href="https://alleny.xyz/post/powerinfer-source-analysis-1/">PowerInfer源码解析（一）：模型加载</a>。</li>
<li><a href="https://alleny.xyz/post/powerinfer-source-analysis-2/">PowerInfer源码解析（二）：计算图构建与算子调用 </a>。</li>
</ul>
<h2 id="ggml_compute_forward_mul_mat">ggml_compute_forward_mul_mat</h2>
<p>我们先来看原本矩阵乘所默认使用算子（CPU版本）<code>ggml_compute_forward_mul_mat</code>。</p>
<pre><code class="language-c++">static void ggml_compute_forward_mul_mat(
        const struct ggml_compute_params * params,
        const struct ggml_tensor * src0,
        const struct ggml_tensor * src1,
              struct ggml_tensor * dst) {
    int64_t t0 = ggml_perf_time_us();
    UNUSED(t0);

    GGML_TENSOR_BINARY_OP_LOCALS

    const int ith = params-&gt;ith;
    const int nth = params-&gt;nth;

    const enum ggml_type type = src0-&gt;type;

    const bool src1_cont = ggml_is_contiguous(src1);

    ggml_vec_dot_t    const vec_dot               = type_traits[type].vec_dot;
    enum ggml_type    const vec_dot_type          = type_traits[type].vec_dot_type;
    ggml_from_float_t const from_float_to_vec_dot = type_traits[vec_dot_type].from_float;

    GGML_ASSERT(ne0 == ne01);
    GGML_ASSERT(ne1 == ne11);
    GGML_ASSERT(ne2 == ne12);
    GGML_ASSERT(ne3 == ne13);

    // we don't support permuted src0 or src1
    GGML_ASSERT(nb00 == ggml_type_size(type));
    GGML_ASSERT(nb10 == ggml_type_size(src1-&gt;type));

    // dst cannot be transposed or permuted
    GGML_ASSERT(nb0 == sizeof(float));
    GGML_ASSERT(nb0 &lt;= nb1);
    GGML_ASSERT(nb1 &lt;= nb2);
    GGML_ASSERT(nb2 &lt;= nb3);

    // broadcast factors
    const int64_t r2 = ne12/ne02;
    const int64_t r3 = ne13/ne03;

    // nb01 &gt;= nb00 - src0 is not transposed
    //   compute by src0 rows

#if defined(GGML_USE_CLBLAST)
    if (ggml_cl_can_mul_mat(src0, src1, dst)) {
        if (params-&gt;ith == 0 &amp;&amp; params-&gt;type == GGML_TASK_COMPUTE) {
            ggml_cl_mul_mat(src0, src1, dst, params-&gt;wdata, params-&gt;wsize);
        }
        return;
    }
#endif

#if defined(GGML_USE_ACCELERATE) || defined(GGML_USE_OPENBLAS)
    if (ggml_compute_forward_mul_mat_use_blas(src0, src1, dst)) {
        if (params-&gt;ith != 0) {
            return;
        }

        if (params-&gt;type == GGML_TASK_INIT) {
            return;
        }

        if (params-&gt;type == GGML_TASK_FINALIZE) {
            return;
        }

        for (int64_t i13 = 0; i13 &lt; ne13; i13++) {
            for (int64_t i12 = 0; i12 &lt; ne12; i12++) {
                // broadcast src0 into src1 across 2nd,3rd dimension
                const int64_t i03 = i13/r3;
                const int64_t i02 = i12/r2;

                const void  * x = (char *)            src0-&gt;data + i02*nb02 + i03*nb03;
                const float * y = (float *) ((char *) src1-&gt;data + i12*nb12 + i13*nb13);

                float * d = (float *) ((char *) dst-&gt;data + i12*nb2 + i13*nb3);

                if (type != GGML_TYPE_F32) {
                            float * const wdata    = params-&gt;wdata;
                    ggml_to_float_t const to_float = type_traits[type].to_float;

                    size_t id = 0;
                    for (int64_t i01 = 0; i01 &lt; ne01; ++i01) {
                        to_float((const char *) x + i01*nb01, wdata + id, ne00);
                        id += ne00;
                    }

                    assert(id*sizeof(float) &lt;= params-&gt;wsize);
                    x = wdata;
                }

                cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasTrans,
                        ne11, ne01, ne10,
                        1.0f,    y, ne10,
                                 x, ne00,
                        0.0f,    d, ne01);
            }
        }

        //printf(&quot;CBLAS = %f ms, %d x %d x %d x %d\n&quot;, (ggml_perf_time_us() - t0)/1000.0, ne0, ne1, ne2, ne3);

        return;
    }
#endif

    if (params-&gt;type == GGML_TASK_INIT) {
        if (src1-&gt;type != vec_dot_type) {
            char * wdata = params-&gt;wdata;
            const size_t row_size = ne10*ggml_type_size(vec_dot_type)/ggml_blck_size(vec_dot_type);

            for (int64_t i13 = 0; i13 &lt; ne13; ++i13) {
                for (int64_t i12 = 0; i12 &lt; ne12; ++i12) {
                    for (int64_t i11 = 0; i11 &lt; ne11; ++i11) {
                        from_float_to_vec_dot((float *)((char *) src1-&gt;data + i13*nb13 + i12*nb12 + i11*nb11), (void *) wdata, ne10);
                        wdata += row_size;
                    }
                }
            }
        }

        return;
    }

    if (params-&gt;type == GGML_TASK_FINALIZE) {
        return;
    }

    const void * wdata    = (src1-&gt;type == vec_dot_type) ? src1-&gt;data : params-&gt;wdata;
    const size_t row_size = ne10*ggml_type_size(vec_dot_type)/ggml_blck_size(vec_dot_type);

    const int64_t nr0 = ne01;           // src0 rows
    const int64_t nr1 = ne11*ne12*ne13; // src1 rows

    //printf(&quot;nr0 = %lld, nr1 = %lld\n&quot;, nr0, nr1);

    // distribute the thread work across the inner or outer loop based on which one is larger

    const int64_t nth0 = nr0 &gt; nr1 ? nth : 1; // parallelize by src0 rows
    const int64_t nth1 = nr0 &gt; nr1 ? 1 : nth; // parallelize by src1 rows

    const int64_t ith0 = ith % nth0;
    const int64_t ith1 = ith / nth0;

    const int64_t dr0 = (nr0 + nth0 - 1)/nth0;
    const int64_t dr1 = (nr1 + nth1 - 1)/nth1;

    const int64_t ir010 = dr0*ith0;
    const int64_t ir011 = MIN(ir010 + dr0, nr0);

    const int64_t ir110 = dr1*ith1;
    const int64_t ir111 = MIN(ir110 + dr1, nr1);

    //printf(&quot;ir010 = %6lld, ir011 = %6lld, ir110 = %6lld, ir111 = %6lld\n&quot;, ir010, ir011, ir110, ir111);

    // threads with no work simply yield (not sure if it helps)
    if (ir010 &gt;= ir011 || ir110 &gt;= ir111) {
        sched_yield();
        return;
    }

    assert(ne12 % ne02 == 0);
    assert(ne13 % ne03 == 0);

    // block-tiling attempt
    const int64_t blck_0 = 16;
    const int64_t blck_1 = 16;

    // attempt to reduce false-sharing (does not seem to make a difference)
    float tmp[16];

    for (int64_t iir1 = ir110; iir1 &lt; ir111; iir1 += blck_1) {
        for (int64_t iir0 = ir010; iir0 &lt; ir011; iir0 += blck_0) {
            for (int64_t ir1 = iir1; ir1 &lt; iir1 + blck_1 &amp;&amp; ir1 &lt; ir111; ++ir1) {
                const int64_t i13 = (ir1/(ne12*ne11));
                const int64_t i12 = (ir1 - i13*ne12*ne11)/ne11;
                const int64_t i11 = (ir1 - i13*ne12*ne11 - i12*ne11);

                // broadcast src0 into src1
                const int64_t i03 = i13/r3;
                const int64_t i02 = i12/r2;

                const int64_t i1 = i11;
                const int64_t i2 = i12;
                const int64_t i3 = i13;

                const char * src0_row = (const char *) src0-&gt;data + (0 + i02*nb02 + i03*nb03);

                // desc: when src1 is not a contiguous memory block we have to calculate the offset using the strides
                //       if it is, then we have either copied the data to params-&gt;wdata and made it contiguous or we are using
                //       the original src1 data pointer, so we should index using the indices directly
                // TODO: this is a bit of a hack, we should probably have a better way to handle this
                const char * src1_col = (const char *) wdata +
                    (src1_cont || src1-&gt;type != vec_dot_type
                     ? (i11      + i12*ne11 + i13*ne12*ne11)*row_size
                     : (i11*nb11 + i12*nb12 + i13*nb13));

                float * dst_col = (float *) ((char *) dst-&gt;data + (i1*nb1 + i2*nb2 + i3*nb3));

                //for (int64_t ir0 = iir0; ir0 &lt; iir0 + blck_0 &amp;&amp; ir0 &lt; ir011; ++ir0) {
                //    vec_dot(ne00, &amp;dst_col[ir0], src0_row + ir0*nb01, src1_col);
                //}

                for (int64_t ir0 = iir0; ir0 &lt; iir0 + blck_0 &amp;&amp; ir0 &lt; ir011; ++ir0) {
                    vec_dot(ne00, &amp;tmp[ir0 - iir0], src0_row + ir0*nb01, src1_col);
                }
                memcpy(&amp;dst_col[iir0], tmp, (MIN(iir0 + blck_0, ir011) - iir0)*sizeof(float));
            }
        }
    }
}
</code></pre>
<p>这一开头就来个<code>GGML_TENSOR_BINARY_OP_LOCALS</code>是什么东西？<code>ne0</code>，<code>ne01</code>等等这些变量又是哪里来的？一开始看到这里一定一头雾水。<br>
我们追根溯源，看看宏定义到底做了什么。</p>
<pre><code class="language-c++">// in ggml.h
#define GGML_TENSOR_LOCALS_1(type, prefix, pointer, array) \
    const type prefix##0 = (pointer)-&gt;array[0]; \
    GGML_UNUSED(prefix##0);
#define GGML_TENSOR_LOCALS_2(type, prefix, pointer, array) \
    GGML_TENSOR_LOCALS_1    (type, prefix, pointer, array) \
    const type prefix##1 = (pointer)-&gt;array[1]; \
    GGML_UNUSED(prefix##1);
#define GGML_TENSOR_LOCALS_3(type, prefix, pointer, array) \
    GGML_TENSOR_LOCALS_2    (type, prefix, pointer, array) \
    const type prefix##2 = (pointer)-&gt;array[2]; \
    GGML_UNUSED(prefix##2);
#define GGML_TENSOR_LOCALS(type, prefix, pointer, array) \
    GGML_TENSOR_LOCALS_3  (type, prefix, pointer, array) \
    const type prefix##3 = (pointer)-&gt;array[3]; \
    GGML_UNUSED(prefix##3);
</code></pre>
<pre><code class="language-c++">// in ggml.c
#define GGML_TENSOR_BINARY_OP_LOCALS \
    GGML_TENSOR_LOCALS(int64_t, ne0, src0, ne) \
    GGML_TENSOR_LOCALS(size_t,  nb0, src0, nb) \
    GGML_TENSOR_LOCALS(int64_t, ne1, src1, ne) \
    GGML_TENSOR_LOCALS(size_t,  nb1, src1, nb) \
    GGML_TENSOR_LOCALS(int64_t, ne,  dst,  ne) \
    GGML_TENSOR_LOCALS(size_t,  nb,  dst,  nb)
</code></pre>
<p>原来，这里是负责定义了一堆局部变量。<br>
<code>GGML_TENSOR_LOCALS_1(type, prefix, pointer, array)</code>负责定义<code>prefix##0</code>局部变量来存储<code>(pointer)-&gt;array[0]</code>的值。<br>
注意这里的<code>##</code>的作用是将两个标记拼接成一个新的标记。在宏定义中，这个特性可以用来动态生成标识符，以简化代码和提高代码的灵活性。<code>prefix##0</code> 使用了<code>##</code>，其目的是将 <code>prefix</code> 和 <code>0</code> 拼接成一个新的标记。假设<code>prefix</code>是<code>ne</code>，那么<code>prefix##0</code>就会变成<code>ne0</code>，这是一个合法的标识符。函数里面所使用的那些新的局部变量（的变量名）就是这么来的。<br>
从<code>GGML_TENSOR_LOCALS</code>调用到<code>GGML_TENSOR_LOCALS_3</code>再到<code>GGML_TENSOR_LOCALS_2</code>再到<code>GGML_TENSOR_LOCALS_1</code>，<code>prefix##0</code>到<code>prefix##3</code>依次被<code>(pointer)-&gt;array[0]</code>到<code>(pointer)-&gt;array[3]</code>赋值初始化。<br>
<code>GGML_TENSOR_BINARY_OP_LOCALS</code>则针对<code>src0</code>，<code>src1</code>和<code>dst</code>的<code>ne</code>和<code>nb</code>分别使用了<code>GGML_TENSOR_LOCALS</code>，就有了我们在函数中看到的那一堆局部变量了。<br>
之后，检查是否可以使用 OpenCL 加速（CLBLAST）或 BLAS 库（OpenBLAS/Accelerate）。如果可以，则调用相应的矩阵乘法函数加速计算。</p>
<pre><code class="language-c++">#if defined(GGML_USE_CLBLAST)
    if (ggml_cl_can_mul_mat(src0, src1, dst)) {
        if (params-&gt;ith == 0 &amp;&amp; params-&gt;type == GGML_TASK_COMPUTE) {
            ggml_cl_mul_mat(src0, src1, dst, params-&gt;wdata, params-&gt;wsize);
        }
        return;
    }
#endif

#if defined(GGML_USE_ACCELERATE) || defined(GGML_USE_OPENBLAS)
    if (ggml_compute_forward_mul_mat_use_blas(src0, src1, dst)) {
        if (params-&gt;ith != 0) {
            return;
        }

        if (params-&gt;type == GGML_TASK_INIT) {
            return;
        }

        if (params-&gt;type == GGML_TASK_FINALIZE) {
            return;
        }

        for (int64_t i13 = 0; i13 &lt; ne13; i13++) {
            for (int64_t i12 = 0; i12 &lt; ne12; i12++) {
                // broadcast src0 into src1 across 2nd,3rd dimension
                const int64_t i03 = i13/r3;
                const int64_t i02 = i12/r2;

                const void  * x = (char *)            src0-&gt;data + i02*nb02 + i03*nb03;
                const float * y = (float *) ((char *) src1-&gt;data + i12*nb12 + i13*nb13);

                float * d = (float *) ((char *) dst-&gt;data + i12*nb2 + i13*nb3);

                if (type != GGML_TYPE_F32) {
                            float * const wdata    = params-&gt;wdata;
                    ggml_to_float_t const to_float = type_traits[type].to_float;

                    size_t id = 0;
                    for (int64_t i01 = 0; i01 &lt; ne01; ++i01) {
                        to_float((const char *) x + i01*nb01, wdata + id, ne00);
                        id += ne00;
                    }

                    assert(id*sizeof(float) &lt;= params-&gt;wsize);
                    x = wdata;
                }

                cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasTrans,
                        ne11, ne01, ne10,
                        1.0f,    y, ne10,
                                 x, ne00,
                        0.0f,    d, ne01);
            }
        }

        //printf(&quot;CBLAS = %f ms, %d x %d x %d x %d\n&quot;, (ggml_perf_time_us() - t0)/1000.0, ne0, ne1, ne2, ne3);

        return;
    }
#endif
</code></pre>
<ul>
<li>GGML_TASK_INIT：初始化阶段，用来将 src1 中的 float 类型数据转换为适合进行矩阵乘法的类型（vec_dot_type），并将其存储在一个临时缓冲区 wdata 中，以便之后的计算使用。</li>
<li>GGML_TASK_FINALIZE：结束阶段，什么也不做，只是标记计算结束。</li>
</ul>
<pre><code class="language-c++">    if (params-&gt;type == GGML_TASK_INIT) {
        if (src1-&gt;type != vec_dot_type) {
            char * wdata = params-&gt;wdata;
            const size_t row_size = ne10*ggml_type_size(vec_dot_type)/ggml_blck_size(vec_dot_type);

            for (int64_t i13 = 0; i13 &lt; ne13; ++i13) {
                for (int64_t i12 = 0; i12 &lt; ne12; ++i12) {
                    for (int64_t i11 = 0; i11 &lt; ne11; ++i11) {
                        from_float_to_vec_dot((float *)((char *) src1-&gt;data + i13*nb13 + i12*nb12 + i11*nb11), (void *) wdata, ne10);
                        wdata += row_size;
                    }
                }
            }
        }

        return;
    }
</code></pre>
<p>后面这部分代码主要是任务的分配。<br>
（<code>nth0</code>和<code>nth1</code>）先是看一下<code>src0</code>和<code>src1</code>谁的行数多（<code>nr0</code>和<code>nr1</code>），谁多就按谁来并行。<br>
（<code>ith0</code>和<code>ith1</code>）然后，计算当前线程应该处理<code>src0</code>和<code>src</code>的哪部分。<br>
我们可以这样理解这个公式：假设<code>nth</code>是4，</p>
<ul>
<li>如果<code>nth0</code>是4，那么<code>ith0</code>就是<code>[0, 3]</code>也就是处理四个不同的部分，<code>ith1</code>则只能是0</li>
<li>如果<code>nth0</code>是1，那么<code>ith0</code>只能是0，而<code>ith1</code>可以是<code>[0, 3]</code>。</li>
</ul>
<p>（<code>dr0</code>和<code>dr1</code>）然后，计算每个线程应该分别处理多少行<code>src0</code>和<code>src1</code>。这里就是用总行数对<code>nth0</code>和<code>nth1</code>做商的向上取整。<br>
（<code>ir010</code>和<code>ir011</code>）有了负责的部分（<code>ith0</code>）以及每个部分的行数<code>dr0</code>，我们就可以计算线程对<code>src0</code>的处理范围了，即处理<code>src0</code>的起始行（<code>dr0*ith0</code>）和终止行（<code>MIN(ir010 + dr0, nr0)</code>）。<br>
（<code>ir110</code>和<code>ir111</code>）同上，线程处理 <code>src1</code> 的起始行和结束行。</p>
<pre><code class="language-c++">    const void * wdata    = (src1-&gt;type == vec_dot_type) ? src1-&gt;data : params-&gt;wdata;
    const size_t row_size = ne10*ggml_type_size(vec_dot_type)/ggml_blck_size(vec_dot_type);

    const int64_t nr0 = ne01;           // src0 rows
    const int64_t nr1 = ne11*ne12*ne13; // src1 rows

    //printf(&quot;nr0 = %lld, nr1 = %lld\n&quot;, nr0, nr1);

    // distribute the thread work across the inner or outer loop based on which one is larger

    const int64_t nth0 = nr0 &gt; nr1 ? nth : 1; // parallelize by src0 rows
    const int64_t nth1 = nr0 &gt; nr1 ? 1 : nth; // parallelize by src1 rows

    const int64_t ith0 = ith % nth0;
    const int64_t ith1 = ith / nth0;

    const int64_t dr0 = (nr0 + nth0 - 1)/nth0;
    const int64_t dr1 = (nr1 + nth1 - 1)/nth1;

    const int64_t ir010 = dr0*ith0;
    const int64_t ir011 = MIN(ir010 + dr0, nr0);

    const int64_t ir110 = dr1*ith1;
    const int64_t ir111 = MIN(ir110 + dr1, nr1);
</code></pre>
<p>接下来是计算。首先是一个矩阵的分块。外两层循环每次加<code>blck_0</code>和<code>blck_1</code>，然后内两层循环处理该block内的数据。其中第三层循环增加<code>src1</code>的一列，第四层循环增加<code>src0</code>的一行。第四层循环算完会得到结果的一列（通过<code>src1</code>的一列和block内<code>src0</code>的所有行），再把结果<code>memcpy</code>到<code>dst_col</code>。</p>
<pre><code class="language-c++">    // block-tiling attempt
    const int64_t blck_0 = 16;
    const int64_t blck_1 = 16;

    // attempt to reduce false-sharing (does not seem to make a difference)
    float tmp[16];

    for (int64_t iir1 = ir110; iir1 &lt; ir111; iir1 += blck_1) {
        for (int64_t iir0 = ir010; iir0 &lt; ir011; iir0 += blck_0) {
            for (int64_t ir1 = iir1; ir1 &lt; iir1 + blck_1 &amp;&amp; ir1 &lt; ir111; ++ir1) {
                // -- snip --
                for (int64_t ir0 = iir0; ir0 &lt; iir0 + blck_0 &amp;&amp; ir0 &lt; ir011; ++ir0) {
                    vec_dot(ne00, &amp;tmp[ir0 - iir0], src0_row + ir0*nb01, src1_col);
                }
                memcpy(&amp;dst_col[iir0], tmp, (MIN(iir0 + blck_0, ir011) - iir0)*sizeof(float));
            }
        }
    }
</code></pre>
<p>第三层循环内的开头是一个一维索引到三维索引的重新计算。我们可以这样理解这个公式：</p>
<ul>
<li>ir1在三维张量中首先跨过了多少“深度”（<code>ne12 * ne11</code>表示一个完整的平面大小）。所以这步是在第 2 维度上跨过多少个完整的<code>ne11 x ne12</code>大小的平面。</li>
<li>在确定<code>i13</code>之后，减去i13对应的展平索引所跨过的部分，剩下的就是在<code>ne11 * ne12</code>这个平面中的位置。接下来，用这个剩余部分除以<code>ne11</code>，得到<code>i12</code>，即在第 1 维度上的索引。</li>
<li>最后，减去<code>i13</code>和<code>i12</code>跨过的部分，剩下的就是在第 0 维度上的索引<code>i11</code>。它表示当前<code>ir1</code>在这个平面中，具体的第 0 维度上的位置。</li>
</ul>
<pre><code class="language-c++">                const int64_t i13 = (ir1/(ne12*ne11));
                const int64_t i12 = (ir1 - i13*ne12*ne11)/ne11;
                const int64_t i11 = (ir1 - i13*ne12*ne11 - i12*ne11);
</code></pre>
<p>通过 r2 和 r3 将 src0 的较小维度广播到 src1，以适应后者较大的维度。具体地说，i03 和 i02 通过除以广播因子将 src1 的索引转换为 src0 的索引，以正确地在较大的张量上应用较小张量的值。<br>
例如，如果 i13 = 4，r3 = 3，则 i03 = 4 / 3 = 1，表示 src0 的第 3 维的第 1 个元素会被应用于 src1 的第 4 个位置。</p>
<pre><code class="language-c++">                // broadcast src0 into src1
                const int64_t i03 = i13/r3;
                const int64_t i02 = i12/r2;
</code></pre>
<p>针对 src1 的多维索引（例如 i11, i12, i13）直接映射到 dst 中的对应维度位置。这表明在 dst 中的元素将与 src1 的这些维度一一对应。</p>
<pre><code class="language-c++">                const int64_t i1 = i11;
                const int64_t i2 = i12;
                const int64_t i3 = i13;
</code></pre>
<p>计算<code>src0</code>的行起始位置（block中的第一行）。</p>
<pre><code class="language-c++">                const char * src0_row = (const char *) src0-&gt;data + (0 + i02*nb02 + i03*nb03);
</code></pre>
<p>计算<code>src1_col</code>和<code>dst_col</code>的位置。这里如果<code>src1</code>是连续的则使用<code>ne</code>和<code>row_size</code>来计算，否则使用<code>nb</code>来计算（<strong>为什么？</strong>）。</p>
<pre><code class="language-c++">                const char * src1_col = (const char *) wdata +
                    (src1_cont || src1-&gt;type != vec_dot_type
                     ? (i11      + i12*ne11 + i13*ne12*ne11)*row_size
                     : (i11*nb11 + i12*nb12 + i13*nb13));

                float * dst_col = (float *) ((char *) dst-&gt;data + (i1*nb1 + i2*nb2 + i3*nb3));
</code></pre>
<p>最后，算出结果中的一列。这里依次把block里面<code>src0</code>的各行与<code>src1</code>的对应列做向量点乘，把结果放到<code>tmp</code>中，再把<code>tmp</code>的结果放到<code>dst_col</code>即对应列中。</p>
<pre><code class="language-c++">                for (int64_t ir0 = iir0; ir0 &lt; iir0 + blck_0 &amp;&amp; ir0 &lt; ir011; ++ir0) {
                    vec_dot(ne00, &amp;tmp[ir0 - iir0], src0_row + ir0*nb01, src1_col);
                }
                memcpy(&amp;dst_col[iir0], tmp, (MIN(iir0 + blck_0, ir011) - iir0)*sizeof(float));
</code></pre>
<p>这样一来，<code>ggml.c</code>中的<code>ggml_compute_forward_mul_mat</code>就结束了。</p>
<h2 id="ggml_cuda_mul_mat">ggml_cuda_mul_mat</h2>
<p>对于<code>GGML_USE_CUBLAS</code>为<code>True</code>的情况，<code>GGML_OP_MUL_MAT</code>会调用到<code>ggml_cuda_mul_mat</code>。<br>
<code>ggml_cuda_mul_mat</code>会通过检查输入张量的类型、内存布局、计算能力等条件，来选择最适合的矩阵乘法计算方法。</p>
<pre><code class="language-c++">static void ggml_cuda_mul_mat(const ggml_tensor * src0, const ggml_tensor * src1, ggml_tensor * dst) {
    const bool all_on_device =
        (src0-&gt;backend == GGML_BACKEND_GPU || src0-&gt;backend == GGML_BACKEND_GPU_SPLIT) &amp;&amp;
        (src1-&gt;backend == GGML_BACKEND_GPU) &amp;&amp;
        ( dst-&gt;backend == GGML_BACKEND_GPU);

    const bool split = src0-&gt;backend == GGML_BACKEND_GPU_SPLIT;

    int64_t min_compute_capability = INT_MAX;
    for (int64_t id = 0; id &lt; g_device_count; ++id) {
        if (min_compute_capability &gt; g_compute_capabilities[id] &amp;&amp; g_tensor_split[id] &lt; (id + 1 &lt; g_device_count ? g_tensor_split[id + 1] : 1.0f)) {
            min_compute_capability = g_compute_capabilities[id];
        }
    }

#ifdef CUDA_USE_TENSOR_CORES
    const bool use_tensor_cores = true;
#else
    const bool use_tensor_cores = false;
#endif

    // debug helpers
    //printf(&quot;src0: %8d %8d %8d %8d\n&quot;, src0-&gt;ne[0], src0-&gt;ne[1], src0-&gt;ne[2], src0-&gt;ne[3]);
    //printf(&quot;      %8d %8d %8d %8d\n&quot;, src0-&gt;nb[0], src0-&gt;nb[1], src0-&gt;nb[2], src0-&gt;nb[3]);
    //printf(&quot;src1: %8d %8d %8d %8d\n&quot;, src1-&gt;ne[0], src1-&gt;ne[1], src1-&gt;ne[2], src1-&gt;ne[3]);
    //printf(&quot;      %8d %8d %8d %8d\n&quot;, src1-&gt;nb[0], src1-&gt;nb[1], src1-&gt;nb[2], src1-&gt;nb[3]);
    //printf(&quot;src0 is contiguous %d, transposed %d, type = %s, name = %s\n&quot;, ggml_is_contiguous(src0), ggml_is_transposed(src0), ggml_type_name(src0-&gt;type), src0-&gt;name);
    //printf(&quot;src1 is contiguous %d, transposed %d, type = %s, name = %s\n&quot;, ggml_is_contiguous(src1), ggml_is_transposed(src1), ggml_type_name(src1-&gt;type), src1-&gt;name);

    if (!split &amp;&amp; all_on_device &amp;&amp; !use_tensor_cores &amp;&amp; src0-&gt;type == GGML_TYPE_F16 &amp;&amp; ggml_is_permuted(src0) &amp;&amp; ggml_is_permuted(src1) &amp;&amp; src1-&gt;ne[1] == 1) {
        // KQ single-batch
        ggml_cuda_mul_mat_vec_p021(src0, src1, dst);
    } else if (!split &amp;&amp; all_on_device &amp;&amp; !use_tensor_cores &amp;&amp; src0-&gt;type == GGML_TYPE_F16 &amp;&amp; !ggml_is_contiguous(src0) &amp;&amp; !ggml_is_transposed(src1) &amp;&amp; src1-&gt;ne[1] == 1) {
        // KQV single-batch
        ggml_cuda_mul_mat_vec_nc(src0, src1, dst);
    } else if (!split &amp;&amp; all_on_device &amp;&amp; use_tensor_cores &amp;&amp; src0-&gt;type == GGML_TYPE_F16 &amp;&amp; src1-&gt;type == GGML_TYPE_F32 &amp;&amp; !ggml_is_transposed(src0) &amp;&amp; !ggml_is_transposed(src1)) {
        // KQ + KQV multi-batch
        ggml_cuda_mul_mat_mat_batched_cublas(src0, src1, dst);
    } else if (src0-&gt;type == GGML_TYPE_F32) {
        ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_cublas, false);
    } else if (ggml_is_quantized(src0-&gt;type) || src0-&gt;type == GGML_TYPE_F16) {
        if (src1-&gt;ne[1] == 1 &amp;&amp; src0-&gt;ne[0] % GGML_CUDA_DMMV_X == 0) {
#ifdef GGML_CUDA_FORCE_DMMV
            const bool use_mul_mat_vec_q = false;
#else
            const bool use_mul_mat_vec_q = min_compute_capability &gt;= MIN_CC_DP4A &amp;&amp; ggml_is_quantized(src0-&gt;type);
#endif // GGML_CUDA_FORCE_DMMV

            if (use_mul_mat_vec_q) {
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_vec_q, true);
            } else {
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_dequantize_mul_mat_vec, false);
            }
        } else {
            bool use_mul_mat_q = min_compute_capability &gt;= MIN_CC_DP4A &amp;&amp; ggml_is_quantized(src0-&gt;type);

            // when tensor cores are available, use them for large batch size
            // ref: https://github.com/ggerganov/llama.cpp/pull/3776
            if (use_tensor_cores &amp;&amp; min_compute_capability &gt;= CC_VOLTA &amp;&amp; src1-&gt;ne[1] &gt; MMQ_MAX_BATCH_SIZE) {
                use_mul_mat_q = false;
            }

            if (use_mul_mat_q) {
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_q, true);
            } else {
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_cublas, false);
            }
        }
    } else {
        GGML_ASSERT(false);
    }
}
</code></pre>
<p>对于<code>src0</code>是量化类型，且<code>src1</code>是列向量的情况，代码会根据<a href="https://docs.nvidia.com/cuda/cuda-c-programming-guide/index.html#compute-capabilities">GPU计算能力</a>选择是直接使用量化的矩阵乘法（<code>ggml_cuda_op_mul_mat_vec_q</code>），还是先进行反量化（<code>ggml_cuda_op_dequantize_mul_mat_vec</code>）。</p>
<pre><code class="language-c++">            if (use_mul_mat_vec_q) {
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_vec_q, true);
            } else {
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_dequantize_mul_mat_vec, false);
            }
</code></pre>
<p><code>ggml_cuda_op_mul_mat</code>的函数签名如下。注意这里最后一个参数<code>covert_src1_to_q8_1</code>如果为<code>true</code>，则会尝试调用<code>quantize_q8_1</code>对输入<code>src1</code>进行量化。</p>
<pre><code class="language-c++">static void ggml_cuda_op_mul_mat(
    const ggml_tensor * src0, const ggml_tensor * src1, ggml_tensor * dst, ggml_cuda_op_mul_mat_t op,
    const bool convert_src1_to_q8_1) 
</code></pre>
<h3 id="ggml_cuda_op_dequantize_mul_mat_vec">ggml_cuda_op_dequantize_mul_mat_vec</h3>
<p><code>ggml_cuda_op_dequantize_mul_mat_vec</code>基于量化类型选择合适的函数。</p>
<pre><code class="language-c++">inline void ggml_cuda_op_dequantize_mul_mat_vec(
    const ggml_tensor * src0, const ggml_tensor * src1, ggml_tensor * dst, const char * src0_dd_i, const float * src1_ddf_i,
    const char * src1_ddq_i, float * dst_dd_i, const int64_t row_low, const int64_t row_high, const int64_t src1_ncols,
    const int64_t src1_padded_row_size, const cudaStream_t &amp; stream) {

    const int64_t ne00 = src0-&gt;ne[0];
    const int64_t row_diff = row_high - row_low;

    // on some GPUs it is faster to convert src1 to half and to use half precision intrinsics
#ifdef GGML_CUDA_F16
    size_t ash;
    dfloat * src1_dfloat = nullptr; // dfloat == half

    bool src1_convert_f16 = src0-&gt;type == GGML_TYPE_Q4_0 || src0-&gt;type == GGML_TYPE_Q4_1 ||
        src0-&gt;type == GGML_TYPE_Q5_0 || src0-&gt;type == GGML_TYPE_Q5_1 ||
        src0-&gt;type == GGML_TYPE_Q8_0 || src0-&gt;type == GGML_TYPE_F16;

    if (src1_convert_f16) {
        src1_dfloat = (half *) ggml_cuda_pool_malloc(ne00*sizeof(half), &amp;ash);
        ggml_cpy_f32_f16_cuda((const char *) src1_ddf_i, (char *) src1_dfloat, ne00,
                                ne00, 1, sizeof(float), 0, 0,
                                ne00, 1, sizeof(half),  0, 0, stream);
    }
#else
    const dfloat * src1_dfloat = (const dfloat *) src1_ddf_i; // dfloat == float, no conversion
#endif // GGML_CUDA_F16

    switch (src0-&gt;type) {
        case GGML_TYPE_Q4_0:
            dequantize_mul_mat_vec_q4_0_cuda(src0_dd_i, src1_dfloat, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q4_1:
            dequantize_mul_mat_vec_q4_1_cuda(src0_dd_i, src1_dfloat, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q5_0:
            dequantize_mul_mat_vec_q5_0_cuda(src0_dd_i, src1_dfloat, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q5_1:
            dequantize_mul_mat_vec_q5_1_cuda(src0_dd_i, src1_dfloat, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q8_0:
            dequantize_mul_mat_vec_q8_0_cuda(src0_dd_i, src1_dfloat, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q2_K:
            dequantize_mul_mat_vec_q2_K_cuda(src0_dd_i, src1_ddf_i, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q3_K:
            dequantize_mul_mat_vec_q3_K_cuda(src0_dd_i, src1_ddf_i, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q4_K:
            dequantize_mul_mat_vec_q4_K_cuda(src0_dd_i, src1_ddf_i, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q5_K:
            dequantize_mul_mat_vec_q5_K_cuda(src0_dd_i, src1_ddf_i, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_Q6_K:
            dequantize_mul_mat_vec_q6_K_cuda(src0_dd_i, src1_ddf_i, dst_dd_i, ne00, row_diff, stream);
            break;
        case GGML_TYPE_F16:
            convert_mul_mat_vec_f16_cuda(src0_dd_i, src1_dfloat, dst_dd_i, ne00, row_diff, stream);
            break;
        default:
            GGML_ASSERT(false);
            break;
    }

#ifdef GGML_CUDA_F16
    if (src1_convert_f16) {
        ggml_cuda_pool_free(src1_dfloat, ash);
    }
#endif // GGML_CUDA_F16

    (void) src1;
    (void) dst;
    (void) src1_ddq_i;
    (void) src1_ncols;
    (void) src1_padded_row_size;
}
</code></pre>
<p>事实上，这些函数都会调用到<code>dequantize_mul_mat_vec</code>，只是选择了不同的函数模版。<br>
以<code>GGML_TYPE_Q4_0</code>为例，调用的是<code>dequantize_mul_mat_vec&lt;QK4_0, QR4_0, dequantize_q4_0&gt;</code>。</p>
<pre><code class="language-c++">static void dequantize_mul_mat_vec_q4_0_cuda(const void * vx, const dfloat * y, float * dst, const int ncols, const int nrows, cudaStream_t stream) {
    GGML_ASSERT(ncols % GGML_CUDA_DMMV_X == 0);
    const int block_num_y = (nrows + GGML_CUDA_MMV_Y - 1) / GGML_CUDA_MMV_Y;
    // the number of rows may exceed maximum grid size in the y or z dimensions, use the x dimension instead
    const dim3 block_nums(block_num_y, 1, 1);
    const dim3 block_dims(WARP_SIZE, GGML_CUDA_MMV_Y, 1);
    dequantize_mul_mat_vec&lt;QK4_0, QR4_0, dequantize_q4_0&gt;
        &lt;&lt;&lt;block_nums, block_dims, 0, stream&gt;&gt;&gt;(vx, y, dst, ncols, nrows);
}
</code></pre>
<p>其中的<code>dequantize_q4_0</code>是<code>GGML_TYPE_Q4_0</code>类型的反量化函数。</p>
<pre><code class="language-c++">static __device__ __forceinline__ void dequantize_q4_0(const void * vx, const int ib, const int iqs, dfloat2 &amp; v){
    const block_q4_0 * x = (const block_q4_0 *) vx;

    const dfloat d = x[ib].d;

    const int vui = x[ib].qs[iqs];

    v.x = vui &amp; 0xF;
    v.y = vui &gt;&gt; 4;

#ifdef GGML_CUDA_F16
    v = __hsub2(v, {8.0f, 8.0f});
    v = __hmul2(v, {d, d});
#else
    v.x = (v.x - 8.0f) * d;
    v.y = (v.y - 8.0f) * d;
#endif // GGML_CUDA_F16
}
</code></pre>
<p>在最终调用到的<code>dequantize_mul_mat_vec</code>中，<code>blockIdx.x*blockDim.y + threadIdx.y</code>用于指定负责的<code>row</code>，<code>threadIdx.x</code>作为<code>tid</code>用于计算所负责的<code>col</code>。以<code>iter_stride</code>为步长，每次迭代处理<code>vals_per_iter</code>个数据，同时单个迭代中又每次处理两个数据（<code>j += 2</code>）。<br>
处理时，先对<code>vx</code>做反量化，结果放置到<code>v</code>，然后再用<code>v</code>和<code>y</code>做相乘，结果累加到<code>tmp</code>中。<br>
接着，根据划分<code>const dim3 block_dims(WARP_SIZE, GGML_CUDA_MMV_Y, 1);</code>，我们知道<code>threadIdx.x</code>的范围其实就是0~31，因此可以做一个warp shuffle（<code>tmp += __shfl_xor_sync(0xffffffff, tmp, mask, 32);</code>）把结果累加，最后<code>tid == 0</code>的线程负责把结果放置到<code>dst[row]</code>中。</p>
<pre><code class="language-c++">template &lt;int qk, int qr, dequantize_kernel_t dequantize_kernel&gt;
static __global__ void dequantize_mul_mat_vec(const void * __restrict__ vx, const dfloat * __restrict__ y, float * __restrict__ dst, const int ncols, const int nrows) {
    // qk = quantized weights per x block
    // qr = number of quantized weights per data value in x block
    const int row = blockIdx.x*blockDim.y + threadIdx.y;

    if (row &gt;= nrows) {
        return;
    }

    const int tid = threadIdx.x;

    const int iter_stride = 2*GGML_CUDA_DMMV_X;
    const int vals_per_iter = iter_stride / WARP_SIZE; // num quantized vals per thread and i iter
    const int y_offset = qr == 1 ? 1 : qk/2;

// partial sum for each thread
#ifdef GGML_CUDA_F16
    half2 tmp = {0.0f, 0.0f}; // two sums for f16 to take advantage of half2 intrinsics
#else
    float tmp = 0.0f;
#endif // GGML_CUDA_F16

    for (int i = 0; i &lt; ncols; i += iter_stride) {
        const int col = i + vals_per_iter*tid;
        const int ib = (row*ncols + col)/qk; // x block index
        const int iqs = (col%qk)/qr; // x quant index
        const int iybs = col - col%qk; // y block start index

// processing &gt;2 values per i iter is faster for fast GPUs
#pragma unroll
        for (int j = 0; j &lt; vals_per_iter; j += 2) {
            // process 2 vals per j iter

            // dequantize
            // for qr = 2 the iqs needs to increase by 1 per j iter because 2 weights per data val
            dfloat2 v;
            dequantize_kernel(vx, ib, iqs + j/qr, v);

            // matrix multiplication
            // for qr = 2 the y index needs to increase by 1 per j iter because of y_offset = qk/2
#ifdef GGML_CUDA_F16
            tmp += __hmul2(v, {
                y[iybs + iqs + j/qr + 0],
                y[iybs + iqs + j/qr + y_offset]
            });
#else
            tmp += v.x * y[iybs + iqs + j/qr + 0];
            tmp += v.y * y[iybs + iqs + j/qr + y_offset];
#endif // GGML_CUDA_F16
        }
    }

    // sum up partial sums and write back result
#pragma unroll
    for (int mask = 16; mask &gt; 0; mask &gt;&gt;= 1) {
        tmp += __shfl_xor_sync(0xffffffff, tmp, mask, 32);
    }

    if (tid == 0) {
#ifdef GGML_CUDA_F16
        dst[row] = tmp.x + tmp.y;
#else
        dst[row] = tmp;
#endif // GGML_CUDA_F16
    }
}
</code></pre>
<h2 id="ggml_cuda_mul_mat_sparse-有什么不同">ggml_cuda_mul_mat_sparse 有什么不同</h2>
<p>sparse这边，反量化版本调用的是<code>ggml_cuda_op_mul_mat_vec_sparse_dequantized</code>。</p>
<pre><code class="language-c++">static void ggml_cuda_mul_mat_sparse(const ggml_tensor * src0, const ggml_tensor * src1, ggml_tensor * dst) {
    GGML_ASSERT(dst-&gt;src[2] != NULL &amp;&amp; &quot;dst-&gt;src[2] must be present for sparse matrix multiplication&quot;);
    if (src1-&gt;ne[1] == 1 &amp;&amp; src0-&gt;ne[0] % GGML_CUDA_DMMV_X == 0) {
        switch(src0-&gt;type) {
            case GGML_TYPE_F16:
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_vec_sparse_dequantized, false);
                break;
            case GGML_TYPE_Q4_0:
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_vec_sparse_q, true);
                break;
            default:
                GGML_ASSERT(false &amp;&amp; &quot;unsupported type for sparse matrix multiplication&quot;);
        }
    } else {
        ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_batch_sparse, false);
    }
}
</code></pre>
<p><code>ggml_cuda_op_mul_mat_vec_sparse_dequantized</code>里面，我们注意到这里从<code>dst-&gt;src</code>里取了<code>sparse_idx</code>和<code>row_lookup</code>这么两个东西。</p>
<pre><code class="language-c++">inline void ggml_cuda_op_mul_mat_vec_sparse_dequantized(
    const ggml_tensor * src0, const ggml_tensor * src1, ggml_tensor * dst, const char * src0_dd_i, const float * src1_ddf_i,
    const char * src1_ddq_i, float * dst_dd_i, const int64_t row_low, const int64_t row_high, const int64_t src1_ncols,
    const int64_t src1_padded_row_size, const cudaStream_t &amp; stream) {

    const int64_t ne00 = src0-&gt;ne[0];
    const int64_t ne10 = src1-&gt;ne[1];
    const int64_t row_diff = row_high - row_low;

    float * sparse_idx = static_cast&lt;float *&gt;(ggml_cuda_get_tensor_data(dst-&gt;src[2]));
    int32_t * row_lookup = dst-&gt;src[3] != NULL ? static_cast&lt;int32_t *&gt;(ggml_cuda_get_tensor_data(dst-&gt;src[3])) : NULL;

    // on some GPUs it is faster to convert src1 to half and to use half precision intrinsics
#ifdef GGML_CUDA_F16
    size_t ash;
    dfloat * src1_dfloat = nullptr; // dfloat == half

    bool src1_convert_f16 = src0-&gt;type == GGML_TYPE_Q4_0 || src0-&gt;type == GGML_TYPE_Q4_1 ||
        src0-&gt;type == GGML_TYPE_Q5_0 || src0-&gt;type == GGML_TYPE_Q5_1 ||
        src0-&gt;type == GGML_TYPE_Q8_0 || src0-&gt;type == GGML_TYPE_F16;

    if (src1_convert_f16) {
        src1_dfloat = (half *) ggml_cuda_pool_malloc(ne00*sizeof(half), &amp;ash);
        ggml_cpy_f32_f16_cuda((const char *) src1_ddf_i, (char *) src1_dfloat, ne00,
                                ne00, 1, sizeof(float), 0, 0,
                                ne00, 1, sizeof(half),  0, 0, stream);
    }
#else
    const dfloat * src1_dfloat = (const dfloat *) src1_ddf_i; // dfloat == float, no conversion
#endif // GGML_CUDA_F16

    cudaMemsetAsync((void *)dst_dd_i, 0, ggml_nbytes(dst), stream);
    switch (src0-&gt;type) {
        case GGML_TYPE_F16:
            convert_mul_mat_vec_f16_cuda_sparse(src0_dd_i, src1_dfloat, dst_dd_i, ne00, row_diff, stream, row_lookup, sparse_idx);
            break;
        default:
            GGML_ASSERT(false &amp;&amp; &quot;Unsupported type&quot;);
            break;
    }

    (void) src1;
    (void) dst;
    (void) src1_ddf_i;
    (void) src1_ncols;
    (void) src1_padded_row_size;
}
</code></pre>
<p>而实际上，这里的<code>row_lookup</code>就是<code>gpu_bucket</code>，记录的是有哪些neurons在GPU上，即这些neurons在原矩阵中的index。而<code>sparse_idx</code>则是运行时通过predictor预测会被激活的neurons的index。</p>
<pre><code class="language-c++">struct ggml_tensor * ggml_mul_mat_idx_upscale(
        struct ggml_context * ctx,
        struct ggml_tensor  * a,
        struct ggml_tensor  * b,
        struct ggml_tensor  * sparse_idx,
        struct ggml_tensor  * gpu_bucket,
                      int64_t result_ne0) {
    bool is_node = false;

    if (a-&gt;grad || b-&gt;grad) {
        is_node = true;
    }

    const int64_t ne[4] = { result_ne0, b-&gt;ne[1], b-&gt;ne[2], b-&gt;ne[3] };
    struct ggml_tensor * result = ggml_new_tensor(ctx, GGML_TYPE_F32, MAX(a-&gt;n_dims, b-&gt;n_dims), ne);

    result-&gt;op   = GGML_OP_MUL_MAT_SPARSE;
    result-&gt;grad = is_node ? ggml_dup_tensor(ctx, result) : NULL;
    result-&gt;src[0] = a;
    result-&gt;src[1] = b;
    result-&gt;src[2] = sparse_idx;
    result-&gt;src[3] = gpu_bucket;

    return result;
}
</code></pre>
<p>然后，<code>row_lookup</code>和<code>sparse_idx</code>会被作为多出来的两个参数<code>lst</code>和<code>idx</code>传递到<code>dequantize_mul_mat_vec_sparse</code>。</p>
<pre><code class="language-c++">static void convert_mul_mat_vec_f16_cuda_sparse(const void * vx, const dfloat * y, float * dst, const int ncols, const int nrows, cudaStream_t stream, int *lst, float *idx) {
    GGML_ASSERT(ncols % GGML_CUDA_DMMV_X == 0);
    const int block_num_y = (nrows + GGML_CUDA_MMV_Y - 1) / GGML_CUDA_MMV_Y;
    const dim3 block_nums(1, block_num_y, 1);
    const dim3 block_dims(WARP_SIZE, GGML_CUDA_MMV_Y, 1);

    dequantize_mul_mat_vec_sparse&lt;1, 1, convert_f16&gt;
        &lt;&lt;&lt;block_nums, block_dims, 0, stream&gt;&gt;&gt;(vx, y, dst, ncols, nrows, lst, idx);
 
}
</code></pre>
<p>到了kernel这边，其实改动就很简单了。<br>
先使用<code>gpu_row</code>去<code>lst</code>（也就是<code>row_lookup</code>或者说<code>gpu_bucket</code>）查询一下其对应的是原矩阵的哪个<code>neuron</code>也就是哪一行<code>row</code>，然后再去<code>idx</code>（也就是通过predictor得到的<code>sparse_idx</code>）看一下其预测值有没有达到<code>dex_sparse_threshold</code>阈值。若没有，则直接<code>return</code>也就是跳过其计算。<br>
就是这么简单，其他部分没有多大修改。</p>
<pre><code class="language-c++">template &lt;int qk, int qr, dequantize_kernel_t dequantize_kernel&gt;
static __global__ void dequantize_mul_mat_vec_sparse(const void * __restrict__ vx, const dfloat * __restrict__ y, float * __restrict__ dst, const int ncols, const int nrows, int * lst, float * idx) {
    // qk = quantized weights per x block
    // qr = number of quantized weights per data value in x block
    const int gpu_row = blockIdx.y*blockDim.y + threadIdx.y;

    if (gpu_row &gt;= nrows) {
        return;
    }

    int row = lst ? lst[gpu_row] : gpu_row;
    if (idx[row] &lt; dev_sparse_threshold) {
        return;
    }

    const int tid = threadIdx.x;

    const int iter_stride = 2*GGML_CUDA_DMMV_X;
    const int vals_per_iter = iter_stride / WARP_SIZE; // num quantized vals per thread and i iter
    const int y_offset = qr == 1 ? 1 : qk/2;

// partial sum for each thread
#ifdef GGML_CUDA_F16
    half2 tmp = {0.0f, 0.0f}; // two sums for f16 to take advantage of half2 intrinsics
#else
    float tmp = 0.0f;
#endif // GGML_CUDA_F16

    for (int i = 0; i &lt; ncols; i += iter_stride) {
        const int col = i + vals_per_iter*tid;
        const int ib = (gpu_row*ncols + col)/qk; // x block index
        const int iqs = (col%qk)/qr; // x quant index
        const int iybs = col - col%qk; // y block start index

// processing &gt;2 values per i iter is faster for fast GPUs
#pragma unroll
        for (int j = 0; j &lt; vals_per_iter; j += 2) {
            // process 2 vals per j iter

            // dequantize
            // for qr = 2 the iqs needs to increase by 1 per j iter because 2 weights per data val
            dfloat2 v;
            dequantize_kernel(vx, ib, iqs + j/qr, v);

            // matrix multiplication
            // for qr = 2 the y index needs to increase by 1 per j iter because of y_offset = qk/2
#ifdef GGML_CUDA_F16
            tmp += __hmul2(v, {
                y[iybs + iqs + j/qr + 0],
                y[iybs + iqs + j/qr + y_offset]
            });
#else
            tmp += v.x * y[iybs + iqs + j/qr + 0];
            tmp += v.y * y[iybs + iqs + j/qr + y_offset];
#endif // GGML_CUDA_F16
        }
    }

    // sum up partial sums and write back result
#pragma unroll
    for (int mask = 16; mask &gt; 0; mask &gt;&gt;= 1) {
        tmp += __shfl_xor_sync(0xffffffff, tmp, mask, 32);
    }

    if (tid == 0) {
#ifdef GGML_CUDA_F16
        dst[row] = tmp.x + tmp.y;
#else
        dst[row] = tmp;
#endif // GGML_CUDA_F16
    }
}
</code></pre>
<h2 id="总结">总结</h2>
<p>对于原版的算子，这里介绍的比较简单。我们主要关注PowerInfer在这里做了什么修改。<br>
其实相比原先的实现，PowerInfer这边的<code>sparse</code>版本所做的修改就很简单。就是检查一下其predictor的预测值有没有达到指定的阈值，若没有则直接<code>return</code>跳过计算即可。<br>
到这里，从上到下的一个简单运行流程就被走通了，对PowerInfer的源码解析也初步结束了。<br>
可能还有下一篇解析，也可能没有了。</p>
<h2 id="支持-️">支持 ☕️</h2>
<p>如果发现内容有纰漏或错误，可以通过邮箱hangyu.yuan@qq.com联系我或直接在下方评论告诉我，谢谢。<br>
我的<a href="https://github.com/Yuan-Allen">GitHub主页</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[PowerInfer源码解析（二）：计算图构建与算子调用]]></title>
        <id>https://alleny.xyz/post/powerinfer-source-analysis-2/</id>
        <link href="https://alleny.xyz/post/powerinfer-source-analysis-2/">
        </link>
        <updated>2024-09-25T09:26:51.000Z</updated>
        <summary type="html"><![CDATA[<p>上篇文章概括了PowerInfer的模型加载过程，这次我们来看一看推理时的流程。</p>
]]></summary>
        <content type="html"><![CDATA[<p>上篇文章概括了PowerInfer的模型加载过程，这次我们来看一看推理时的流程。</p>
<!-- more -->
<h2 id="相关">相关</h2>
<ul>
<li><a href="https://alleny.xyz/post/powerinfer-source-analysis-1/">PowerInfer源码解析（一）：模型加载</a>。</li>
<li><a href="https://alleny.xyz/post/powerinfer-source-analysis-3/">PowerInfer源码解析（三）：算子实现</a>。</li>
</ul>
<h2 id="计算图构建">计算图构建</h2>
<p>让我们回到<code>examples/main/main.cpp:main</code>，模型在加载之后，又经过了一堆推理时的参数准备，最终调用<code>llama_decode</code>进行推理。</p>
<pre><code class="language-c++">int main(int argc, char ** argv) {
    // -- snip --
                for (int i = 0; i &lt; (int) embd.size(); i += params.n_batch) {
                int n_eval = (int) embd.size() - i;
                if (n_eval &gt; params.n_batch) {
                    n_eval = params.n_batch;
                }

                LOG(&quot;eval: %s\n&quot;, LOG_TOKENS_TOSTR_PRETTY(ctx, embd).c_str());

                if (llama_decode(ctx, llama_batch_get_one(&amp;embd[i], n_eval, n_past, 0))) {
                    LOG_TEE(&quot;%s : failed to eval\n&quot;, __func__);
                    return 1;
                }

                n_past += n_eval;

                LOG(&quot;n_past = %d\n&quot;, n_past);
            }
    // -- snip --
}
</code></pre>
<p><code>llama_decode</code>会调用到<code>llama_decode_internal</code>，<code>llama_decode_internal</code>则会使用<code>llama_build_graph</code>来构建计算图。<br>
对于<code>LLM_ARCH_LLAMA</code>和<code>LLM_ARCH_BAMBOO</code>模型架构，PowerInfer调用<code>llm.build_llama_variants</code>来生成计算图（替代了原有的<code>llm.build_llama</code>函数）。<br>
对原先的<code>build_llama</code>而言，新的<code>build_llama_variants</code>的区别主要在于，对于使用sparse inference的情况，PowerInfer会使用单独的<code>llm_build_ffn_sparse</code>（区别于<code>llm_build_ffn</code>）来生成FFN部分。</p>
<pre><code class="language-c++">    struct ggml_cgraph * build_llama_variants() {
        // -- snip --
                if (llama_use_sparse_inference(&amp;model)) {
                    llm_build_cb_short cbs = [&amp;](ggml_tensor * cur, const char * name) {
                        std::string name_str = std::string(name) + &quot;-&quot; + std::to_string(il);
                        ggml_set_name(cur, name_str.c_str());
                    };
                    // We only offload the ffn input to GPU if all neurons are offloaded
                    if (model.layers[il].gpu_offload_ratio &gt;= 1.) {
                        cb(cur, &quot;ffn_norm&quot;, il);
                    } else {
                        cbs(cur, &quot;ffn_norm&quot;);
                    }
                    cur = llm_build_ffn_sparse(ctx0, cur,
                        model.layers[il].ffn_up,   NULL,
                        model.layers[il].ffn_gate, NULL,
                        model.layers[il].ffn_down_t, NULL,
                        model.layers[il].mlp_pre_w1,
                        model.layers[il].mlp_pre_w2,
                        ffn_inp, // as for now, llama's pred use the same input as the ffn
                        model.layers[il].gpu_idx, 
                        model.layers[il].gpu_bucket, model.layers[il].ffn_gate_gpu, model.layers[il].ffn_down_gpu, model.layers[il].ffn_up_gpu,
                        LLM_FFN_RELU, gate_type, model.layers[il].gpu_offload_ratio, cbs);
                } else {
                    // fallback to dense
                    cb(cur, &quot;ffn_norm&quot;, il);
                    llm_ffn_op_type   act_type = model.arch == LLM_ARCH_BAMBOO ? LLM_FFN_RELU : LLM_FFN_SILU;
                    cur = llm_build_ffn(ctx0, cur,
                        model.layers[il].ffn_up,   NULL,
                        model.layers[il].ffn_gate, NULL,
                        model.layers[il].ffn_down, NULL,
                        act_type, gate_type, cb, il);
                }
    // -- snip --
}
</code></pre>
<p>在<code>llm_build_ffn_sparse</code>中我们可以具体看见FFN部分是如何被构建的。我们可以先看一下原版Llama的MLP的具体架构。<br>
<img src="https://alleny.xyz/post-images/1727258017810.png" alt="" loading="lazy"><br>
图中的Gate，Up和Down均为线性层。即Llama的MLP的输入会一边经过Gate然后激活函数，另一边经过Up，最后两者乘起来再经过Down，最终得到MLP的输出。<br>
至于PowerInfer，则在前面加了一个Predictor用来预测当前层的哪些neurons会被激活。并且，这些neurons可能是分别分布在GPU和CPU上的，同时还要考虑利用到激活的稀疏性，因此还会调用特制的算子来进行计算。<br>
<img src="https://alleny.xyz/post-images/1727323918446.png" alt="" loading="lazy"><br>
于是来看看代码。</p>
<pre><code class="language-c++">static struct ggml_tensor * llm_build_ffn_sparse(
        struct ggml_context * ctx,
         struct ggml_tensor * cur,
         struct ggml_tensor * up,
         struct ggml_tensor * up_b,
         struct ggml_tensor * gate,
         struct ggml_tensor * gate_b,
         struct ggml_tensor * down_t,
         struct ggml_tensor * down_b,
         struct ggml_tensor * pre_w1,
         struct ggml_tensor * pre_w2,
         struct ggml_tensor * pred_inpl,
         struct ggml_tensor * gpu_index,
         struct ggml_tensor * gpu_bucket,
         struct ggml_tensor * gate_gpu,
         struct ggml_tensor * down_gpu,
         struct ggml_tensor * up_gpu,
            llm_ffn_op_type   type_op,
          llm_ffn_gate_type   type_gate,
                     double   gpu_offload_ratio,
   const llm_build_cb_short &amp; cb_outer) {
    bool full_gpu = gpu_offload_ratio &gt;= 1.0;
    ggml_tensor * ffn_input = cur;

    llm_build_cb_short cb = [&amp;cb_outer](struct ggml_tensor * tensor, const char * name) {
        cb_outer(tensor, name);
#if defined(GGML_USE_CUBLAS)
        // Determine offloading based on src[0] (weight for both mul and axpy)
        bool operates_on_gpu = tensor-&gt;src[0]-&gt;backend == GGML_BACKEND_GPU;
        if (operates_on_gpu) {
            ggml_cuda_assign_buffers_no_alloc(tensor);
        }
#endif
    };

    // prepare sparse idx
    ggml_tensor * idx = ggml_mul_mat(ctx, pre_w1, pred_inpl);
    cb(idx, &quot;mlp_pre_hidden&quot;);
    idx = ggml_relu(ctx, idx);
    cb(idx, &quot;mlp_pre_relu&quot;);
    idx = ggml_mul_mat(ctx, pre_w2, idx);
    // If the FFN layer is not fully offloaded, we need to transfer the sparsity index
    // back to the CPU to avoid synchronization issues.
    (full_gpu ? cb : cb_outer)(idx, &quot;mlp_pre_out&quot;);

    auto act_fn = [&amp;](ggml_tensor * tensor, const char * name) {
        switch (type_op) {
            case LLM_FFN_RELU:
                {
                    tensor = ggml_relu(ctx, tensor);
                    cb(tensor, name);
                } break;
            default:
                GGML_ASSERT(false &amp;&amp; &quot;unsupported activation function&quot;);
        }
        return tensor;
    };

    // FFN up
    struct ggml_tensor * up_out = llm_build_sparse_mul_mat(ctx, up, ffn_input, idx, up_gpu, gpu_index, gpu_bucket, cb_outer, &quot;up&quot;, full_gpu);
    if (up_b) {
        up_out = ggml_add(ctx, up_out, up_b);
        cb(up_out, &quot;ffn_up_b&quot;);
    }

    struct ggml_tensor * gate_out = nullptr;
    if (gate) {
        ggml_tensor * gate_input = (type_gate == LLM_FFN_PAR || type_gate == LLM_FFN_SYM) ? ffn_input : up_out;
        gate_out = llm_build_sparse_mul_mat(ctx, gate, gate_input, idx, gate_gpu, gpu_index, gpu_bucket, cb_outer, &quot;gate&quot;, full_gpu);
        if (gate_b) {
            gate_out = ggml_add(ctx, gate_out, gate_b);
            cb(gate_out, &quot;ffn_gate_b&quot;);
        }
        switch (type_gate) {
            case LLM_FFN_PAR:
                {
                    ggml_tensor * act_gate = act_fn(gate_out, &quot;ffn_gate_act&quot;);
                    cur = ggml_mul(ctx, act_gate, up_out);
                    cb(cur, &quot;ffn_gate_par&quot;);
                } break;
            case LLM_FFN_SYM:
                {
                    ggml_tensor * act_gate = act_fn(gate_out, &quot;ffn_gate_act&quot;);
                    ggml_tensor * act_up = act_fn(up_out, &quot;ffn_up_act&quot;);
                    cur = ggml_mul(ctx, act_gate, act_up);
                    cb(cur, &quot;ffn_gate_sym&quot;);
                } break;
            case LLM_FFN_SEQ:
                {
                    cur = act_fn(gate_out, &quot;ffn_gate_act&quot;);
                } break;
            default: GGML_ASSERT(false &amp;&amp; &quot;unsupported gate type&quot;);
        }
    } else {
        cur = act_fn(up_out, &quot;ffn_up_act&quot;);
    }

    cur = llm_build_sparse_axpy(ctx, down_t, cur, idx, down_gpu, gpu_index, gpu_bucket, cb_outer, &quot;down&quot;, full_gpu);

    if (down_b) {
        cur = ggml_add(ctx, cur, down_b);
        cb(cur, &quot;ffn_down_b&quot;);
    }

    return cur;
}
</code></pre>
<p>让我们来具体看一下里面的内容。<br>
首先是一个矩阵乘、一个ReLU、再一个矩阵乘，组成了predictor部分，张量名字分别为<code>mlp_pre_hidden</code>、<code>mlp_pre_relu</code>和<code>mlp_pre_out</code>，最终得到sparse idx，即哪些neurons会被激活的预测结果。</p>
<pre><code class="language-c++">    // prepare sparse idx
    ggml_tensor * idx = ggml_mul_mat(ctx, pre_w1, pred_inpl);
    cb(idx, &quot;mlp_pre_hidden&quot;);
    idx = ggml_relu(ctx, idx);
    cb(idx, &quot;mlp_pre_relu&quot;);
    idx = ggml_mul_mat(ctx, pre_w2, idx);
    // If the FFN layer is not fully offloaded, we need to transfer the sparsity index
    // back to the CPU to avoid synchronization issues.
    (full_gpu ? cb : cb_outer)(idx, &quot;mlp_pre_out&quot;);
</code></pre>
<p>定义了后续所使用的激活函数，目前只支持ReLU。</p>
<pre><code class="language-c++">    auto act_fn = [&amp;](ggml_tensor * tensor, const char * name) {
        switch (type_op) {
            case LLM_FFN_RELU:
                {
                    tensor = ggml_relu(ctx, tensor);
                    cb(tensor, name);
                } break;
            default:
                GGML_ASSERT(false &amp;&amp; &quot;unsupported activation function&quot;);
        }
        return tensor;
    };
</code></pre>
<p>回忆Llama MLP的结构，首先一边是<code>ffn_up</code>。</p>
<pre><code class="language-c++">    // FFN up
    struct ggml_tensor * up_out = llm_build_sparse_mul_mat(ctx, up, ffn_input, idx, up_gpu, gpu_index, gpu_bucket, cb_outer, &quot;up&quot;, full_gpu);
    if (up_b) {
        up_out = ggml_add(ctx, up_out, up_b);
        cb(up_out, &quot;ffn_up_b&quot;);
    }
</code></pre>
<p>另一边是<code>ffn_gate</code>以及后续的激活函数。<br>
注意这里又有一个gate类型的选择。其类型分别有：</p>
<ul>
<li><code>LLM_FFN_SEQ</code>：<code>ffn_gate</code>和<code>ffn_up</code>的计算是顺序的，先计算<code>ffn_up</code>，再把<code>ffn_up</code>的结果作为<code>ffn_gate</code>的输入。</li>
<li><code>LLM_FFN_PAR</code>：<code>ffn_gate</code>与<code>ffn_up</code>的计算是并行的。<code>ffn_gate</code>的输入是<code>ffn_input</code>，等输入经过<code>ffn_gate</code>和激活函数后再和<code>up_out</code>相乘。</li>
<li><code>LLM_FFN_SYM</code>：与<code>LLM_FFN_PAR</code>的区别是，<code>up_out</code>也要先经过激活函数才与<code>ffn_gate_act</code>相乘。<br>
最后，结果会再经过<code>ffn_down</code>，进行一个axpy操作，得到最终结果。</li>
</ul>
<pre><code class="language-c++">    struct ggml_tensor * gate_out = nullptr;
    if (gate) {
        ggml_tensor * gate_input = (type_gate == LLM_FFN_PAR || type_gate == LLM_FFN_SYM) ? ffn_input : up_out;
        gate_out = llm_build_sparse_mul_mat(ctx, gate, gate_input, idx, gate_gpu, gpu_index, gpu_bucket, cb_outer, &quot;gate&quot;, full_gpu);
        if (gate_b) {
            gate_out = ggml_add(ctx, gate_out, gate_b);
            cb(gate_out, &quot;ffn_gate_b&quot;);
        }
        switch (type_gate) {
            case LLM_FFN_PAR:
                {
                    ggml_tensor * act_gate = act_fn(gate_out, &quot;ffn_gate_act&quot;);
                    cur = ggml_mul(ctx, act_gate, up_out);
                    cb(cur, &quot;ffn_gate_par&quot;);
                } break;
            case LLM_FFN_SYM:
                {
                    ggml_tensor * act_gate = act_fn(gate_out, &quot;ffn_gate_act&quot;);
                    ggml_tensor * act_up = act_fn(up_out, &quot;ffn_up_act&quot;);
                    cur = ggml_mul(ctx, act_gate, act_up);
                    cb(cur, &quot;ffn_gate_sym&quot;);
                } break;
            case LLM_FFN_SEQ:
                {
                    cur = act_fn(gate_out, &quot;ffn_gate_act&quot;);
                } break;
            default: GGML_ASSERT(false &amp;&amp; &quot;unsupported gate type&quot;);
        }
    } else {
        cur = act_fn(up_out, &quot;ffn_up_act&quot;);
    }
</code></pre>
<p>需要注意的是，<code>llm_build_ffn_sparse</code>调用了专门的<code>llm_build_sparse_mul_mat</code>来进行矩阵乘，其以使用sparse idx来利用激活的稀疏性特征。<br>
在<code>llm_build_sparse_mul_mat</code>中，如果是全部计算卸载到GPU的情况则直接对<code>up_gpu</code>和输入调用<code>ggml_mul_mat_idx</code>并返回即可。<br>
否则，对CPU上的<code>up</code>和GPU上的<code>up_gpu</code>分别使用<code>ggml_mul_mat_idx</code>和<code>ggml_mul_mat_idx_upscale</code>进行计算，然后再把得到的结果<code>out</code>和<code>out_gpu</code>使用<code>ggml_add</code>进行汇总，得到最终结果。</p>
<pre><code class="language-c++">static struct ggml_tensor * llm_build_sparse_mul_mat(
        struct ggml_context * ctx,
         struct ggml_tensor * up,
         struct ggml_tensor * inp,
         struct ggml_tensor * idx,
         struct ggml_tensor * up_gpu,
         struct ggml_tensor * gpu_index,
         struct ggml_tensor * gpu_bucket,
   const llm_build_cb_short &amp; cb,
                 const char * name,
                         bool full_gpu) {
    std::string full_name = &quot;ffn_&quot; + std::string(name) + &quot;_sparse&quot;;
    ggml_tensor * out = nullptr;

#ifdef GGML_USE_HIPBLAS
// WARNING: THIS IS A HACK! 
// if up_gpu-&gt;data is null
// inference fails when model exceeds 40B on rocm device
// so we just let up_gpu-&gt;data point to itself
    
    up_gpu-&gt;data = up_gpu;

#endif 

#ifdef GGML_USE_CUBLAS
    // Full offloading fast path
    if (full_gpu) {
        GGML_ASSERT(up_gpu &amp;&amp; &quot;full_gpu but no up_gpu&quot;);
        out = ggml_mul_mat_idx(ctx, up_gpu, inp, idx, NULL);
        ggml_cuda_assign_buffers_no_alloc(out);
        cb(out, (full_name).c_str());
        return out;
    }
#endif

    out = ggml_mul_mat_idx(ctx, up, inp, idx, gpu_index);
    cb(out, full_name.c_str());

#ifdef GGML_USE_CUBLAS
    if (up_gpu) {
        ggml_tensor * out_gpu = ggml_mul_mat_idx_upscale(ctx, up_gpu, inp, idx, gpu_bucket, out-&gt;ne[0]);
        ggml_cuda_assign_buffers_no_alloc(out_gpu);
        cb(out_gpu, (full_name + &quot;_gpu&quot;).c_str());
        out = ggml_add(ctx, out, out_gpu);
        // We don't need to assign buffers here, as the output will be passed into Axpy,
        // which in this case, is also a hybrid operation.
        cb(out, (full_name + &quot;_merged&quot;).c_str());
    }
#endif

    return out;
}
</code></pre>
<p>查看所调用的<code>ggml_mul_mat_idx</code>。我们可以看见，<code>a</code>，<code>b</code>，<code>sparse idx</code>（由predictor得到）和<code>gpu_idx</code>（offline时候得到）分别被作为了四个<code>src</code>参与计算。<code>op</code>使用的是<code>GGML_OP_MUL_MAT_SPARSE</code>（区别于<code>GGML_OP_MUL_MAT</code>）。</p>
<pre><code class="language-c++">struct ggml_tensor * ggml_mul_mat_idx(
        struct ggml_context * ctx,
        struct ggml_tensor  * a,
        struct ggml_tensor  * b,
        struct ggml_tensor  * sparse_idx,
        // Under hybrid inference, this tensor is to indicate which row are offloaded to GPU;
        // When using full GPU inference, it is NULL.
        struct ggml_tensor  * gpu_idx) {
    GGML_ASSERT(!ggml_is_transposed(a));

    bool is_node = false;

    if (a-&gt;grad || b-&gt;grad) {
        is_node = true;
    }

    const int64_t ne[4] = { a-&gt;ne[1], b-&gt;ne[1], b-&gt;ne[2], b-&gt;ne[3] };
    struct ggml_tensor * result = ggml_new_tensor(ctx, GGML_TYPE_F32, MAX(a-&gt;n_dims, b-&gt;n_dims), ne);

    result-&gt;op   = GGML_OP_MUL_MAT_SPARSE;
    result-&gt;grad = is_node ? ggml_dup_tensor(ctx, result) : NULL;
    result-&gt;src[0] = a;
    result-&gt;src[1] = b;
    result-&gt;src[2] = sparse_idx;
    result-&gt;src[3] = gpu_idx;

    int32_t params[] = { gpu_idx ? 0 : 1 };
    ggml_set_op_params(result, params, sizeof(params));

    return result;
}
</code></pre>
<h2 id="算子调用">算子调用</h2>
<p>回到<code>llama_decode_internal</code>中。计算图被构建以后，后续则会被使用<code>ggml_graph_compute_helper</code>进行计算。<br>
<code>ggml_graph_compute_helper</code>会调用<code>ggml_graph_plan</code>评估工作缓冲区的大小，得到一个<code>ggml_cplan</code>（主要成员为<code>work_size</code>，<code>work_data</code>和<code>n_threads</code>）。然后，会使用<code>ggml_graph_compute(graph, &amp;plan)</code>进行计算。</p>
<pre><code class="language-c++">static void ggml_graph_compute_helper(std::vector&lt;uint8_t&gt; &amp; buf, ggml_cgraph * graph, int n_threads) {
    struct ggml_cplan plan = ggml_graph_plan(graph, n_threads);

    if (plan.work_size &gt; 0) {
        buf.resize(plan.work_size);
        plan.work_data = buf.data();
    }

    ggml_graph_compute(graph, &amp;plan);
}
</code></pre>
<p>区别于原先的代码，PowerInfer所使用的<code>state_shared</code>中<code>n_threads</code>与<code>n_active</code>均比<code>cplan</code>中的值少1，这应该是由于PowerInfer中有一个单独的线程专门用作GPU Executor。<br>
然后，PowerInfer创建的工作线程所执行函数为<code>ggml_graph_compute_thread_hybrid</code>（区别于<code>ggml_graph_compute_thread</code>），最终完成计算。</p>
<pre><code class="language-c++">int ggml_graph_compute(struct ggml_cgraph * cgraph, struct ggml_cplan * cplan) {
    {
        GGML_ASSERT(cplan);
        GGML_ASSERT(cplan-&gt;n_threads &gt; 0);

        if (cplan-&gt;work_size &gt; 0) {
            GGML_ASSERT(cplan-&gt;work_data);
        }
    }

    const int n_threads = cplan-&gt;n_threads;
#ifdef GGML_USE_HYBRID_THREADING
    struct ggml_compute_state_shared state_shared = {
        /*.cgraph                  =*/ cgraph,
        /*.cgraph_plan             =*/ cplan,
        /*.perf_node_start_cycles  =*/ 0,
        /*.perf_node_start_time_us =*/ 0,
        /*.n_threads               =*/ n_threads-1,
        /*.aic                     =*/ 0,
        /*.n_active                =*/ n_threads-1,
        /*.node_n                  =*/ -1,
        /*.abort_callback          =*/ NULL,
        /*.abort_callback_data     =*/ NULL,
    };
#else
    struct ggml_compute_state_shared state_shared = {
        /*.cgraph                  =*/ cgraph,
        /*.cgraph_plan             =*/ cplan,
        /*.perf_node_start_cycles  =*/ 0,
        /*.perf_node_start_time_us =*/ 0,
        /*.n_threads               =*/ n_threads,
        /*.aic                     =*/ 0,
        /*.n_active                =*/ n_threads,
        /*.node_n                  =*/ -1,
        /*.abort_callback          =*/ NULL,
        /*.abort_callback_data     =*/ NULL,
    };
#endif
    struct ggml_compute_state * workers = alloca(sizeof(struct ggml_compute_state)*n_threads);

    // create thread pool
    if (n_threads &gt; 1) {
        for (int j = 1; j &lt; n_threads; ++j) {
            workers[j] = (struct ggml_compute_state) {
                .thrd   = 0,
                .ith = j,
                .shared = &amp;state_shared,
            };
#ifdef GGML_USE_HYBRID_THREADING
            const int rc = ggml_thread_create(&amp;workers[j].thrd, NULL, ggml_graph_compute_thread_hybrid, &amp;workers[j]);
#else
            const int rc = ggml_thread_create(&amp;workers[j].thrd, NULL, ggml_graph_compute_thread, &amp;workers[j]);
#endif
            GGML_ASSERT(rc == 0);
            UNUSED(rc);
        }
    }

    workers[0].ith = 0;
    workers[0].shared = &amp;state_shared;

    const int64_t perf_start_cycles  = ggml_perf_cycles();
    const int64_t perf_start_time_us = ggml_perf_time_us();

    // this is a work thread too

#ifdef GGML_USE_HYBRID_THREADING
    int compute_status = (size_t) ggml_graph_compute_thread_hybrid(&amp;workers[0]);
#else
    int compute_status = (size_t) ggml_graph_compute_thread(&amp;workers[0]);
#endif

    // don't leave affinity set on the main thread
    clear_numa_thread_affinity();

    // join or kill thread pool
    if (n_threads &gt; 1) {
        for (int j = 1; j &lt; n_threads; j++) {
            const int rc = ggml_thread_join(workers[j].thrd, NULL);
            GGML_ASSERT(rc == 0);
        }
    }

    // performance stats (graph)
    {
        int64_t perf_cycles_cur  = ggml_perf_cycles()  - perf_start_cycles;
        int64_t perf_time_us_cur = ggml_perf_time_us() - perf_start_time_us;

        cgraph-&gt;perf_runs++;
        cgraph-&gt;perf_cycles  += perf_cycles_cur;
        cgraph-&gt;perf_time_us += perf_time_us_cur;

        GGML_PRINT_DEBUG(&quot;%s: perf (%d) - cpu = %.3f / %.3f ms, wall = %.3f / %.3f ms\n&quot;,
                __func__, cgraph-&gt;perf_runs,
                (double) perf_cycles_cur      / (double) ggml_cycles_per_ms(),
                (double) cgraph-&gt;perf_cycles  / (double) ggml_cycles_per_ms() / (double) cgraph-&gt;perf_runs,
                (double) perf_time_us_cur     / 1000.0,
                (double) cgraph-&gt;perf_time_us / 1000.0 / cgraph-&gt;perf_runs);
    }

    return compute_status;
}
</code></pre>
<p>因此重头戏就在工作线程所执行的<code>ggml_graph_compute_thread_hybrid</code>里面。这是一个比较长的函数，我们来梳理一下里面的流程。</p>
<ul>
<li>主要的函数体是一个<code>while(true)</code>的循环，计算图的节点会在里面依次得到计算。</li>
<li>第0号线程(<code>state-&gt;ith == 0</code>)会进入一条单独的路径。事实上从<code>if (node-&gt;backend == GGML_BACKEND_CPU) continue;</code>可以看出这是专门用来负责GPU计算的线程。其会使用一个<code>while (1)</code>循环来等待<code>node-&gt;src[0]-&gt;is_finish</code>，<code>node-&gt;src[1]-&gt;is_finish</code>和<code>node-&gt;src[2]-&gt;is_finish</code>均准备就绪，然后设置参数(<code>params.type = GGML_TASK_COMPUTE</code>)调用<code>ggml_compute_forward</code>进行计算，之后再把<code>node-&gt;is_finish</code>置为1。以此往复，直到<code>node_n &gt;= cgraph-&gt;n_nodes</code>。</li>
<li>其他线程（非0号）是负责执行CPU计算的线程。
<ul>
<li>算子可能有<code>INIT</code>子任务和<code>FINALIZE</code>子任务，可使用<code>GGML_OP_HAS_INIT[node-&gt;op]</code>和<code>GGML_OP_HAS_FINALIZE[node-&gt;op]</code>来判断。</li>
<li>每个线程每次循环会先执行一遍<code>atomic_fetch_sub(&amp;state-&gt;shared-&gt;n_active, 1)</code>。
<ul>
<li>最后一个执行到这里（返回值为1）的线程将会负责上一个节点的<code>FINALIZE</code>子任务（可能是收集结果等），然后分发新任务。分发新任务的过程包括：
<ul>
<li><code>++node_n</code>。</li>
<li>等待<code>src[0]</code>， <code>src[1]</code>和<code>src[2]</code>完成。</li>
<li>如果有<code>INIT</code>子任务，执行<code>INIT</code>子任务。</li>
<li>如果<code>n_tasks == 1</code>，说明只有一份任务，直接当场自己执行了，不用交给其他线程。如果有<code>FINALIZE</code>子任务则把<code>FINALIZE</code>也执行了。然后回到<code>++node_n</code>的步骤。</li>
<li><code>n_tasks</code>不是1，那么重置好<code>state-&gt;shared-&gt;n_active</code>为<code>n_threads</code>，设置好<code>state-&gt;shared-&gt;node_n</code>为新的<code>node_n</code>。</li>
</ul>
</li>
<li><code>atomic_fetch_sub(&amp;state-&gt;shared-&gt;n_active, 1) == 1</code>判定失败的线程会对<code>state-&gt;shared-&gt;node_n</code>进行等待，直到其出现变化（值不等于之前拿到的局部变量<code>node_n</code>了）。别忘了分发任务的结尾会设置新的<code>state-&gt;shared-&gt;node_n</code>，其影响的就是这里。</li>
</ul>
</li>
<li>无论是否是负责分发任务的线程，都会尝试对当前任务进行计算。
<ul>
<li><code>if (node_n &gt;= cgraph-&gt;n_nodes) break;</code>：所有节点执行完毕，可以退出最外层的<code>while(true)</code>循环，任务停止。</li>
<li>设置<code>ggml_compute_params</code>。这里由于负责执行CPU计算的线程是从<code>state-&gt;ith == 1</code>开始的，因此<code>ith</code>要减一。至于<code>nth</code>这里为什么是<code>n_tasks-1</code>，本人依然有疑问。有知道的可联系笔者或在评论区评论。</li>
<li><code>state-&gt;ith &lt; n_tasks</code>的情况下，调用<code>ggml_compute_forward</code>执行分配给自己的计算任务。</li>
</ul>
</li>
</ul>
</li>
</ul>
<pre><code class="language-c++">static thread_ret_t ggml_graph_compute_thread_hybrid(void * data) {
    struct ggml_compute_state * state = (struct ggml_compute_state *) data;

    const struct ggml_cgraph * cgraph = state-&gt;shared-&gt;cgraph;
    const struct ggml_cplan  * cplan  = state-&gt;shared-&gt;cplan;

    const int   n_threads   = state-&gt;shared-&gt;n_threads;

    set_numa_thread_affinity(state-&gt;ith, n_threads);

    // cpu_set_t mask;
    // CPU_ZERO(&amp;mask);
    // CPU_SET(state-&gt;ith * 2, &amp;mask);
    // if (sched_setaffinity(0, sizeof(mask), &amp;mask) == -1) {
    //     perror(&quot;sched_setaffinity&quot;);
    // }

    int node_n = -1;

    while (true) {
        if (cplan-&gt;abort_callback &amp;&amp; cplan-&gt;abort_callback(cplan-&gt;abort_callback_data)) {
            state-&gt;shared-&gt;node_n += 1;
            return (thread_ret_t) GGML_EXIT_ABORTED;
        }
        if (state-&gt;ith == 0)
        {
            // atomic_fetch_sub(&amp;state-&gt;shared-&gt;n_active, 1);
            node_n = -1;
            // return 0;

            while (1)
            {
                state-&gt;shared-&gt;perf_node_start_cycles  = ggml_perf_cycles();
                state-&gt;shared-&gt;perf_node_start_time_us = ggml_perf_time_us();
                node_n = node_n + 1;
                if (node_n &gt;= cgraph-&gt;n_nodes)
                    return 0;
                struct ggml_tensor *node = cgraph-&gt;nodes[node_n];
                if (node-&gt;backend == GGML_BACKEND_CPU)
                    continue;
                // uint64_t dbug = 0;
                while (1)
                {
                    // dbug++;
                    int status0 = atomic_load(&amp;node-&gt;src[0]-&gt;is_finish);
                    int status1 = 1;
                    int status2 = 1;
                    if (node-&gt;src[1] != NULL)
                        status1 = atomic_load(&amp;node-&gt;src[1]-&gt;is_finish);
                    if (node-&gt;src[2] != NULL)
                        status2 = atomic_load(&amp;node-&gt;src[2]-&gt;is_finish);
                    // if (dbug &gt; 10000000) {
                    //     printf(&quot;stuck %s thread %d\n&quot;, ggml_get_name(node), n_threads);
                    //     int k;
                    //     scanf(&quot;%d&quot;, &amp;k);
                    // }
                    if (status0 == 1 &amp;&amp; status1 == 1 &amp;&amp; status2 == 1)
                    {
                        break;
                    }
                    // else
                    //     busy_wait_cycles(10);
                }
                struct ggml_compute_params params = {
                    /*.type  =*/GGML_TASK_COMPUTE,
                    /*.ith   =*/0,
                    /*.nth   =*/1,
                    /*.wsize =*/0,
                    /*.wdata =*/0,
                    /*.aic   =*/0,
                };


                // printf(&quot;GPU %s\n&quot;, ggml_get_name(node));
                // cudaDeviceSynchronize();
                ggml_compute_forward(&amp;params, node);
                // cudaDeviceSynchronize();
                // ggml_graph_compute_perf_stats_node_gpu(node, state-&gt;shared);
                ggml_graph_compute_perf_stats_node_gpu(node, state-&gt;shared);
                // if (strcmp(ggml_get_name(node), &quot;before&quot;) == 0)
                //     printf(&quot;%ld\n&quot;, ggml_time_us());
                atomic_store(&amp;node-&gt;is_finish, 1);
            }
        }
        if (atomic_fetch_sub(&amp;state-&gt;shared-&gt;n_active, 1) == 1) {
            // all other threads are finished and spinning
            // do finalize and init here so we don't have synchronize again
            struct ggml_compute_params params = {
                /*.type  =*/ GGML_TASK_FINALIZE,
                /*.ith   =*/ 0,
                /*.nth   =*/ 0,
                /*.wsize =*/ cplan-&gt;work_size,
                /*.wdata =*/ cplan-&gt;work_data,
                /*.aic   =*/ &amp;state-&gt;shared-&gt;aic,
            };

            if (node_n != -1) {
                /* FINALIZE */
                struct ggml_tensor * node = cgraph-&gt;nodes[node_n];
                if (GGML_OP_HAS_FINALIZE[node-&gt;op]) {
                    params.nth = ggml_get_n_tasks(node, n_threads);
                    ggml_compute_forward(&amp;params, node);
                }
                ggml_graph_compute_perf_stats_node(node, state-&gt;shared);
                atomic_store(&amp;node-&gt;is_finish, 1);
            }

            // distribute new work or execute it direct if 1T
            while (++node_n &lt; cgraph-&gt;n_nodes) {
                GGML_PRINT_DEBUG_5(&quot;%s: %d/%d\n&quot;, __func__, node_n, cgraph-&gt;n_nodes);

                struct ggml_tensor * node = cgraph-&gt;nodes[node_n];
                const int n_tasks = ggml_get_n_tasks(node, n_threads);

                state-&gt;shared-&gt;perf_node_start_cycles  = ggml_perf_cycles();
                state-&gt;shared-&gt;perf_node_start_time_us = ggml_perf_time_us();

                params.nth = n_tasks;
                if (node-&gt;backend == GGML_BACKEND_GPU)
                    continue;
                while(1)
                {
                    int status0 = atomic_load(&amp;node-&gt;src[0]-&gt;is_finish);
                    int status1 = 1;
                    int status2 = 1;
                    if(node-&gt;src[1] != NULL)
                        status1 = atomic_load(&amp;node-&gt;src[1]-&gt;is_finish);
                    if(node-&gt;src[2] != NULL)
                        status2 = atomic_load(&amp;node-&gt;src[2]-&gt;is_finish);
                    if(status0 == 1 &amp;&amp; status1 == 1 &amp;&amp; status2 == 1)
                        break;
                    // else busy_wait_cycles(10);
                }

                /* INIT */
                if (GGML_OP_HAS_INIT[node-&gt;op]) {
                    params.type = GGML_TASK_INIT;
                    ggml_compute_forward(&amp;params, node);
                }

                if (n_tasks == 1) {
                    // TODO: maybe push node_n to the atomic but if other threads see n_tasks is 1,
                    // they do something more efficient than spinning (?)
                    params.type = GGML_TASK_COMPUTE;
                    ggml_compute_forward(&amp;params, node);
                    atomic_store(&amp;node-&gt;is_finish, 1);

                    if (GGML_OP_HAS_FINALIZE[node-&gt;op]) {
                        params.type = GGML_TASK_FINALIZE;
                        ggml_compute_forward(&amp;params, node);
                    }

                    ggml_graph_compute_perf_stats_node(node, state-&gt;shared);
                } else {
                    break;
                }

                if (cplan-&gt;abort_callback &amp;&amp; cplan-&gt;abort_callback(cplan-&gt;abort_callback_data)) {
                    break;
                }
            }

            atomic_store(&amp;state-&gt;shared-&gt;n_active, n_threads);
            atomic_store(&amp;state-&gt;shared-&gt;node_n,   node_n);
        } else {
            // wait for other threads to finish
            const int last = node_n;
            while (true) {
                // TODO: this sched_yield can have significant impact on the performance - either positive or negative
                //       depending on the workload and the operating system.
                //       since it is not clear what is the best approach, it should potentially become user-configurable
                //       ref: https://github.com/ggerganov/ggml/issues/291
#if defined(GGML_USE_ACCELERATE) || defined(GGML_USE_OPENBLAS)
                sched_yield();
#endif

                node_n = atomic_load(&amp;state-&gt;shared-&gt;node_n);
                if (node_n != last) break;
            };
        }

        // check if we should stop
        if (node_n &gt;= cgraph-&gt;n_nodes) break;

        /* COMPUTE */
        struct ggml_tensor * node = cgraph-&gt;nodes[node_n];
        const int n_tasks = ggml_get_n_tasks(node, n_threads);

        struct ggml_compute_params params = {
            /*.type  =*/ GGML_TASK_COMPUTE,
            /*.ith   =*/ state-&gt;ith-1,
            /*.nth   =*/ n_tasks-1,
            /*.wsize =*/ cplan-&gt;work_size,
            /*.wdata =*/ cplan-&gt;work_data,
            /*.aic   =*/ &amp;state-&gt;shared-&gt;aic,
        };

        if (state-&gt;ith &lt; n_tasks) {
            ggml_compute_forward(&amp;params, node);
        }
    }

    return GGML_EXIT_SUCCESS;
}
</code></pre>
<p><code>ggml_compute_forward</code>会负责根据<code>tensor-&gt;op</code>去调用具体的算子。</p>
<pre><code class="language-c++">static void ggml_compute_forward(struct ggml_compute_params * params, struct ggml_tensor * tensor) {
    GGML_ASSERT(params);

    if (tensor-&gt;op == GGML_OP_NONE) {
        return;
    }

#ifdef GGML_USE_CUBLAS
    bool skip_cpu = ggml_cuda_compute_forward(params, tensor);
    if (skip_cpu) {
        return;
    }
    // Make sure src[0] (weight for binary ops) is on CPU to avoid any weight transfer
    GGML_ASSERT((tensor-&gt;src[0] == NULL || tensor-&gt;src[0]-&gt;backend == GGML_BACKEND_CPU) &amp;&amp; &quot;weight should be on the CPU to compute on the CPU&quot;);
#endif // GGML_USE_CUBLAS

    switch (tensor-&gt;op) {
        case GGML_OP_DUP:
            {
                ggml_compute_forward_dup(params, tensor-&gt;src[0], tensor);
            } break;
        case GGML_OP_ADD:
            {
                ggml_compute_forward_add(params, tensor-&gt;src[0], tensor-&gt;src[1], tensor);
            } break;
        case GGML_OP_ADD1:
            {
                ggml_compute_forward_add1(params, tensor-&gt;src[0], tensor-&gt;src[1], tensor);
            } break;
        case GGML_OP_ACC:
            {
                ggml_compute_forward_acc(params, tensor-&gt;src[0], tensor-&gt;src[1], tensor);
            } break;
        case GGML_OP_SUB:
            {
                ggml_compute_forward_sub(params, tensor-&gt;src[0], tensor-&gt;src[1], tensor);
            } break;
        case GGML_OP_MUL:
            {
                ggml_compute_forward_mul(params, tensor-&gt;src[0], tensor-&gt;src[1], tensor);
            } break;
        case GGML_OP_DIV:
            {
                ggml_compute_forward_div(params, tensor-&gt;src[0], tensor-&gt;src[1], tensor);
            } break;
            // Other cases...
            // -- snip --
    }
}
</code></pre>
<p>额外地，我们注意<code>ggml_compute_foward</code>的开头：如果使用了CUBLAS，那么就转而调用CUDA实现的算子（<code>ggml_cuda_compute_forward</code>）。</p>
<pre><code class="language-c++">static void ggml_compute_forward(struct ggml_compute_params * params, struct ggml_tensor * tensor) {
    GGML_ASSERT(params);

    if (tensor-&gt;op == GGML_OP_NONE) {
        return;
    }

#ifdef GGML_USE_CUBLAS
    bool skip_cpu = ggml_cuda_compute_forward(params, tensor);
    if (skip_cpu) {
        return;
    }
    // Make sure src[0] (weight for binary ops) is on CPU to avoid any weight transfer
    GGML_ASSERT((tensor-&gt;src[0] == NULL || tensor-&gt;src[0]-&gt;backend == GGML_BACKEND_CPU) &amp;&amp; &quot;weight should be on the CPU to compute on the CPU&quot;);
#endif // GGML_USE_CUBLAS

    switch (tensor-&gt;op) {
        case GGML_OP_DUP:
            {
                ggml_compute_forward_dup(params, tensor-&gt;src[0], tensor);
            } break;
            // Other cases...
            // -- snip --
    }
}
</code></pre>
<p>在<code>ggml_cuda_compute_forward</code>中，会根据<code>tensor-&gt;op</code>去调用具体的CUDA算子。</p>
<pre><code class="language-c++">bool ggml_cuda_compute_forward(struct ggml_compute_params * params, struct ggml_tensor * tensor) {
    if (!g_cublas_loaded) return false;

    ggml_cuda_func_t func;
    const bool src0_on_device = tensor-&gt;src[0] != nullptr &amp;&amp; (tensor-&gt;src[0]-&gt;backend != GGML_BACKEND_CPU);
    const bool any_on_device = tensor-&gt;backend == GGML_BACKEND_GPU || src0_on_device
        || (tensor-&gt;src[1] != nullptr &amp;&amp; tensor-&gt;src[1]-&gt;backend == GGML_BACKEND_GPU);

    // when src0 (weights) is not on device, we compute on CPU with sparsity
    if (!src0_on_device &amp;&amp; (tensor-&gt;op == GGML_OP_MUL_MAT_SPARSE || tensor-&gt;op == GGML_OP_AXPY)
        || !any_on_device &amp;&amp; tensor-&gt;op != GGML_OP_MUL_MAT) {
        return false;
    }

    if (tensor-&gt;op == GGML_OP_MUL_MAT) {
        if (tensor-&gt;src[0]-&gt;ne[3] != tensor-&gt;src[1]-&gt;ne[3]) {
#ifndef NDEBUG
            fprintf(stderr, &quot;%s: cannot compute %s: src0-&gt;ne[3] = %d, src1-&gt;ne[3] = %d - fallback to CPU\n&quot;, __func__, tensor-&gt;name, tensor-&gt;src[0]-&gt;ne[3], tensor-&gt;src[1]-&gt;ne[3]);
#endif
            return false;
        }
    }

    switch (tensor-&gt;op) {
        case GGML_OP_REPEAT:
            func = ggml_cuda_repeat;
            break;
        case GGML_OP_GET_ROWS:
            func = ggml_cuda_get_rows;
            break;
        case GGML_OP_DUP:
            func = ggml_cuda_dup;
            break;
        case GGML_OP_ADD:
            func = ggml_cuda_add;
            break;
        case GGML_OP_MUL:
            func = ggml_cuda_mul;
            break;
        case GGML_OP_UNARY:
            switch (ggml_get_unary_op(tensor)) {
                case GGML_UNARY_OP_GELU:
                    func = ggml_cuda_gelu;
                    break;
                case GGML_UNARY_OP_SILU:
                    func = ggml_cuda_silu;
                    break;
                case GGML_UNARY_OP_RELU:
                    func = ggml_cuda_relu;
                    break;
                default:
                    return false;
            } break;
        case GGML_OP_NORM:
            func = ggml_cuda_norm;
            break;
        case GGML_OP_RMS_NORM:
            func = ggml_cuda_rms_norm;
            break;
        case GGML_OP_MUL_MAT:
            if (!any_on_device &amp;&amp; !ggml_cuda_can_mul_mat(tensor-&gt;src[0], tensor-&gt;src[1], tensor)) {
                return false;
            }
            func = ggml_cuda_mul_mat;
            break;
        case GGML_OP_MUL_MAT_SPARSE:
            if (!src0_on_device &amp;&amp; !ggml_cuda_can_mul_mat(tensor-&gt;src[0], tensor-&gt;src[1], tensor)) {
                return false;
            }
            func = ggml_cuda_mul_mat_sparse;
            break;
        case GGML_OP_AXPY:
            func = ggml_cuda_axpy;
            break;
        // Other cases...
        // -- snip --
        default:
            return false;
    }

    if (params-&gt;ith != 0) {
        return true;
    }
    if (params-&gt;type == GGML_TASK_INIT || params-&gt;type == GGML_TASK_FINALIZE) {
        return true;
    }
    func(tensor-&gt;src[0], tensor-&gt;src[1], tensor);

    // CUDA_CHECK(cudaDeviceSynchronize());

    return true;
}
</code></pre>
<p>以<code>ggml_cuda_mul_mat_sparse</code>为例，其会根据类型继续下调。</p>
<pre><code class="language-c++">static void ggml_cuda_mul_mat_sparse(const ggml_tensor * src0, const ggml_tensor * src1, ggml_tensor * dst) {
    GGML_ASSERT(dst-&gt;src[2] != NULL &amp;&amp; &quot;dst-&gt;src[2] must be present for sparse matrix multiplication&quot;);
    if (src1-&gt;ne[1] == 1 &amp;&amp; src0-&gt;ne[0] % GGML_CUDA_DMMV_X == 0) {
        switch(src0-&gt;type) {
            case GGML_TYPE_F16:
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_vec_sparse_dequantized, false);
                break;
            case GGML_TYPE_Q4_0:
                ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_vec_sparse_q, true);
                break;
            default:
                GGML_ASSERT(false &amp;&amp; &quot;unsupported type for sparse matrix multiplication&quot;);
        }
    } else {
        ggml_cuda_op_mul_mat(src0, src1, dst, ggml_cuda_op_mul_mat_batch_sparse, false);
    }
}
</code></pre>
<p>至此，后续便能调用到具体负责计算的算子。模型加载以后，计算图的构建一直到算子的调用的大致流程也结束了。</p>
<h2 id="支持-️">支持 ☕️</h2>
<p>如果发现内容有纰漏或错误，可以通过邮箱hangyu.yuan@qq.com联系我或直接在下方评论告诉我，谢谢。<br>
我的<a href="https://github.com/Yuan-Allen">GitHub主页</a>。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[LeetCode刷题记录（二叉树篇）]]></title>
        <id>https://alleny.xyz/post/leetcode-binary-tree/</id>
        <link href="https://alleny.xyz/post/leetcode-binary-tree/">
        </link>
        <updated>2024-09-25T02:12:10.000Z</updated>
        <summary type="html"><![CDATA[<p>LeetCode刷题记录（二叉树篇），个人向。<br>
这部分涉及频繁的指针操作，因此专精C++来做题。</p>
]]></summary>
        <content type="html"><![CDATA[<p>LeetCode刷题记录（二叉树篇），个人向。<br>
这部分涉及频繁的指针操作，因此专精C++来做题。</p>
<!-- more -->
<h2 id="144-145-94">[144]、[145]、[94]</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p>题目描述就不放了，就是二叉树的前中后序遍历。考察最基本的数据结构了解程度，无难度。这里放几种不同的实现方式。</p>
<h3 id="递归遍历">递归遍历</h3>
<p>前序遍历。</p>
<pre><code class="language-c++">class Solution {
 public:
  void traverse(TreeNode* cur, vector&lt;int&gt;&amp; res) {
    if (!cur) {
      return;
    }
    res.push_back(cur-&gt;val);
    traverse(cur-&gt;left, res);
    traverse(cur-&gt;right, res);
  }

  vector&lt;int&gt; preorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    traverse(root, res);
    return res;
  }
};
</code></pre>
<p>后序遍历。</p>
<pre><code class="language-c++">class Solution {
 public:
  void traverse(TreeNode* cur, vector&lt;int&gt;&amp; res) {
    if (!cur) {
      return;
    }
    traverse(cur-&gt;left, res);
    traverse(cur-&gt;right, res);
    res.push_back(cur-&gt;val);
  }

  vector&lt;int&gt; postorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    traverse(root, res);
    return res;
  }
};
</code></pre>
<p>中序遍历。</p>
<pre><code class="language-c++">class Solution {
 public:
  void traverse(TreeNode* cur, vector&lt;int&gt;&amp; res) {
    if (!cur) {
      return;
    }
    traverse(cur-&gt;left, res);
    res.push_back(cur-&gt;val);
    traverse(cur-&gt;right, res);
  }

  vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    vector&lt;int&gt; res;
    traverse(root, res);
    return res;
  }
};
</code></pre>
<p>三种遍历的递归写法代码基本一样，改下<code>traverse</code>里面顺序即可。</p>
<h3 id="迭代遍历">迭代遍历</h3>
<p>前序遍历。使用栈来存放节点。<br>
注意要先入右节点再入左节点，这样左节点会先出栈，才符合前序遍历顺序。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; preorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (!root) return result;
    st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      result.push_back(cur-&gt;val);
      if (cur-&gt;right) st.push(cur-&gt;right);
      if (cur-&gt;left) st.push(cur-&gt;left);
    }
    return result;
  }
};
</code></pre>
<p>后序遍历。和前序遍历类似。<br>
为了满足后续遍历的顺序，我们可以交换左右节点入栈的顺序（即先入左节点再入右节点），最后再把结果反转一下顺序。<br>
这样一来，原本前序遍历为<strong>中左右</strong>，交换入栈顺序变成<strong>中右左</strong>，结果反转后变成<strong>左右中</strong>。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; postorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (!root) return result;
    st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      result.push_back(cur-&gt;val);
      if (cur-&gt;left) st.push(cur-&gt;left);
      if (cur-&gt;right) st.push(cur-&gt;right);
    }
    reverse(result.begin(), result.end());
    return result;
  }
};
</code></pre>
<p>中序遍历会更麻烦些。在前序遍历中，当前节点访问过就可以丢掉了，但是在中序遍历中我们需要把当前节点先入栈存起来，并尽量的先往左遍历，直到遍历到头再尝试弹栈并往右移动。<br>
注意在后序遍历中，我们通过结果反转的方式巧妙规避了这些问题，但中序遍历就不行了。<br>
在写代码时请注意在空节点是否入栈上达成统一意见（以防止写出bug），本人给出的是空节点不入栈的写法。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    TreeNode* cur = root;
    while (cur || !st.empty()) {
      if (cur) {
        st.push(cur);
        cur = cur-&gt;left;
      } else {
        cur = st.top();
        st.pop();
        result.push_back(cur-&gt;val);
        cur = cur-&gt;right;
      }
    }
    return result;
  }
};
</code></pre>
<h3 id="统一迭代法">统一迭代法</h3>
<p>在前面的迭代方法中，前中后序的写法都不一样，没有做到像递归遍历一样的稍微改下代码顺序即可。因此，对于非递归的方法，也有统一的写法，可做到稍微改下代码顺序即可更改遍历顺序。<br>
统一迭代法的关键是，利用了空指针来做标记，即访问到的节点后会再跟一个空指针入栈，弹栈时遇到空指针才把后面的节点进行处理（加入结果集）。<strong>即一个节点实际上会入栈出栈两次，第一次（入栈不带空指针）代表访问到（仅仅是路过），第二次（入栈后带空指针）才代表要处理该节点。</strong><br>
于是，我们可以很容易得到三种遍历的写法。<br>
前序遍历。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; preorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (root) st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      if (cur) {
        if (cur-&gt;right) st.push(cur-&gt;right);
        if (cur-&gt;left) st.push(cur-&gt;left);
        st.push(cur);
        st.push(nullptr);
      } else {
        result.push_back(st.top()-&gt;val);
        st.pop();
      }
    }
    return result;
  }
};
</code></pre>
<p>后序遍历。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; postorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (root) st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      if (cur) {
        st.push(cur);
        st.push(nullptr);
        if (cur-&gt;right) st.push(cur-&gt;right);
        if (cur-&gt;left) st.push(cur-&gt;left);
      } else {
        result.push_back(st.top()-&gt;val);
        st.pop();
      }
    }
    return result;
  }
};
</code></pre>
<p>中序遍历。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; inorderTraversal(TreeNode* root) {
    stack&lt;TreeNode*&gt; st;
    vector&lt;int&gt; result;
    if (root) st.push(root);
    while (!st.empty()) {
      TreeNode* cur = st.top();
      st.pop();
      if (cur) {
        if (cur-&gt;right) st.push(cur-&gt;right);
        st.push(cur);
        st.push(nullptr);
        if (cur-&gt;left) st.push(cur-&gt;left);
      } else {
        result.push_back(st.top()-&gt;val);
        st.pop();
      }
    }
    return result;
  }
};
</code></pre>
<h2 id="102-binary-tree-level-order-traversal">[102] Binary Tree Level Order Traversal</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/description/">题目描述</a>。<br>
二叉树的层序遍历，也属于数据结构的基本操作。<br>
层序遍历其实就相当于图论的广度优先搜索。只不过，这道题的返回类型是二维<code>vector</code>，即要求把每一层的节点单独作为一个<code>vector&lt;int&gt;</code>分出来，因此我们在内部嵌套一个循环来专门处理某一层的节点。否则，我们只保留最外层的<code>while</code>循环即可（不关心每层的节点从什么地方开始和结束，即退化到广度优先搜索）。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;vector&lt;int&gt;&gt; levelOrder(TreeNode* root) {
    vector&lt;vector&lt;int&gt;&gt; result;
    if (!root) {
      return result;
    }

    queue&lt;TreeNode*&gt; q;
    q.push(root);

    while (!q.empty()) {
      int level_width = q.size();
      vector&lt;int&gt; cur_level;
      while (level_width-- &gt; 0) {
        TreeNode* cur = q.front();
        q.pop();
        cur_level.push_back(cur-&gt;val);
        if (cur-&gt;left) {
          q.push(cur-&gt;left);
        }
        if (cur-&gt;right) {
          q.push(cur-&gt;right);
        }
      }
      result.push_back(cur_level);
    }

    return result;
  }
};
</code></pre>
<h2 id="226-invert-binary-tree">[226] Invert Binary Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/invert-binary-tree/description/">题目描述</a>。<br>
之前讲了很多种遍历方法，随便选一种用，遍历的同时交换当前节点的左右儿子即可。这里我选用的是递归前序遍历。<br>
需要注意的是，如果选用的是递归中序遍历，两次<code>traversal</code>都要对<code>cur-&gt;left</code>进行，因为左右儿子在中间被交换了。</p>
<pre><code class="language-c++">class Solution {
 public:
  void traversal(TreeNode* cur) {
    if (!cur) {
      return;
    }
    TreeNode* tmp = cur-&gt;left;
    cur-&gt;left = cur-&gt;right;
    cur-&gt;right = tmp;
    traversal(cur-&gt;left);
    traversal(cur-&gt;right);
  }
  TreeNode* invertTree(TreeNode* root) {
    traversal(root);
    return root;
  }
};
</code></pre>
<h2 id="101-symmetric-tree">[101] Symmetric Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/symmetric-tree/description/">题目描述</a>。<br>
同时遍历根节点的左右子树，遍历的同时进行比较即可。注意左子树的<code>left</code>和右子树的<code>right</code>比较，左子树的<code>right</code>和右子树的<code>left</code>比较。<br>
这里使用的是递归的写法。实际上，用队列或者栈等等也可以有不递归的写法（迭代法）。具体来说，就是把<code>left_cur-&gt;left, right_cur-&gt;right</code>放进容器中，<code>left_cur-&gt;right, right_cur-&gt;left</code>放进容器中，然后成对从容器中取元素，进行判断即可。具体可见这篇<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0101.%E5%AF%B9%E7%A7%B0%E4%BA%8C%E5%8F%89%E6%A0%91.md">solution</a>。</p>
<pre><code class="language-c++">class Solution {
 public:
  bool traversal(TreeNode* left_cur, TreeNode* right_cur) {
    if (!left_cur || !right_cur) {
      if (left_cur == right_cur) {
        return true;
      } else {
        return false;
      }
    }

    if (left_cur-&gt;val != right_cur-&gt;val) {
      return false;
    }

    return traversal(left_cur-&gt;left, right_cur-&gt;right) &amp;&amp;
           traversal(left_cur-&gt;right, right_cur-&gt;left);
  }

  bool isSymmetric(TreeNode* root) {
    if (!root) {
      return true;
    }

    return traversal(root-&gt;left, root-&gt;right);
  }
};
</code></pre>
<h2 id="104-maximum-depth-of-binary-tree">[104] Maximum Depth of Binary Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/">题目描述</a>。<br>
比较闲就顺手写了非递归层序和递归前序的两种写法。事实上这道题写法应该很多，要做的就只是在遍历的同时记录一下深度即可。在这里的话，我选择在非递归层序遍历时用空指针记录一层的结束，然后直接<code>++max_depth</code>；在递归前序遍历中我选择记录<code>cur_level</code>并看条件更新<code>max_level</code>。</p>
<pre><code class="language-c++">class Solution {
 public:
  int maxDepthLevel(TreeNode* root) {
    if (!root) {
      return 0;
    }

    int max_depth = 0;
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    q.push(nullptr);
    while (!q.empty()) {
      TreeNode* cur = q.front();
      q.pop();
      if (!cur) {
        ++max_depth;
        if (!q.empty()) {
          // Not the last level
          q.push(nullptr);
        }
      } else {
        if (cur-&gt;left) {
          q.push(cur-&gt;left);
        }
        if (cur-&gt;right) {
          q.push(cur-&gt;right);
        }
      }
    }
    return max_depth;
  }

  void traversal(TreeNode* cur, int cur_level, int&amp; max_level) {
    if (!cur) {
      return;
    }
    cur_level += 1;
    max_level = cur_level &gt; max_level ? cur_level : max_level;
    traversal(cur-&gt;left, cur_level, max_level);
    traversal(cur-&gt;right, cur_level, max_level);
  }

  int maxDepth(TreeNode* root) {
    int max_level = 0;
    traversal(root, 0, max_level);
    return max_level;
  }
};
</code></pre>
<h2 id="111-minimum-depth-of-binary-tree">[111] Minimum Depth of Binary Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/minimum-depth-of-binary-tree/description/">题目描述</a>。<br>
在<a href="#104-maximum-depth-of-binary-tree">104</a>的基础上稍加改动即可。在遍历的时候，遇到当前节点的左右儿子都是空指针，说明遇到叶子节点，就可以尝试更新<code>min_level</code>了。</p>
<pre><code class="language-c++">class Solution {
 public:
  void traversal(TreeNode* cur, int cur_level, int&amp; min_level) {
    if (!cur) {
      return;
    }
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right) {
      min_level = cur_level &lt; min_level ? cur_level : min_level;
    }
    traversal(cur-&gt;left, cur_level + 1, min_level);
    traversal(cur-&gt;right, cur_level + 1, min_level);
  }

  int minDepth(TreeNode* root) {
    if (!root) {
      return 0;
    }

    int min_level = __INT_MAX__;
    traversal(root, 1, min_level);
    return min_level;
  }
};
</code></pre>
<h2 id="222-count-complete-tree-nodes">[222] Count Complete Tree Nodes</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">题目描述</a>。<br>
往下遍历的过程中一定会遇到满二叉树，对于满二叉树可以用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mn>2</mn><mi>h</mi></msup><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">2^h - 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.932438em;vertical-align:-0.08333em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">h</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span>的公式快速计算数量。可以用向左遍历和向右遍历的深度是否一致来判断当前子树是否为满二叉树，如不是，则往左右子树继续递归（后序遍历）即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  int countNodes(TreeNode* root) {
    if (!root) {
      return 0;
    }

    TreeNode* left = root-&gt;left;
    TreeNode* right = root-&gt;right;
    int left_depth = 0;
    int right_depth = 0;
    while (left) {
      left = left-&gt;left;
      left_depth += 1;
    }
    while (right) {
      right = right-&gt;right;
      right_depth += 1;
    }
    if (left_depth == right_depth) {
      return (2 &lt;&lt; left_depth) - 1;
    }

    return countNodes(root-&gt;left) + countNodes(root-&gt;right) + 1;
  }
};
</code></pre>
<h2 id="110-balanced-binary-tree">[110] Balanced Binary Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/balanced-binary-tree/description/">题目描述</a>。<br>
使用后序遍历获取节点高度，同时使用-1来表示子树不平衡。在遍历的同时比较左右子树的高度，如果高度差值绝对值大于1则返回-1即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  int getHeight(TreeNode* cur) {
    if (!cur) {
      return 0;
    }

    int left_height = getHeight(cur-&gt;left);
    if (left_height &lt; 0) {
      return -1;
    }
    int right_height = getHeight(cur-&gt;right);
    if (right_height &lt; 0) {
      return -1;
    }

    if (abs(left_height - right_height) &gt; 1) {
      return -1;
    }

    return max(left_height, right_height) + 1;
  }

  bool isBalanced(TreeNode* root) { return getHeight(root) &gt;= 0; }
};
</code></pre>
<h2 id="257-binary-tree-paths">[257] Binary Tree Paths</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p>前序遍历的同时，记录当前走过的路径（<code>cur_path</code>），在遇到叶子节点时再存入<code>all_path</code>即可。由于题目要求字符串格式的路径，所以增加了<code>pathToString</code>用来把<code>vector&lt;TreeNode*&gt;</code>转为<code>string</code>。</p>
<pre><code class="language-c++">class Solution {
 public:
  string pathToString(vector&lt;TreeNode*&gt; path) {
    string s;
    for (TreeNode* node : path) {
      s.append(to_string(node-&gt;val));
      s.append(&quot;-&gt;&quot;);
    }
    s.erase(s.end() - 2, s.end());
    return s;
  }

  void traverse(TreeNode* cur, vector&lt;string&gt;&amp; all_paths,
                vector&lt;TreeNode*&gt; cur_path) {
    cur_path.push_back(cur);
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right) {
      all_paths.push_back(pathToString(cur_path));
      return;
    }
    if (cur-&gt;left) {
      traverse(cur-&gt;left, all_paths, cur_path);
    }
    if (cur-&gt;right) {
      traverse(cur-&gt;right, all_paths, cur_path);
    }
  }

  vector&lt;string&gt; binaryTreePaths(TreeNode* root) {
    vector&lt;string&gt; result;
    if (!root) {
      return result;
    }
    vector&lt;TreeNode*&gt; cur_path;
    traverse(root, result, cur_path);
    return result;
  }
};
</code></pre>
<h2 id="404-sum-of-left-leaves">[404] Sum of Left Leaves</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/sum-of-left-leaves/description/">题目描述</a>。<br>
无什么难度的题目。遍历的同时使用一个参数<code>left_falg</code>来记录当前节点是否是其父节点的左儿子即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  int traverse(TreeNode* cur, bool left_flag) {
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right) {
      return left_flag ? cur-&gt;val : 0;
    }

    int sum = 0;
    if (cur-&gt;left) {
      sum += traverse(cur-&gt;left, true);
    }
    if (cur-&gt;right) {
      sum += traverse(cur-&gt;right, false);
    }
    return sum;
  }

  int sumOfLeftLeaves(TreeNode* root) {
    if (!root) {
      return 0;
    }
    return traverse(root, false);
  }
};
</code></pre>
<h2 id="513-find-bottom-left-tree-value">[513] Find Bottom Left Tree Value</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/find-bottom-left-tree-value/description/">题目描述</a>。<br>
很容易想到使用层序遍历，记录最后一层最左边的节点即可。这里也写了一个递归的写法，在遍历的同时记录当前深度，由于是前序遍历（先左后右），所以在第一次到达新的深度时记录节点即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  void traversal(TreeNode* cur, int cur_level, int&amp; left_most_val,
                 int&amp; most_level) {
    if (cur_level &gt; most_level) {
      left_most_val = cur-&gt;val;
      most_level = cur_level;
    }
    if (cur-&gt;left) {
      traversal(cur-&gt;left, cur_level + 1, left_most_val, most_level);
    }
    if (cur-&gt;right) {
      traversal(cur-&gt;right, cur_level + 1, left_most_val, most_level);
    }
  }

  int findBottomLeftValueRecursive(TreeNode* root) {
    int left_most_val = 0;
    int most_level = 0;
    if (!root) {
      return left_most_val;
    }

    traversal(root, 1, left_most_val, most_level);

    return left_most_val;
  }

  int findBottomLeftValue(TreeNode* root) {
    int left_most_val = 0;
    if (!root) {
      return left_most_val;
    }
    queue&lt;TreeNode*&gt; q;
    q.push(root);
    while (!q.empty()) {
      int width = q.size();
      for (int i = 0; i &lt; width; ++i) {
        TreeNode* cur = q.front();
        q.pop();
        if (i == 0) {
          left_most_val = cur-&gt;val;
        }
        if (cur-&gt;left) {
          q.push(cur-&gt;left);
        }
        if (cur-&gt;right) {
          q.push(cur-&gt;right);
        }
      }
    }
    return left_most_val;
  }
};
</code></pre>
<h2 id="112-path-sum">[112] Path Sum</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/path-sum/description/">题目描述</a>。<br>
在遍历的同时记录一下当前<code>cur_sum</code>，在遇到叶子节点时再判断一下是否等于<code>target</code>即可。<br>
也可以换成把一个参数递减一直减到0而不是求和然后判断是否相等，这样代码可以更简洁，可参考<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0112.%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C.md">这篇</a>。<br>
也可以用迭代的方式，使用<code>pair&lt;TreeNode*, int&gt;</code>来存储节点指针和对应的路径数值即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  bool traversal(TreeNode* cur, int cur_sum, int target) {
    cur_sum += cur-&gt;val;
    bool result = false;
    if (!cur-&gt;left &amp;&amp; !cur-&gt;right &amp;&amp; cur_sum == target) {
      return true;
    }
    if (cur-&gt;left) {
      result |= traversal(cur-&gt;left, cur_sum, target);
    }
    if (!result &amp;&amp; cur-&gt;right) {
      result |= traversal(cur-&gt;right, cur_sum, target);
    }
    return result;
  }
  bool hasPathSum(TreeNode* root, int targetSum) {
    if (!root) {
      return false;
    }
    return traversal(root, 0, targetSum);
  }
};
</code></pre>
<h2 id="106-construct-binary-tree-from-inorder-and-postorder-traversal">[106] Construct Binary Tree from Inorder and Postorder Traversal</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-inorder-and-postorder-traversal/description/">题目描述</a>。<br>
后序遍历的最后一个一定是根节点。利用这个特性，我们使用该节点在中序遍历中划分左右子树，然后再依次在左右子树中递归即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* traversal(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder,
                      int inorder_begin, int inorder_end, int postorder_begin,
                      int postorder_end) {
    if (postorder_begin == postorder_end) {
      return nullptr;
    }
    int cur_val = postorder[postorder_end - 1];
    TreeNode* cur = new TreeNode(cur_val);
    if (postorder_begin + 1 &lt; postorder_end) {  // early stop
      for (int i = inorder_begin; i &lt; inorder_end; ++i) {
        if (inorder[i] == cur_val) {
          cur-&gt;left =
              traversal(inorder, postorder, inorder_begin, i, postorder_begin,
                        postorder_begin + i - inorder_begin);
          cur-&gt;right =
              traversal(inorder, postorder, i + 1, inorder_end,
                        postorder_begin + i - inorder_begin, postorder_end - 1);

          break;
        }
      }
    }

    return cur;
  }

  TreeNode* buildTree(vector&lt;int&gt;&amp; inorder, vector&lt;int&gt;&amp; postorder) {
    int size = inorder.size();
    TreeNode* root = traversal(inorder, postorder, 0, size, 0, size);
    return root;
  }
};
</code></pre>
<h2 id="654-maximum-binary-tree">[654] Maximum Binary Tree</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/maximum-binary-tree/description/">题目描述</a>。<br>
递归的同时找一下当前<code>index</code>范围内的最大值作为当前<code>TreeNode</code>，然后递归找<code>[left_index, max_index)</code>和<code>[max_index + 1, right_index)</code>即可，没什么难度。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* traversal(vector&lt;int&gt;&amp; nums, int left_index, int right_index) {
    if (right_index - left_index == 1) {
      return new TreeNode(nums[left_index]);
    }

    int max_index = left_index;
    int max_val = -1;
    for (int i = left_index; i &lt; right_index; ++i) {
      if (nums[i] &gt; max_val) {
        max_val = nums[i];
        max_index = i;
      }
    }
    TreeNode* cur = new TreeNode(max_val);
    if (max_index &gt; left_index) {
      cur-&gt;left = traversal(nums, left_index, max_index);
    }
    if (right_index &gt; max_index + 1) {
      cur-&gt;right = traversal(nums, max_index + 1, right_index);
    }
    return cur;
  }
  TreeNode* constructMaximumBinaryTree(vector&lt;int&gt;&amp; nums) {
    return traversal(nums, 0, nums.size());
  }
};
</code></pre>
<h2 id="617-merge-two-binary-trees">[617] Merge Two Binary Trees</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/merge-two-binary-trees/description/">题目描述</a>。<br>
同时遍历两棵树即可，没什么难度。<br>
这里复用了两棵树的节点。如果不想复用也可一路创建新节点即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* mergeTrees(TreeNode* root1, TreeNode* root2) {
    if (!root1) return root2;
    if (!root2) return root1;

    TreeNode* cur = new TreeNode(root1-&gt;val + root2-&gt;val);
    cur-&gt;left = mergeTrees(root1-&gt;left, root2-&gt;left);
    cur-&gt;right = mergeTrees(root1-&gt;right, root2-&gt;right);
    return cur;
  }
};
</code></pre>
<h2 id="700-search-in-a-binary-search-tree">[700] Search in a Binary Search Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/search-in-a-binary-search-tree/description/">题目描述</a>。<br>
二叉搜索树的最基本操作，无难度。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* searchBST(TreeNode* root, int val) {
    TreeNode* cur = root;
    while (cur) {
      if (cur-&gt;val == val) {
        return cur;
      }
      if (cur-&gt;val &lt; val) {
        cur = cur-&gt;right;
      } else {
        cur = cur-&gt;left;
      }
    }
    return cur;
  }
};
</code></pre>
<h2 id="98-validate-binary-search-tree">[98] Validate Binary Search Tree</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/validate-binary-search-tree/description/">题目描述</a>。<br>
写了两种解法。一种是自己写的前序遍历，遍历过程传入<code>left_bound</code>和<code>right_bound</code>，把当前节点的左右儿子与当前节点和对应bound做比较，然后递归遍历其左右子树。<br>
另一种解法是写完后看到的网上的解法，使用的是<strong>中序遍历</strong>，其核心是使用了<strong>二叉搜索树中序遍历输出的节点数值是有序序列</strong>的性质。通过中序遍历的这个性质，我们只需要记录一个<code>pre</code>即当前节点左边的节点（也可以只记录数值，但是要注意如果题目出现<code>long long</code>类型的最小值就没法初始化成更小了，所以记录节点更好），然后只比较当前节点的数值和这个<code>pre</code>的数值大小即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  bool traversal(TreeNode* cur, long long left_bound, long long right_bound) {
    if (!cur) {
      return true;
    }
    if (cur-&gt;left &amp;&amp;
        (cur-&gt;left-&gt;val &gt;= cur-&gt;val || cur-&gt;left-&gt;val &lt;= left_bound)) {
      return false;
    }
    if (cur-&gt;right &amp;&amp;
        (cur-&gt;right-&gt;val &lt;= cur-&gt;val || cur-&gt;right-&gt;val &gt;= right_bound)) {
      return false;
    }
    return traversal(cur-&gt;left, left_bound, cur-&gt;val) &amp;&amp;
           traversal(cur-&gt;right, cur-&gt;val, right_bound);
  }

  TreeNode* pre = nullptr;

  bool isValidBST(TreeNode* root) {
    // return traversal(root, -__LONG_LONG_MAX__ - 1, __LONG_LONG_MAX__);
    if (!root) {
      return true;
    }
    bool result = isValidBST(root-&gt;left);
    if (pre &amp;&amp; root-&gt;val &lt;= pre-&gt;val) {
      return false;
    } else {
      pre = root;
    }
    result &amp;= isValidBST(root-&gt;right);
    return result;
  }
};
</code></pre>
<h2 id="530-minimum-absolute-difference-in-bst">[530] Minimum Absolute Difference in BST</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/minimum-absolute-difference-in-bst/description/">题目描述</a>。<br>
参照上一题，我们已经知道了<strong>二叉搜索树中序遍历输出的节点数值是有序序列</strong>。通过这个性质，我们只需在这个有序序列中计算当前节点和上一个节点的差值，然后记录最小值即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* pre = nullptr;
  int min_abs_diff = __INT_MAX__;
  int getMinimumDifference(TreeNode* root) {
    if (!root) {
      return false;
    }
    getMinimumDifference(root-&gt;left);
    if (pre &amp;&amp; root-&gt;val - pre-&gt;val &lt; min_abs_diff) {
      min_abs_diff = root-&gt;val - pre-&gt;val;
    }
    pre = root;
    getMinimumDifference(root-&gt;right);
    return min_abs_diff;
  }
};
</code></pre>
<h2 id="501-find-mode-in-binary-search-tree">[501] Find Mode in Binary Search Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/find-mode-in-binary-search-tree/description/">题目描述</a>。<br>
和之前一样的思路，采用中序遍历。使用<code>pre &amp;&amp; cur-&gt;val != pre-&gt;val</code>来判断是应该把<code>cut_count</code>置1还是加1。然后，对比<code>cur_count</code>与<code>max_count</code>，来对结果<code>result</code>进行更新。</p>
<pre><code class="language-c++">class Solution {
 public:
  vector&lt;int&gt; result;
  TreeNode* pre = nullptr;
  int max_count = 0;
  int cur_count = 0;

  void traversal(TreeNode* cur) {
    if (!cur) {
      return;
    }

    traversal(cur-&gt;left);
    if (pre &amp;&amp; cur-&gt;val != pre-&gt;val) {
      cur_count = 1;
    } else {
      cur_count += 1;
    }
    if (cur_count == max_count) {
      result.push_back(cur-&gt;val);
    } else if (cur_count &gt; max_count) {
      result.clear();
      result.push_back(cur-&gt;val);
      max_count = cur_count;
    }
    pre = cur;
    traversal(cur-&gt;right);
  }

  vector&lt;int&gt; findMode(TreeNode* root) {
    if (!root) {
      return result;
    }
    traversal(root);
    return result;
  }
};
</code></pre>
<h2 id="236-lowest-common-ancestor-of-a-binary-tree">[236] Lowest Common Ancestor of a Binary Tree</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/description/">题目描述</a>。<br>
一开始写了一个naive的写法：遍历树，在遍历的同时记录路径，以此分别找到到达<code>p</code>和<code>q</code>的路径，然后再把两个路径进行对比，找到路径出现不一致的地方，其最后一个一致的节点就是最近公共祖先了。但写完发现这种解法效率较低。<br>
实际上我们没有必要记录路径。我们只需要在遍历的同时，遇到<code>p</code>和<code>q</code>就返回（否则遍历到底然后返回空指针）。使用后序遍历，我们可查看其左右子树是否遍历到了<code>p</code>或<code>q</code>，若是则当前节点就是最近公共祖先。若<code>left</code>和<code>right</code>有一个为空，则返回另一个即可（一是传递结果，二是<code>p</code>或<code>q</code>可能本身是公共祖先）。通过这种方式我们避免了路径的记录，大大提高了效率。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) {
      return nullptr;
    }
    if (root == p || root == q) {
      return root;
    }
    TreeNode* left = lowestCommonAncestor(root-&gt;left, p, q);
    TreeNode* right = lowestCommonAncestor(root-&gt;right, p, q);
    if (left &amp;&amp; right) {
      return root;
    }
    if (!left) {
      return right;
    }
    return left;
  }
};
</code></pre>
<h2 id="235-lowest-common-ancestor-of-a-binary-search-tree">[235] Lowest Common Ancestor of a Binary Search Tree</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/description/">题目描述</a>。<br>
利用二叉搜索树有序的性质，直接遍历，找到值处于<code>[p, q]</code>（或<code>[q, p]</code>）区间的节点即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* lowestCommonAncestor(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root) {
      return nullptr;
    }
    if ((p-&gt;val &lt;= root-&gt;val &amp;&amp; q-&gt;val &gt;= root-&gt;val) ||
        p-&gt;val &gt;= root-&gt;val &amp;&amp; q-&gt;val &lt;= root-&gt;val) {
      return root;
    }
    if (p-&gt;val &lt; root-&gt;val) {
      return lowestCommonAncestor(root-&gt;left, p, q);
    } else {
      return lowestCommonAncestor(root-&gt;right, p, q);
    }
  }
};
</code></pre>
<h2 id="701-insert-into-a-binary-search-tree">[701] Insert into a Binary Search Tree</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/description/">题目描述</a>。<br>
一路查找，找到对应空指针的位置插入即可。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* insertIntoBST(TreeNode* root, int val) {
    if (!root) {
      return new TreeNode(val);
    }
    TreeNode* cur = root;
    while (true) {
      if (val &gt; cur-&gt;val) {
        if (cur-&gt;right) {
          cur = cur-&gt;right;
        } else {
          cur-&gt;right = new TreeNode(val);
          break;
        }
      } else {
        if (cur-&gt;left) {
          cur = cur-&gt;left;
        } else {
          cur-&gt;left = new TreeNode(val);
          break;
        }
      }
    }
    return root;
  }
};
</code></pre>
<h2 id="450-delete-node-in-a-bst">[450] Delete Node in a BST</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/delete-node-in-a-bst/description/">题目描述</a>。<br>
二叉搜索树的基本操作之一，但是有一定难度。要删除一个节点，我们肯定要先找到这个节点。这里分成了几种情况。</p>
<ul>
<li>该节点不存在。什么都不用干。</li>
<li>该节点只有左子树或右子树。把其左子树或右子树接到其父节点上即可（还要判断一下父节点是否存在以及该节点是其父节点的左孩子还是右孩子）。</li>
<li>该节点同时有左子树和右子树。可以找到其右子树的最左节点（也就是树里面值最接近该节点的比该节点大的节点）替换到该节点上。可以直接替换节点，但我这里写的是赋值的写法（<code>cur-&gt;val = right-&gt;val;</code>），然后再把这个原先的右子树最左（位置的）节点删掉。</li>
</ul>
<p>把右子树最左节点挪过来的方法只是解法之一，也可以把<code>cur-&gt;left</code>直接接到其右子树最左节点的左边，可参考<a href="https://github.com/youngyangyang04/leetcode-master/blob/master/problems/0450.%E5%88%A0%E9%99%A4%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B9.md">这篇solution</a>。但是个人感觉这样会使树的深度加深，太不优雅，所以不喜欢这种方式。总之二叉搜索树不是唯一的，解法也不是只有一种。<br>
此外，代码除了迭代还可使用递归的实现方式，同样可参考上面的solution，但递归显然没有迭代的方式性能高效。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* deleteNode(TreeNode* root, int key) {
    TreeNode* cur = root;
    TreeNode* pre = nullptr;

    // find
    while (cur &amp;&amp; key != cur-&gt;val) {
      pre = cur;
      if (key &lt; cur-&gt;val) {
        cur = cur-&gt;left;
      } else {
        cur = cur-&gt;right;
      }
    }
    if (!cur) {
      return root;
    }

    // simple cases
    if (!cur-&gt;left || !cur-&gt;right) {
      if (!pre) {
        // The root node is the target node
        root = cur-&gt;left ? cur-&gt;left : cur-&gt;right;
      } else {
        (pre-&gt;val &gt; cur-&gt;val ? pre-&gt;left : pre-&gt;right) =
            (cur-&gt;left ? cur-&gt;left : cur-&gt;right);
      }
      delete cur;
      return root;
    }

    // the target node has two children
    // find the left most node in the right subtree
    TreeNode* right = cur-&gt;right;
    pre = cur;
    while (right-&gt;left) {
      pre = right;
      right = right-&gt;left;
    }

    // get the value
    cur-&gt;val = right-&gt;val;

    // move the left most node found
    (pre-&gt;val &gt; right-&gt;val ? pre-&gt;left : pre-&gt;right) = right-&gt;right;
    delete right;

    return root;
  }
};
</code></pre>
<h2 id="669-trim-a-binary-search-tree">[669] Trim a Binary Search Tree</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/description/">题目描述</a>。<br>
Medium但是写起来意外的很简单。如果当前节点在范围外就对对应方向子树进行递归，如果在范围内就直接两端递归一下即可，没什么难度。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* trimBST(TreeNode* root, int low, int high) {
    if (!root) {
      return nullptr;
    }
    if (root-&gt;val &lt; low) {
      return trimBST(root-&gt;right, low, high);
    }
    if (root-&gt;val &gt; high) {
      return trimBST(root-&gt;left, low, high);
    }
    root-&gt;left = trimBST(root-&gt;left, low, high);
    root-&gt;right = trimBST(root-&gt;right, low, high);
    return root;
  }
};
</code></pre>
<h2 id="108-convert-sorted-array-to-binary-search-tree">[108] Convert Sorted Array to Binary Search Tree</h2>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/description/">题目描述</a>。<br>
数组已经是有序了，所以直接递归找区间中值二分即可，没什么难度。</p>
<pre><code class="language-c++">class Solution {
 public:
  TreeNode* buildTree(vector&lt;int&gt;&amp; nums, int left, int right) {
    if (left &gt;= right) {
      return nullptr;
    }
    // we can use `int mid = left + ((right - left) / 2);` instead to avoid
    // int overflow.
    int mid = (left + right) / 2;
    TreeNode* cur = new TreeNode(nums[mid]);
    cur-&gt;left = buildTree(nums, left, mid);
    cur-&gt;right = buildTree(nums, mid + 1, right);
    return cur;
  }

  TreeNode* sortedArrayToBST(vector&lt;int&gt;&amp; nums) {
    return buildTree(nums, 0, nums.size());
  }
};
</code></pre>
<h2 id="538-convert-bst-to-greater-tree">[538] Convert BST to Greater Tree</h2>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/convert-bst-to-greater-tree/description/">题目描述</a>。<br>
写出来代码异常简洁的Medium题。根据题目要求，使用反中序遍历（右中左）。在遍历过程中记录当前累加值<code>sum</code>，先算右边，右子树返回值累加到当前节点，再传到左子树去累加，最后把整个子树的累加值再传回父节点即可。<br>
注意遍历到空节点的时候直接返回<code>sum</code>，即可从累加过的值继续累加。</p>
<pre><code class="language-c++">class Solution {
 public:
  int traversal(TreeNode* cur, int sum) {
    if (!cur) {
      return sum;
    }
    cur-&gt;val += traversal(cur-&gt;right, sum);
    return traversal(cur-&gt;left, cur-&gt;val);
  }

  TreeNode* convertBST(TreeNode* root) {
    traversal(root, 0);
    return root;
  }
};
</code></pre>
<h2 id="总结">总结</h2>
<p>这一部分刷的题比较多。概括起来的话就是</p>
<ul>
<li>首先掌握二叉树的基本遍历方式，例如前中后序遍历和层序遍历，实现方式又分为递归法和迭代法，为了统一前中后序的迭代法实现方式又有统一迭代法。</li>
<li>大部分的题都只是对二叉树做遍历，然后在遍历的过程中记录和传递一些需要的中间数据即可。遍历的方式可根据题目要求来，迭代还是递归也可根据怎么实现方便怎么来。</li>
<li><a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal">[106] Construct Binary Tree from Inorder and Postorder Traversal</a>要求通过中序和后序遍历的结果来还原构造出二叉树。这里我们要利用后序遍历的最后一个节点一定是根节点的性质，然后对应到中序遍历的位置来分割左右子树，再回到后序遍历的部分找子树的根节点，两个遍历结果来回分割和查询。注意前序遍历和中序遍历的结果也可以用来唯一确定一颗二叉树，但是前序和后序一起却不行，因为没有中序遍历无法确定左右部分，也就是无法分割。</li>
<li>后面的题是关于二叉搜索树（BST）的。BST的查找和插入都很简单，但删除有一定难度，这里使用了其右子树的最左节点来替换要删除的节点（其同时有左右儿子的情况）。此外就是可以注意一下BST的中序遍历的结果是有序序列的性质，在某些题目中会很有用。</li>
</ul>
<h2 id="补充">补充</h2>
<h3 id="543-diameter-of-binary-tree">[543] Diameter of Binary Tree</h3>
<blockquote>
<p>难度：Easy<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/diameter-of-binary-tree/description/">题目描述</a>。<br>
任意一条路径可以看成是某一节点分别向左右儿子向下遍历的路径拼接得到，而这样的左右路径的长度分别就是左右子树的深度。<br>
因此，我们考虑后续遍历，统计各节点左右子树的深度，再比较深度之和来更新<code>maxLength</code>，便可得到答案。</p>
<pre><code class="language-c++">class Solution {
  public:
    int traverse(TreeNode *cur, int &amp;maxLengh) {
        if (cur == nullptr) {
            return 0;
        }

        int left = traverse(cur-&gt;left, maxLengh);
        int right = traverse(cur-&gt;right, maxLengh);
        maxLengh = max(maxLengh, left + right);
        return max(left, right) + 1;
    }

    int diameterOfBinaryTree(TreeNode *root) {
        int maxLength = 0;
        traverse(root, maxLength);
        return maxLength;
    }
};
</code></pre>
<h3 id="230-kth-smallest-element-in-a-bst">[230] Kth Smallest Element in a BST</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/description/">题目描述</a>。<br>
利用二叉搜索树中序遍历得到有序序列的性质，中序遍历到第<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.03148em;">k</span></span></span></span>个即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    int kthSmallest(TreeNode *root, int k) {
        stack&lt;TreeNode *&gt; st;
        TreeNode *cur = root;
        while (cur || !st.empty()) {
            if (cur) {
                st.push(cur);
                cur = cur-&gt;left;
            } else {
                cur = st.top();
                st.pop();
                if (--k == 0) {
                    break;
                }
                cur = cur-&gt;right;
            }
        }
        return cur-&gt;val;
    }
};
</code></pre>
<h3 id="199-binary-tree-right-side-view">[199] Binary Tree Right Side View</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/binary-tree-right-side-view/description/">题目描述</a>。<br>
层序遍历，取每层最后一个节点加入结果即可。</p>
<pre><code class="language-c++">class Solution {
  public:
    vector&lt;int&gt; rightSideView(TreeNode *root) {
        vector&lt;int&gt; result;
        TreeNode *cur = root;
        queue&lt;TreeNode *&gt; q;
        if (root) {
            q.push(root);
        }
        while (!q.empty()) {
            int size = q.size();
            for (int i = 0; i &lt; size; ++i) {
                cur = q.front();
                q.pop();
                if (cur-&gt;left) {
                    q.push(cur-&gt;left);
                }
                if (cur-&gt;right) {
                    q.push(cur-&gt;right);
                }
            }
            result.emplace_back(cur-&gt;val);
        }
        return result;
    }
};
</code></pre>
<h3 id="114-flatten-binary-tree-to-linked-list">[114] Flatten Binary Tree to Linked List</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/description/">题目描述</a>。<br>
容易想到的Naive方式是前序遍历一遍，再按照遍历的结果依次改指针即可。见<code>flattenNaive</code>。<br>
为了把空间复杂度优化到<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>O</mi><mo>(</mo><mn>1</mn><mo>)</mo></mrow><annotation encoding="application/x-tex">O(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>，我们可以观察到，当前节点的右儿子就是左子树中最右节点的下一个访问对象，同时当前节点的左儿子就是当前节点的下一个访问对象。利用这个特性，我们可以把右子树接到左子树的最右节点的右边，再把左子树接到当前节点的右边。见<code>flatten</code>。</p>
<pre><code class="language-c++">class Solution {
  public:
    void flatten(TreeNode *root) {
        TreeNode *cur = root;
        while (cur) {
            if (cur-&gt;left) {
                TreeNode *leftRightMost = cur-&gt;left;
                while (leftRightMost-&gt;right) {
                    leftRightMost = leftRightMost-&gt;right;
                }
                leftRightMost-&gt;right = cur-&gt;right;
                cur-&gt;right = cur-&gt;left;
                cur-&gt;left = nullptr;
            }
            cur = cur-&gt;right;
        }
    }

    void flattenNaive(TreeNode *root) {
        vector&lt;TreeNode *&gt; result;
        stack&lt;TreeNode *&gt; st;
        if (root) {
            st.push(root);
        }

        while (!st.empty()) {
            TreeNode *cur = st.top();
            st.pop();
            result.emplace_back(cur);
            if (cur-&gt;right) {
                st.push(cur-&gt;right);
            }
            if (cur-&gt;left) {
                st.push(cur-&gt;left);
            }
        }

        int size = result.size();
        for (int i = 0; i &lt; size - 1; ++i) {
            result[i]-&gt;left = nullptr;
            result[i]-&gt;right = result[i + 1];
        }
    }
};
</code></pre>
<h3 id="105-construct-binary-tree-from-preorder-and-inorder-traversal">[105] Construct Binary Tree from Preorder and Inorder Traversal</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/">题目描述</a>。<br>
类似<a href="#106-construct-binary-tree-from-inorder-and-postorder-traversal">[106] Construct Binary Tree from Inorder and Postorder Traversal</a>的题，这是这里从后序换成了前序，根节点自然也是从<code>preorder</code>的第一个开始找。<br>
此外，这里使用了哈希表<code>inorderMap</code>来加速了当前节点值在<code>inorder</code>中的索引的查找。<br>
最后，这道题还有迭代的解法，见<a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/solutions/255811/cong-qian-xu-yu-zhong-xu-bian-li-xu-lie-gou-zao-9/">这篇solution</a>。</p>
<pre><code class="language-c++">class Solution {
  public:
    TreeNode *traversal(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder,
                        int &amp;preIdx, int inorderLeft, int inorderRight,
                        unordered_map&lt;int, int&gt; &amp;inorderMap) {
        if (inorderLeft &gt;= inorderRight) {
            return nullptr;
        }

        TreeNode *cur = new TreeNode(preorder[preIdx]);
        // int inorderIndex =
        //     find(inorder.begin(), inorder.end(), preorder[preIdx]) -
        //     inorder.begin();
        // Opt: unordered_map
        int inorderIndex = inorderMap[preorder[preIdx]];
        ++preIdx;
        cur-&gt;left = traversal(preorder, inorder, preIdx, inorderLeft,
                              inorderIndex, inorderMap);
        cur-&gt;right = traversal(preorder, inorder, preIdx, inorderIndex + 1,
                               inorderRight, inorderMap);
        return cur;
    }

    TreeNode *buildTree(vector&lt;int&gt; &amp;preorder, vector&lt;int&gt; &amp;inorder) {
        unordered_map&lt;int, int&gt; inorderMap;
        int preIdx = 0;
        int idx = 0;
        for (int &amp;val : inorder) {
            inorderMap[val] = idx++;
        }
        return traversal(preorder, inorder, preIdx, 0, inorder.size(),
                         inorderMap);
    }
};
</code></pre>
<h3 id="437-path-sum-iii">[437] Path Sum III</h3>
<blockquote>
<p>难度：Medium<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/path-sum-iii/description/">题目描述</a>。<br>
在遍历的过程记录当前前缀和<code>curSum</code>以及path里面出现各个前缀和值的次数<code>prefix</code>（key为前缀和的值，value为值在当前path出现的次数）。通过查找<code>prefix[curSum - targetSum]</code>的值，便可得到以当前节点为结尾的满足条件的path数目。<br>
注意<code>prefix[curSum] += 1;</code>需要在<code>ret += prefix[curSum - targetSum];</code>的后面。这是因为空path我们是不算做结果的。如果在前面的话，会导致<code>targetSum</code>为0的时候这里<code>ret</code>的值多一。</p>
<pre><code class="language-c++">class Solution {
  public:
    int traversal(TreeNode *cur, int targetSum, long long curSum,
                  unordered_map&lt;long long, int&gt; &amp;prefix) {
        if (!cur) {
            return 0;
        }

        int ret = 0;

        curSum += cur-&gt;val;
        ret += prefix[curSum - targetSum];

        prefix[curSum] += 1;
        ret += traversal(cur-&gt;left, targetSum, curSum, prefix);
        ret += traversal(cur-&gt;right, targetSum, curSum, prefix);
        prefix[curSum] -= 1;

        return ret;
    }

    int pathSum(TreeNode *root, int targetSum) {
        unordered_map&lt;long long, int&gt; prefix;
        prefix[0] = 1;
        return traversal(root, targetSum, 0, prefix);
    }
};
</code></pre>
<h3 id="124-binary-tree-maximum-path-sum">[124] Binary Tree Maximum Path Sum</h3>
<blockquote>
<p>难度：Hard<br>
语言：C++</p>
</blockquote>
<p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/description/">题目描述</a>。<br>
标的难度是Hard但意外地很简单（大概在Easy到Medium之间）。<br>
每条Path我们可以看作是从某个节点出发分别从左右向下遍历的路径的拼接。因此，我们可以查看每个节点分别从左右向下走的最大路径和，然后再加上当前节点的数值与<code>maxSum</code>比较即可（<code>maxSum = max(cur-&gt;val + left + right, maxSum);</code>）。注意如果向下走的路径和为负数，则说明不走这条路径，返回0即可（<code>return max(0, cur-&gt;val + max(left, right));</code>）。</p>
<pre><code class="language-c++">class Solution {
  public:
    int traversal(TreeNode *cur, int &amp;maxSum) {
        if (!cur) {
            return 0;
        }

        int left = traversal(cur-&gt;left, maxSum);
        int right = traversal(cur-&gt;right, maxSum);
        maxSum = max(cur-&gt;val + left + right, maxSum);
        return max(0, cur-&gt;val + max(left, right));
    }

    int maxPathSum(TreeNode *root) {
        int maxSum = -__INT_MAX__ - 1;
        traversal(root, maxSum);
        return maxSum;
    }
};
</code></pre>
]]></content>
    </entry>
</feed>